<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>常青的小屋</title>
  
  <subtitle>劫回落山的太阳</subtitle>
  <link href="https://changqingaas.github.io/atom.xml" rel="self"/>
  
  <link href="https://changqingaas.github.io/"/>
  <updated>2022-02-04T04:55:19.194Z</updated>
  <id>https://changqingaas.github.io/</id>
  
  <author>
    <name>常青</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>matlab学习笔记</title>
    <link href="https://changqingaas.github.io/%E5%BB%BA%E6%A8%A1/math/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/%E5%BB%BA%E6%A8%A1/math/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-03T14:00:33.000Z</published>
    <updated>2022-02-04T04:55:19.194Z</updated>
    
    <content type="html"><![CDATA[<p>注： </p><ul><li>虽然文档很全面，但是这篇文章主要是为了在一天内速成，所以不足之处请多包涵。</li><li>代码基于vscode/py 3.6调用的matlab terminal</li></ul><h1 id="基本的数学运算与矩阵运算"><a href="#基本的数学运算与矩阵运算" class="headerlink" title="基本的数学运算与矩阵运算"></a>基本的数学运算与矩阵运算</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>不需声明</li><li>用 = 给变量赋值</li></ul><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><ul><li>变量名大小写敏感（不知道是不是因为在windows的原因</li><li>变量名只能由[<code>0~9</code>,<code>a~z</code>,<code>A~z</code>,<code>_</code>]组成,且变量名不能以数字开头.</li><li>保留变量不适合做变量名<ul><li>使用<code>iskeyword</code>命令可以查看程序关键字,这些关键字不允许被用作变量名.</li></ul></li></ul><div class="table-container"><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>ans</td><td>上一句运算的结果</td></tr><tr><td><strong>i,j</strong></td><td>复数算子，（这里需要留意）</td></tr><tr><td>Inf</td><td>无穷</td></tr><tr><td>eps</td><td>浮点相对精度,即1.0到下一个浮点数之间的距离(值为2.2204e-16)</td></tr><tr><td>NaN</td><td>非数字</td></tr><tr><td>pi</td><td>圆周率</td></tr></tbody></table></div><ul><li><p>变量名不应当覆盖内置函数名</p><ul><li><p>在MATLAB中,变量的调用优先级(calling priority)高于函数,因此变量名不应该覆盖内置函数.</p><p><img src='https://img-blog.csdnimg.cn/20191112184241114.png'></p></li><li><p>例如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">cos &#x3D; &#39;changqingaas&#39;;cos(8)% disp([&#39;ans is &#39;, num2str(ans)])clear; % 若某函数被变量名所覆盖,则调用clear &lt;变量名&gt;可以取消绑定在该函数名上的变量名cos(8)% disp([&#39;ans is &#39;, num2str(ans)])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：<code>clear</code>是一个比较危险的命令,因为该命令后若不加参数,则表示清除当前工作区内的所有变量.</p></li></ul></li></ul><pre><code>输出：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ans &#x3D;    &#39;n&#39;ans &#x3D;   -0.1455<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p><code>logical</code>,<code>char</code>,<code>numeric</code>,<code>cell</code>,<code>struct</code>以及由他们组成的数组或矩阵.</p><p><img src="https://img-blog.csdnimg.cn/20191112184307618.png" alt="MATLAB中的变量类型"></p><h5 id="数字型变量的显示格式"><a href="#数字型变量的显示格式" class="headerlink" title="数字型变量的显示格式"></a>数字型变量的显示格式</h5><p>数字型变量,默认以<code>double</code>形式存储的.</p><p>可以通过<code>format &lt;显示格式&gt;</code>改变数字型变量的显示格式.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203182051.png" alt="image-20220203182051494"></p><h3 id="MATLAB命令行"><a href="#MATLAB命令行" class="headerlink" title="MATLAB命令行"></a>MATLAB命令行</h3><ul><li><p>使用行尾<code>;</code>抑制输出: </p><ul><li>在一行命令后使用<code>;</code>抑制输出,否则运算结果将被显示在终端上.</li></ul></li><li><p>| 命令    | 作用                                                         | 运行结果                                                     |<br>| ———- | —————————————————————————————— | —————————————————————————————— |<br>| <code>clc</code>   | 清除终端的输出                                               |                                                              |<br>| <code>clear</code> | 默认清除当前工作区内所有变量                                 |                                                              |<br>| <code>who</code>   | 以简略格式显示工作区内所有变量                               | 您的变量为:<br>ans                                           |<br>| <code>whos</code>  | 以复杂格式显示工作区内所有变量                               | Name      Size            Bytes  Class     Attributes<br/>  ans       1x1                 8  double |<br>| which   | 查看内置函数源代码文件的位置,与<code>edit</code>命令结合可以查看内置函数的源代码. |                                                              |</p></li></ul><h2 id="使用MATLAB进行数字运算"><a href="#使用MATLAB进行数字运算" class="headerlink" title="使用MATLAB进行数字运算"></a>使用MATLAB进行数字运算</h2><h3 id="使用MATLAB计算数学表达式"><a href="#使用MATLAB计算数学表达式" class="headerlink" title="使用MATLAB计算数学表达式"></a>使用MATLAB计算数学表达式</h3><ul><li>数学表达式被计算后，其值被存入变量ans</li><li>log 表示 ln</li><li>exp(x) 表示 e^x</li></ul><h3 id="MATLAB内置的数学函数"><a href="#MATLAB内置的数学函数" class="headerlink" title="MATLAB内置的数学函数"></a>MATLAB内置的数学函数</h3><ul><li><p><a href="https://www.mathworks.com/help/matlab/arithmetic.html">MATLAB内置的算数运算函数</a></p><ul><li><p>基本运算:</p><ul><li>加: <code>+</code>,<code>sum</code>,<code>cumsum</code>,<code>movsum</code></li><li>减: <code>-</code>,<code>diff</code></li><li>乘: <code>.*</code>,<code>*</code>,<code>prod</code>,<code>cumprod</code></li><li>除: <code>./</code>,<code>.\</code>,<code>/</code>,<code>\</code></li><li>乘方: <code>.^</code>,<code>^</code></li></ul></li><li><p>取模运算: <code>mod</code>,<code>rem</code>,<code>idivide</code>,<code>ceil</code>,<code>fix</code>,<code>floor</code>,<code>round</code></p></li></ul></li><li><p><a href="http://www.mathworks.com/help/matlab/trigonometry.html">MATLAB内置的三角运算函数</a></p><ul><li>正弦: sin,sind,sinpi,asin,asind,sinh,asinh</li><li>余弦: cos,cosd,cospi,acos,acosd,cosh,acosh</li><li>正切: tan,tand,atan,atand,atan2,atan2d,tanh,atanh</li><li>余割: csc,cscd,acsc,acscd,csch,acsch</li><li>正割: sec,secd,asec,asecd,sech,asech</li><li>余切: cot,cotd,acot,acotd,coth,acoth</li><li>斜边: hypot</li><li>转换: deg2rad,rad2deg,cart2pol,cart2sph,pol2cart,sph2cart</li></ul></li><li><p><a href="https://ww2.mathworks.cn/help/matlab/exponents-and-logarithms.html">MATLAB内置的指数对数函数: </a></p><ul><li>exp,expm1,log,log10,log1p,log2,nextpow2,nthroot,pow2,reallog,realpow,realsqrt,sqr</li></ul></li><li><p><a href="https://www.mathworks.com/help/matlab/complex-numbers.html">MATLAB内置的复函数: </a></p><ul><li>abs,angle,complex,conj,cplxpair,i,imag,isreal,j,real,sign,unwrap</li></ul></li></ul><h2 id="使用MATLAB进行矩阵运算"><a href="#使用MATLAB进行矩阵运算" class="headerlink" title="使用MATLAB进行矩阵运算"></a>使用MATLAB进行矩阵运算</h2><h3 id="定义矩阵"><a href="#定义矩阵" class="headerlink" title="定义矩阵"></a>定义矩阵</h3><h4 id="向终端输入矩阵"><a href="#向终端输入矩阵" class="headerlink" title="向终端输入矩阵"></a>向终端输入矩阵</h4><p>在MATLAB中,使用[]将待输入的矩阵内容括起来,使用空格或逗号,分隔行内变量,使用;分隔每一行.</p><div class="table-container"><table><thead><tr><th><strong>MATLAB命令</strong></th><th><strong>得到的矩阵</strong></th></tr></thead><tbody><tr><td>[1 2 3 4]</td><td>[1 2 3 4]</td></tr><tr><td>[1; 2; 3; 4]</td><td>$\begin{bmatrix}1 \\ 2 \\ 3 \\ 4\end{bmatrix}$</td></tr><tr><td>[1 21 6; 5 17 9; 31 2 7]</td><td>$\begin{bmatrix} 1 &amp; 21 &amp; 6 \\ 5 &amp; 17 &amp; 9 \\ 31 &amp; 2 &amp; 7 \end{bmatrix}$</td></tr></tbody></table></div><h4 id="使用冒号运算符创建向量"><a href="#使用冒号运算符创建向量" class="headerlink" title="使用冒号运算符创建向量"></a>使用冒号运算符创建向量</h4><p>使用冒号运算符:可以创建一个长向量,其语法如下:</p><div class="table-container"><table><thead><tr><th><strong>冒号表达式</strong></th><th><strong>得到的结果</strong></th></tr></thead><tbody><tr><td>j:k</td><td>[j,j+1,j+2,…,k]</td></tr><tr><td>j:i:k</td><td>[j,j+i,j+2*i,…,j+m∗i]</td></tr></tbody></table></div><p> 例如：</p><div class="table-container"><table><thead><tr><th><strong>MATLAB语句</strong></th><th><strong>得到的结果</strong></th></tr></thead><tbody><tr><td>1:5</td><td>[1 2 3 4 5]</td></tr><tr><td>1:3:5</td><td>[1 4]</td></tr><tr><td>[1:3; 2:3:10]</td><td>$\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 2 &amp; 5 &amp; 8 \end{bmatrix}$</td></tr><tr><td>‘a’:2:’z’</td><td>‘acegikmoqsuwy’</td></tr></tbody></table></div><h4 id="定义特殊矩阵"><a href="#定义特殊矩阵" class="headerlink" title="定义特殊矩阵"></a>定义特殊矩阵</h4><div class="table-container"><table><thead><tr><th><strong>命令</strong></th><th><strong>得到的结果</strong></th></tr></thead><tbody><tr><td>eye(n)</td><td>得到一个n × n 的单位矩阵</td></tr><tr><td>zeros(n1, n2)</td><td>得到一个n1 × n2  的全0矩阵</td></tr><tr><td>ones(n1, n2)</td><td>得到一个n1 × n2  的全1矩阵</td></tr><tr><td>diag(vector)</td><td>得到一个以向量<code>vector</code>中内容为对角线的对角矩阵</td></tr></tbody></table></div><h3 id="矩阵的索引"><a href="#矩阵的索引" class="headerlink" title="矩阵的索引"></a>矩阵的索引</h3><ul><li><p>MATLAB中的矩阵是以<strong>列</strong>序存储的.且索引下标从1开始.</p></li><li><p>矩阵有两种索引方式: 按一维索引和按二维索引.对于一个一般的矩阵,其索引顺序如下:</p><ul><li>$\begin{bmatrix} 1或(1,1) &amp; 4或(1,2) &amp; 7或(1,3) \\ 2或(2,1) &amp; 5或(2,2) &amp; 8或(2,3) \\ 3或(3,1) &amp; 6或(3,2) &amp;9或(3,3)  \end{bmatrix}$</li></ul></li><li><p>矩阵的索引可以使用冒号<code>:</code>,表示选取所有行或所有列.</p></li><li><p>矩阵的索引可以是一个或两个向量,表示选中向量内的所有行或所有列.</p><p>| <strong>原矩阵</strong>                                                   | <strong>索引</strong>        | <strong>得到的结果</strong>                                          |<br>| —————————————————————————————— | ———————- | ———————————————————————————- |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A(8)            | 6                                                       |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1 3 5])      | [1 7 5]                                                 |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1 2; 3 4])   | $\begin{bmatrix} 1 &amp; 4 \\ 7 &amp; 2\end{bmatrix}$           |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A(3,2)          | 8                                                       |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1,2], :)     | $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp;  5 &amp; 6 \end{bmatrix}$ |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1 3], [1 2]) | $\begin{bmatrix} 1 &amp; 2 \\ 7 &amp; 8 \end{bmatrix}$          |</p></li></ul><h3 id="矩阵的操作"><a href="#矩阵的操作" class="headerlink" title="矩阵的操作"></a>矩阵的操作</h3><h4 id="操作矩阵的运算符"><a href="#操作矩阵的运算符" class="headerlink" title="操作矩阵的运算符"></a>操作矩阵的运算符</h4><div class="table-container"><table><thead><tr><th>运算符</th><th>操作</th><th>形式</th><th>例子</th></tr></thead><tbody><tr><td><code>+</code></td><td>矩阵与向量相加</td><td><code>A+b</code></td><td><code>[6 3] + 2 = [8 5]</code></td></tr><tr><td><code>-</code></td><td>矩阵与向量相减</td><td><code>A-b</code></td><td><code>[6 3] - 2 = [4 1]</code></td></tr><tr><td><code>+</code></td><td>矩阵与矩阵对应位置相加</td><td><code>A+B</code></td><td><code>[6 3] + [4 8] = [10 11]</code></td></tr><tr><td><code>-</code></td><td>矩阵与矩阵对应位置相减</td><td><code>A-B</code></td><td><code>[6 3] - [4 8] = [2 -5]</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>*</code></td><td>矩阵与矩阵相乘</td><td><code>A*B</code></td><td><code>[6 3] * [4 8]&#39; = 48</code></td></tr><tr><td><code>.*</code></td><td>矩阵与矩阵对应位置相乘</td><td><code>A.*B</code></td><td><code>[6 3] * [4 8] = [24 24]</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>/</code></td><td>矩阵与矩阵右除(等价于<code>A*inv(B)</code>)</td><td><code>A/B</code></td><td><code>[6 3] / [4 8] = 0.6</code></td></tr><tr><td><code>\</code></td><td>矩阵与矩阵左除(等价于<code>inv(A)*B</code>)</td><td><code>A\B</code></td><td><code>[6 3] / [4 8] = [0.06667 1.3333; 0 0]</code></td></tr><tr><td><code>./</code></td><td>矩阵与矩阵对应位置右除</td><td><code>A./B</code></td><td><code>[6 3] ./ [4 8] = [1.5 0.375]</code></td></tr><tr><td><code>.\</code></td><td>矩阵与矩阵对应位置左除</td><td><code>A.\B</code></td><td><code>[6 3] .\ [4 8] = [0.6667 2.6667]</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>^</code></td><td>矩阵与向量乘方</td><td><code>A^b</code></td><td><code>[1 2; 3 4]^3 = [37 54; 81 118]</code></td></tr><tr><td><code>.^</code></td><td>矩阵与矩阵对应位置乘方</td><td><code>A.^B</code></td><td><code>[1 2; 3 4].^[1 2; 3 4] = [1 4; 27 256]</code></td></tr></tbody></table></div><h4 id="操作矩阵的函数"><a href="#操作矩阵的函数" class="headerlink" title="操作矩阵的函数"></a>操作矩阵的函数</h4><p>对下面的矩阵</p><script type="math/tex; mode=display">A=\begin{bmatrix} 1 & 2 & 3 \\ 0 & 5 & 6 \\ 7 & 0 & 9 \end{bmatrix}</script><p>进行操作以演示操作矩阵的常见函数</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td><code>max(A, [], dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的最大值</td><td><code>max(A, [], 1)</code></td><td>$\begin{bmatrix} 7 &amp; 5 &amp; 9 \end{bmatrix}$</td></tr><tr><td><code>min(A, [], dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的最小值</td><td><code>min(A, [], 2)</code></td><td>$\begin{bmatrix} 1 &amp; 0 &amp; 0 \end{bmatrix}$</td></tr><tr><td><code>sum(A, dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的和</td><td><code>sum(A, 1)</code></td><td>$\begin{bmatrix} 8 &amp; 7 &amp; 18 \end{bmatrix}$</td></tr><tr><td><code>mean(A, dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的平均值</td><td><code>mean(A, 1)</code></td><td>[2.66672.33336.0000]</td></tr><tr><td><code>sort(A, dim, direction)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上按<code>direction</code>顺序排序结果</td><td><code>sort(A, 1, &#39;descend&#39;)</code></td><td>$\begin{bmatrix} 7 &amp; 5 &amp; 9 \\\ 1 &amp; 2 &amp; 6 \\ 0 &amp; 0 &amp; 3 \end{bmatrix}$</td></tr><tr><td><code>sortrows(A, column)</code></td><td>获取矩阵<code>A</code>按照每行第<code>column</code>个元素升序排序结果.</td><td><code>sortrows(A, 2)</code></td><td>$\begin{bmatrix}  7 &amp; 0 &amp; 9\\ 1 &amp; 2 &amp; 3\\ 0 &amp; 5 &amp; 6\end{bmatrix}$</td></tr><tr><td><code>size(A, dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的形状.若不指定<code>dim</code>,则返回整个矩阵的形状.</td><td><code>size(A)</code></td><td>[3 3]</td></tr><tr><td><code>find(A, n)</code></td><td>获取矩阵<code>A</code>前<code>n</code>个非零元素的索引</td><td>`find(A,5)</td><td>[1 3 4 5 7]</td></tr></tbody></table></div><p>对于上面这些函数,除第一个参数以外,其它参数都是可选的.</p><h1 id="结构化编程和函数定义"><a href="#结构化编程和函数定义" class="headerlink" title="结构化编程和函数定义"></a>结构化编程和函数定义</h1><h2 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h2><h3 id="流程控制语句和逻辑运算符"><a href="#流程控制语句和逻辑运算符" class="headerlink" title="流程控制语句和逻辑运算符"></a>流程控制语句和逻辑运算符</h3><div class="table-container"><table><thead><tr><th>流程控制语句</th><th>作用</th></tr></thead><tbody><tr><td><code>if, elseif, else</code></td><td>若<code>if</code>语句为真,则执行子句</td></tr><tr><td><code>switch, case, otherwise</code></td><td>根据<code>switch</code>语句内容判断执行哪个子句</td></tr><tr><td><code>while</code></td><td>重复执行子句直到<code>while</code>中的条件为假</td></tr><tr><td><code>for</code></td><td>执行子句固定次数</td></tr><tr><td><code>try, catch</code></td><td>执行子句并捕获执行过程中的异常</td></tr><tr><td><code>break</code></td><td>跳出循环</td></tr><tr><td><code>continue</code></td><td>直接进入下一次循环</td></tr><tr><td><code>end</code></td><td>结束子句</td></tr><tr><td><code>pause</code></td><td>暂停程序</td></tr><tr><td><code>return</code></td><td>返回到调用函数处</td></tr></tbody></table></div><p>上述所有循环和条件语句都要在末尾以<code>end</code>闭合.</p><p>MATLAB还有以下逻辑运算符:</p><div class="table-container"><table><thead><tr><th>运算符</th><th>意义</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td></tr><tr><td><code>~=</code></td><td>不等于</td></tr><tr><td><code>&amp;&amp;</code></td><td>且(支持逻辑短路)</td></tr><tr><td>`</td><td></td><td>`</td><td>或(支持逻辑短路)</td></tr></tbody></table></div><h4 id="流程控制语句示例"><a href="#流程控制语句示例" class="headerlink" title="流程控制语句示例"></a>流程控制语句示例</h4><h5 id="if-语句："><a href="#if-语句：" class="headerlink" title="if 语句："></a>if 语句：</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">if condition1statement1elseif condition2statement2else statement3end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">switch expression    case value1        statement1    case value2        statement2    otherwise         statementend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">while expressionstatementend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">for variable &#x3D; start:increment:endcommandsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 2; k &#x3D; 0; error &#x3D; inf;error_threshold &#x3D; 1e-32;while error &gt; error_threshold    if k &gt; 100        break    end    x &#x3D; x - sin(x) &#x2F; cos(x);    error &#x3D; abs(x - pi);    k &#x3D; k + 1;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用循环语句应尽量预先分配内存空间"><a href="#使用循环语句应尽量预先分配内存空间" class="headerlink" title="使用循环语句应尽量预先分配内存空间"></a>使用循环语句应尽量预先分配内存空间</h4><h3 id="编写脚本时应注意的问题"><a href="#编写脚本时应注意的问题" class="headerlink" title="编写脚本时应注意的问题"></a>编写脚本时应注意的问题</h3><h4 id="在脚本开头应添加语句清空工作区"><a href="#在脚本开头应添加语句清空工作区" class="headerlink" title="在脚本开头应添加语句清空工作区"></a>在脚本开头应添加语句清空工作区</h4><p>在每个脚本的开头,应添加下述语句,清空工作区缓存以及之前程序运行的痕迹:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear all% 清空工作区内存中的变量close all % 关闭之前程序绘制的图像clc% 清空之前程序在终端的输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="在运算和赋值语句后应添加分号-抑制输出"><a href="#在运算和赋值语句后应添加分号-抑制输出" class="headerlink" title="在运算和赋值语句后应添加分号;抑制输出"></a>在运算和赋值语句后应添加分号<code>;</code>抑制输出</h4><p>在所有运算和赋值语句都应该添加分号<code>;</code>抑制输出,若需要向终端输出一个变量,应对其调用<code>disp</code>方法.</p><h4 id="使用省略号-拼接多行语句"><a href="#使用省略号-拼接多行语句" class="headerlink" title="使用省略号...拼接多行语句"></a>使用省略号<code>...</code>拼接多行语句</h4><p>在MATLAB中,省略号<code>...</code>可以将多行语句拼接为一行,灵活使用该语句可以提高代码可读性.</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>与脚本类似,函数可以被存入<code>函数名.m</code>文件中,也可以以函数句柄的形式定义在内存中.</p><h3 id="查看内置函数"><a href="#查看内置函数" class="headerlink" title="查看内置函数"></a>查看内置函数</h3><p>我们可以使用<code>which</code>命令查看内置函数源代码文件的位置,与<code>edit</code>命令结合可以查看内置函数的源代码.</p><p>运行下面语句可以打开MATLAB内置的<code>mean</code>函数的源文件:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">edit(which(&#39;mean.m&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203200209.png" alt="mean函数源代码"></p><h3 id="以函数名-m文件形式定义函数"><a href="#以函数名-m文件形式定义函数" class="headerlink" title="以函数名.m文件形式定义函数"></a>以<code>函数名.m</code>文件形式定义函数</h3><p>在MATLAB文件中定义函数的格式如下:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function [输出变量名] &#x3D; 函数名(输入变量名) % 函数的文档函数代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>function</code>是一个关键字,声明该文件中保存的是一个函数.</li><li><code>输入变量</code>和<code>输出变量</code>是非必须的,函数既可以没有输入变量,也可以没有输出变量.</li><li><code>函数名</code>应与<code>.m</code>文件名相同,且不包含特殊字符(最好不要有中文).</li></ul><h4 id="MATLAB内置的函数参数"><a href="#MATLAB内置的函数参数" class="headerlink" title="MATLAB内置的函数参数"></a>MATLAB内置的函数参数</h4><div class="table-container"><table><thead><tr><th>函数参数</th><th>意义</th></tr></thead><tbody><tr><td><code>imputname</code></td><td>输入变量名列表</td></tr><tr><td><code>mfilename</code></td><td>函数源代码文件名</td></tr><tr><td><code>nargin</code></td><td>输入变量数</td></tr><tr><td><code>nargout</code></td><td>输出变量个数</td></tr><tr><td><code>varargin</code></td><td>可变长输入参数列表</td></tr><tr><td><code>varargout</code></td><td>可变长输出参数列表</td></tr></tbody></table></div><p>MATLAB不提供其他高级语言的指定默认参数值以及函数重载等语法,但灵活使用上述内置的函数参数,可以在一定程度上实现指定默认参数值以及方法重载:</p><h4 id="MATLAB函数定义示例1"><a href="#MATLAB函数定义示例1" class="headerlink" title="MATLAB函数定义示例1"></a>MATLAB函数定义示例1</h4><p>面程序用来计算自由落体运动中位移量:<br>$x = x_{0} + v_{0}t + \frac{1}{2} g t^2 $</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function x &#x3D; freebody(x0,v0,t)% calculation of free falling% x0: initial displacement in m% v0: initial velocity in m&#x2F;sec% t: the elapsed time in sec% x: the depth of falling in mx &#x3D; x0 + v0.*t + 1&#x2F;2*9.8*t.*t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数演示了一个MATLAB编程技巧: 计算乘法时应尽量使用<code>.*</code>而非<code>*</code>,因为前者不仅对参数<code>t</code>为标量的情况可用,也对变量<code>t</code>为向量或矩阵的情况可用.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">freebody(0, 0, 2)% 得到 19.6000freebody(0, 0, [0 1 2 3])% 得到 [0 4.9000 19.6000 44.1000]freebody(0, 0, [0 1; 2 3])% 得到 [0 4.9000; 19.6000 44.1000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="MATLAB函数定义示例2"><a href="#MATLAB函数定义示例2" class="headerlink" title="MATLAB函数定义示例2"></a>MATLAB函数定义示例2</h4><p>下面函数实现了从华氏温度到摄氏温度的转换,该函数可以识别输入的待转换样例的个数,当输入的待转换样例个数为0时,退出函数.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function F2C()while 1    F_degree &#x3D; input(&#39;tempreature in Fahrenheit: &#39;, &#39;s&#39;);    F_degree &#x3D; str2num(F_degree);    if isempty(F_degree)        return    end    C_degree &#x3D; (F_degree-32)*5&#x2F;9;    disp([&#39;tempreature in Celsius: &#39; num2str(C_degree)])end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203201516.png" alt="F2C函数执行结果"></p><h3 id="以函数句柄形式定义函数"><a href="#以函数句柄形式定义函数" class="headerlink" title="以函数句柄形式定义函数"></a>以函数句柄形式定义函数</h3><p>我们也可以使用函数句柄的形式定义函数,这更接近数学上的函数定义,其语法如下:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">函数句柄 &#x3D; @(输入变量) 输出变量 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以直接通过函数句柄调用该方法.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x) exp(-2*x);x &#x3D; 0:0.1:2;plot(x, f(x));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="数据类型与文件读写"><a href="#数据类型与文件读写" class="headerlink" title="数据类型与文件读写"></a>数据类型与文件读写</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MATLAB中主要的数据类型如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203202237.png" alt="MATLAB中的数据类型"></p><h3 id="数值类型-numeric"><a href="#数值类型-numeric" class="headerlink" title="数值类型(numeric)"></a>数值类型(numeric)</h3><p>MATLAB支持的数值类型见下表:</p><div class="table-container"><table><thead><tr><th>数值类型</th><th>描述</th></tr></thead><tbody><tr><td><code>double</code></td><td>双精度浮点数</td></tr><tr><td><code>single</code></td><td>单精度浮点数</td></tr><tr><td><code>int8</code></td><td>8位带符号整数</td></tr><tr><td><code>int16</code></td><td>16位带符号整数</td></tr><tr><td><code>int32</code></td><td>32位带符号整数</td></tr><tr><td><code>int64</code></td><td>64位带符号整数</td></tr><tr><td><code>uint8</code></td><td>8位无符号整数</td></tr><tr><td><code>uint16</code></td><td>16位无符号整数</td></tr><tr><td><code>uint32</code></td><td>32位无符号整数</td></tr><tr><td><code>uint64</code></td><td>64位无符号整数</td></tr></tbody></table></div><p>在MATLAB中,数值类型的变量被默认为<code>double</code>类型的,可以使用类型转换将其转换为其他数值类型.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">n &#x3D; 3;class(n) n &#x3D; int8(3);class(n) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ans &#x3D;    &#39;double&#39;ans &#x3D;    &#39;int8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串类型-char"><a href="#字符串类型-char" class="headerlink" title="字符串类型(char)"></a>字符串类型(char)</h3><ul><li><p>在MATLAB中,字符串类型由一对单引号<code>&#39;</code>包裹一段文字来定义.标准ASCII字符可以被转换为对应的ASCII码.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">s1 &#x3D; &#39;h&#39;;uint16(s1)% 得到 104<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>字符串在内存中是以字符矩阵的形式存储的,可以对其进行矩阵的索引以及赋值操作:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">str1 &#x3D; &#39;hello&#39;;str2 &#x3D; &#39;world&#39;;str3 &#x3D; [str1 str2];size(str3)% 得到 [1 10]str4 &#x3D; [str1; str2];size(str4)% 得到 [2 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">str &#x3D; &#39;aardvark&#39;;&#39;a&#39; &#x3D;&#x3D; str% 得到 [1 1 0 0 0 1 0 0]str(str &#x3D;&#x3D; &#39;a&#39;) &#x3D; &#39;Z&#39;% 得到 &#39;ZZrdvZrk&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="结构体-structure"><a href="#结构体-structure" class="headerlink" title="结构体(structure)"></a>结构体(structure)</h3><p>在MATLAB中,结构体是一个键值对</p><h4 id="结构体的基本使用"><a href="#结构体的基本使用" class="headerlink" title="结构体的基本使用"></a>结构体的基本使用</h4><ul><li>与大多数编程语言类似,MATLAB使用<code>.</code>来访问结构体中的字段:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203202908.png" alt="结构体"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">student.name &#x3D; &#39;John Doe&#39;;student.id &#x3D; &#39;jdo2@sfu.ca&#39;;student.number &#x3D; 301073268;student.grade &#x3D; [100, 75, 73; ...                 95, 91, 85.5; ...                 100, 98, 72];student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对结构体列表使用下标表达式可以扩充或缩减结构体列表.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203203208.png" alt="结构体数组"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">student.name &#x3D; &#39;John Doe&#39;;student.id &#x3D; &#39;jdo2@sfu.ca&#39;;student.number &#x3D; 301073268;student.grade &#x3D; [100, 75, 73; 95, 91, 85.5; 100, 98, 72];studentstudent(2).name &#x3D; &#39;Ann Lane&#39;;student(2).id &#x3D; &#39;aln4@sfu.ca&#39;;student(2).number &#x3D; 301078853;student(2).grade &#x3D; [95 100 90; 95 82 97; 100 85 100];student(1) &#x3D; [] % 删除student列表第一项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体可以级联,即结构体中字段的取值也可以是结构体:</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A &#x3D; struct(&#39;data&#39;, [3 4 7; 8 0 1], ...&#39;nest&#39;, struct(&#39;testnum&#39;, &#39;Test 1&#39;, ...&#39;xdata&#39;, [4 2 8], ...&#39;ydata&#39;, [7 1 6]));A(2).data &#x3D; [9 3 2; 7 6 5];A(2).nest.testnum &#x3D; &#39;Test 2&#39;;A(2).nest.xdata &#x3D; [3 4 2];A(2).nest.ydata &#x3D; [5 0 9];A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="结构体的常用函数"><a href="#结构体的常用函数" class="headerlink" title="结构体的常用函数"></a>结构体的常用函数</h4><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>struct</code></td><td>创建结构体</td></tr><tr><td><code>struct2cell</code></td><td>将结构体转换为元胞数组</td></tr><tr><td><code>cell2struct</code></td><td>将元胞数组转换为结构体</td></tr><tr><td><code>isstruct</code></td><td>判断某变量是否是结构体</td></tr><tr><td><code>structfun</code></td><td>对结构体的每个字段都应用某函数</td></tr><tr><td></td><td></td></tr><tr><td><code>fieldnames</code></td><td>获取结构体的所有字段名</td></tr><tr><td><code>isfield</code></td><td>判断结构体是否包含某字段</td></tr><tr><td><code>getfield</code></td><td>获取结构体某字段的值</td></tr><tr><td><code>setfield</code></td><td>为结构体中的某字段赋值</td></tr><tr><td><code>rmfield</code></td><td>删除结构体中的某字段</td></tr><tr><td><code>orderfields</code></td><td>为结构体字段排序</td></tr></tbody></table></div><h3 id="元胞数组-cell"><a href="#元胞数组-cell" class="headerlink" title="元胞数组(cell)"></a>元胞数组(cell)</h3><p>在MATLAB中,元胞数组是一个可以容纳不同类型元素的数据结构,类似于Python语言中的列表.</p><h4 id="元胞数组的基本使用"><a href="#元胞数组的基本使用" class="headerlink" title="元胞数组的基本使用"></a>元胞数组的基本使用</h4><ul><li><p>使用<code>&#123;&#125;</code>像定义矩阵一样定义元胞数组:</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203205945.png" alt="元胞数组"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A &#x3D; &#123; [1 4 3; 0 5 8; 7 2 9]&#39;Anne Smith&#39; ;...3+7i-pi:pi:pi&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A(1,1)&#x3D;&#123;[1 4 3; 0 5 8; 7 2 9]&#125;;A(1,2)&#x3D;&#123;&#39;Anne Smith&#39;&#125;;A(2,1)&#x3D;&#123;3+7i&#125;;A(2,2)&#x3D;&#123;-pi:pi:pi&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A&#123;1,1&#125;&#x3D;[1 4 3; 0 5 8; 7 2 9];A&#123;1,2&#125;&#x3D;&#39;Anne Smith&#39;;A&#123;2,1&#125;&#x3D;3+7i;A&#123;2,2&#125;&#x3D;-pi:pi:pi;A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面三种方式是等价的,其中第二种方式使用<strong>单元索引</strong>赋值,而第三种方式使用<strong>内容索引</strong>赋值.</p><ul><li><p>有两种方式访问元胞数组中的数据,分别是: <strong>单元索引</strong><code>()</code>和<strong>内容索引</strong><code>&#123;&#125;</code></p><p>因为元胞数组的子集仍为元胞数组,在索引器内容的使用,我们有必要指明我们要访问的的是一个<strong>子元胞数组</strong>还是<strong>元胞数组对应区域中的内容</strong>.</p><ul><li><p>使用<strong>单元索引</strong><code>()</code>,我们得到的是一个<strong>子元胞数组</strong>.</p><ul><li>使用<strong>内容索引</strong><code>&#123;&#125;</code>,我们得到的是<strong>元胞数组对应区域中的内容</strong>.</li></ul></li></ul></li></ul><h4 id="元胞数组的常用函数"><a href="#元胞数组的常用函数" class="headerlink" title="元胞数组的常用函数"></a>元胞数组的常用函数</h4><h3 id="元胞数组的常用函数-1"><a href="#元胞数组的常用函数-1" class="headerlink" title="元胞数组的常用函数"></a>元胞数组的常用函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>cell</code></td><td>创建一个元胞数组</td></tr><tr><td><code>iscell</code></td><td>判断某变量是否为元胞数组</td></tr><tr><td></td><td></td></tr><tr><td><code>cell2mat</code></td><td>将元胞数组转为矩阵</td></tr><tr><td><code>cell2struct</code></td><td>将元胞数组转为结构体</td></tr><tr><td><code>mat2cell</code></td><td>将数组转换为指定大小元胞数组</td></tr><tr><td><code>num2cell</code></td><td>将数组转换为相同大小的元胞数组</td></tr><tr><td><code>struct2cell</code></td><td>将结构体转换为元胞数组</td></tr><tr><td></td><td></td></tr><tr><td><code>celldisp</code></td><td>递归显示元胞数组中的内容</td></tr><tr><td><code>cellplot</code></td><td>以图像形式绘制元胞数组的结构</td></tr><tr><td><code>cellfun</code></td><td>对元胞数组的每个元胞应用某函数</td></tr></tbody></table></div><p>其中<code>mat2cell</code>函数可以在转换的时候指定元胞数组各元胞的尺寸.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; magic(3)b &#x3D; num2cell(a)% 得到% [8] [1] [6]% [3] [5] [7]% [4] [9] [2]c &#x3D; mat2cell(a, [1 2], [2, 1])% 得到% [1x2 double] [6]% [2x2 double] [2x1 double]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高维元胞数组"><a href="#高维元胞数组" class="headerlink" title="高维元胞数组"></a>高维元胞数组</h4><p>一个三维的元胞数组可以有<strong>行</strong>(row),<strong>列</strong>(column),<strong>层</strong>(layer)三个维度.在对元胞数组进行索引时,优先级从高到低的顺序分别是: 行→列→层.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203210656.png" alt="高维元胞数组"></p><p>使用<code>cat</code>函数可以在指定维度上对元胞数组进行拼接.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203210809.png" alt="元胞数组的拼接"></p><h3 id="判断变量数据类型的函数"><a href="#判断变量数据类型的函数" class="headerlink" title="判断变量数据类型的函数"></a>判断变量数据类型的函数</h3><p>下列函数可以对变量类型进行判断:</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>isinteger</code></td><td>判断输入参数是否为整型数数组</td></tr><tr><td><code>islogical</code></td><td>判断输入参数是否为逻辑量数组</td></tr><tr><td><code>isnumeric</code></td><td>判断输入参数是否为数值数组</td></tr><tr><td><code>isreal</code></td><td>判断输入参数是否为实数数组</td></tr><tr><td><code>ischar</code></td><td>判断输入参数是否为字符数组</td></tr><tr><td><code>iscell</code></td><td>判断输入参数是否为元胞数组</td></tr><tr><td><code>isfloat</code></td><td>判断输入数组是否为浮点数组</td></tr><tr><td><code>ishandle</code></td><td>判断输入数组是否有效的图形句柄</td></tr><tr><td><code>isempty</code></td><td>判断输入数组是否为空</td></tr><tr><td><code>isprime</code></td><td>确定哪些数组元素为质数</td></tr><tr><td><code>isnan</code></td><td>确定哪些数组元素为<code>NaN</code></td></tr><tr><td><code>isinf</code></td><td>确定哪些数组元素为<code>Inf</code></td></tr><tr><td><code>isequal</code></td><td>判断数组是否相等</td></tr></tbody></table></div><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>支持的文件类型如下:</p><div class="table-container"><table><thead><tr><th>文件内容</th><th>扩展名</th><th>读取文件的函数</th><th>写入文件的函数</th></tr></thead><tbody><tr><td>MATLAB数据</td><td><code>*.mat</code></td><td><code>load</code></td><td><code>save</code></td></tr><tr><td>Excel表格</td><td><code>*.xls</code>,<code>*.xlsx</code></td><td><code>xlsread</code></td><td><code>xlswrite</code></td></tr><tr><td>空格分隔的数字</td><td><code>*.txt</code></td><td><code>load</code></td><td><code>save</code></td></tr></tbody></table></div><h3 id="读写MATLAB格式的数据"><a href="#读写MATLAB格式的数据" class="headerlink" title="读写MATLAB格式的数据"></a>读写MATLAB格式的数据</h3><p>MATLAB工作区内的数据可以以<code>*.mat</code>格式保存在文件中.使用<code>save</code>函数将数据存入文件,使用<code>load</code>函数从文件中读取数据.</p><ul><li><p><code>save</code></p><p>函数的语法如下:</p><ul><li><code>save(filename,variables)</code>将变量<code>variables</code>以二进制形式存入文件中.</li><li><code>save(filename,variables,&#39;-ascii&#39;)</code>将变量<code>variables</code>以文本形式存入文件中.</li></ul></li><li><p><code>load</code></p><p>函数的语法如下:</p><ul><li><code>load(filename)</code>从二进制形式文件中读取数据.</li><li><code>load(filename,&#39;-ascii&#39;)</code>从文本形式文件中读取数据.</li></ul></li></ul><p>其中参数<code>filename</code>和<code>variables</code>都是字符串格式,若不指定<code>variables</code>参数,则将当前工作区内所有变量存入文件中.</p><blockquote><p>复杂的数据格式,如<code>struct</code>和<code>cell</code>,不支持以二进制格式存储.</p></blockquote><h3 id="读写Excel表格"><a href="#读写Excel表格" class="headerlink" title="读写Excel表格"></a>读写Excel表格</h3><p>使用<code>xlsread</code>和<code>xlswrite</code>函数可以读写Excel数据,语法如下:</p><ul><li><p>读取Excel文件的语法:<code>[num,txt,raw] = xlsread(filename,sheet,xlRange)</code></p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203211325.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">Score &#x3D; xlsread(&#39;04Score.xlsx&#39;)Score &#x3D; xlsread(&#39;04Score.xlsx&#39;, &#39;B2:D4&#39;)[Score Header] &#x3D; xlsread(&#39;04Score.xlsx&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>写入Excel的语法:<code>xlswrite(filename,A,sheet,xlRange)</code></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">M &#x3D; mean(Score);xlswrite(&#39;04Score.xlsx&#39;, M, 1, &#39;E2:E4&#39;);xlswrite(&#39;04Score.xlsx&#39;, &#123;&#39;Mean&#39;&#125;, 1, &#39;E1&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h1><h2 id="图线的绘制与装饰"><a href="#图线的绘制与装饰" class="headerlink" title="图线的绘制与装饰"></a>图线的绘制与装饰</h2><h3 id="使用plot-函数绘制图线"><a href="#使用plot-函数绘制图线" class="headerlink" title="使用plot()函数绘制图线"></a>使用<code>plot()</code>函数绘制图线</h3><p>在MATLAB中,使用<code>plot()</code>函数绘制图线,其语法为:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">plot(x,y,LineSpec)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>LineSpec</code>: 图线的线条设定,三个指定<strong>线型</strong>,<strong>标记符号</strong>和<strong>颜色</strong>的<strong>设定符</strong>组成一个字符串,设定符不区分先后.具体细节请参考<a href="https://www.mathworks.com/help/matlab/ref/linespec.html">官方文档</a>.</p><div class="table-container"><table><thead><tr><th>线型符号</th><th>线型设定符</th><th>标记</th><th>标记设定符</th><th>颜色</th><th>颜色设定符</th></tr></thead><tbody><tr><td><code>-</code></td><td>实线（默认）</td><td><code>o</code></td><td>圆圈</td><td><code>y</code></td><td>黄色</td></tr><tr><td><code>--</code></td><td>虚线</td><td><code>+</code></td><td>加号</td><td><code>m</code></td><td>品红色</td></tr><tr><td><code>:</code></td><td>点线</td><td><code>*</code></td><td>星号</td><td><code>c</code></td><td>青蓝色</td></tr><tr><td><code>-.</code></td><td>点划线</td><td><code>.</code></td><td>点</td><td><code>r</code></td><td>红色</td></tr><tr><td></td><td></td><td><code>x</code></td><td>叉号</td><td><code>g</code></td><td>绿色</td></tr><tr><td></td><td></td><td><code>s</code></td><td>方形</td><td><code>b</code></td><td>蓝色</td></tr><tr><td></td><td></td><td><code>d</code></td><td>菱形</td><td><code>w</code></td><td>白色</td></tr><tr><td></td><td></td><td><code>^</code></td><td>上三角</td><td><code>k</code></td><td>黑色</td></tr><tr><td></td><td></td><td><code>v</code></td><td>下三角</td><td></td><td></td></tr><tr><td></td><td></td><td><code>&gt;</code></td><td>右三角</td><td></td><td></td></tr><tr><td></td><td></td><td><code>&lt;</code></td><td>左三角</td><td></td><td></td></tr><tr><td></td><td></td><td><code>p</code></td><td>五角形</td><td></td><td></td></tr><tr><td></td><td></td><td><code>h</code></td><td>六角形</td><td></td></tr></tbody></table></div><p>注：Python中的matplotlib的画图方式和这里几乎一样</p><h3 id="装饰图线"><a href="#装饰图线" class="headerlink" title="装饰图线"></a>装饰图线</h3><ul><li><p>使用<code>legend()</code>函数为图片增加图例</p><p>  使用<code>legend(label1, ..., labelN)</code>函数可以为图片添加图例.</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x&#x3D;0:0.5:4*pi;y&#x3D;sin(x); h&#x3D;cos(x); w&#x3D;1.&#x2F;(1+exp(-x)); g&#x3D;(1&#x2F;(2*pi*2)^0.5).*exp((-1.*(x-2*pi).^2).&#x2F;(2*2^2));plot(x,y,&#39;bd-&#39; ,x,h,&#39;gp:&#39;,x,w,&#39;ro-&#39; ,x,g,&#39;c^-&#39;);% 绘制多条图线legend(&#39;sin(x)&#39;,&#39;cos(x)&#39;,&#39;Sigmoid&#39;,&#39;Gauss function&#39;);% 添加图例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213101.jpeg" alt="使用legend增加图例"></p></li><li><p>使用<code>title()</code>和<code>*label()</code>为图片增加标题和标签</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 0:0.1:2*pi; y1 &#x3D; sin(x); y2 &#x3D; exp(-x);plot(x, y1, &#39;--*&#39;, x, y2, &#39;:o&#39;);xlabel(&#39;t &#x3D; 0 to 2\pi&#39;);ylabel(&#39;values of sin(t) and e^&#123;-x&#125;&#39;)title(&#39;Function Plots of sin(t) and e^&#123;-x&#125;&#39;);legend(&#39;sin(t)&#39;,&#39;e^&#123;-x&#125;&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213130.jpeg" alt="使用title()和*label()为图片增加标题和标签"></p></li></ul><ul><li><p>使用<code>text()</code>和<code>annotation()</code>为图片增加注解</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; linspace(0,3); y &#x3D; x.^2.*sin(x); plot(x,y);line([2,2],[0,2^2*sin(2)]);str &#x3D; &#39;$$ \int_&#123;0&#125;^&#123;2&#125; x^2\sin(x) dx $$&#39;;text(0.25,2.5,str,&#39;Interpreter&#39;,&#39;latex&#39;);annotation(&#39;arrow&#39;,&#39;X&#39;,[0.32,0.5],&#39;Y&#39;,[0.6,0.4]); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213259.jpeg" alt="使用text()和annotation()为图片增加注解"></p></li></ul><h3 id="控制坐标轴-边框与网格"><a href="#控制坐标轴-边框与网格" class="headerlink" title="控制坐标轴,边框与网格"></a>控制坐标轴,边框与网格</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>grid on/off</code></td><td>设置网格可见性</td></tr><tr><td><code>box on/off</code></td><td>设置边框可见性</td></tr><tr><td><code>axis on/off</code></td><td>设置坐标轴可见性</td></tr><tr><td><code>axis normal</code></td><td>还原默认行为,将图框纵横比模式和数据纵横比模式的属性设置为自动</td></tr><tr><td><code>axis square</code></td><td>使用相同长度的坐标轴线,相应调整数据单位之间的增量</td></tr><tr><td><code>axis equal</code></td><td>沿每个坐标轴使用相同的数据单位长度</td></tr><tr><td><code>axis tight</code></td><td>将坐标轴范围设置为等同于数据范围,使轴框紧密围绕数据</td></tr></tbody></table></div><p>下面的例子演示<code>axis</code>命令的效果:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">t &#x3D; 0:0.1:2*pi; x &#x3D; 3*cos(t); y &#x3D; sin(t);subplot(2, 2, 1); plot(x, y); axis normalsubplot(2, 2, 2); plot(x, y); axis squaresubplot(2, 2, 3); plot(x, y); axis equalsubplot(2, 2, 4); plot(x, y); axis equal tight<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213545.png" alt="axis命令的效果"></p><h2 id="绘制多条图线"><a href="#绘制多条图线" class="headerlink" title="绘制多条图线"></a>绘制多条图线</h2><h3 id="在一个图像上绘制多条图线"><a href="#在一个图像上绘制多条图线" class="headerlink" title="在一个图像上绘制多条图线"></a>在一个图像上绘制多条图线</h3><p>默认情况下,每次执行<code>plot()</code>函数都会清除上一次绘图的结果,多次执行<code>plot()</code>只会保留最后一次绘制的图形.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213755.jpeg" alt="多次执行plot只会保留最后一次绘制的图形"></p><p>我们可以使用<code>hold on</code>和<code>hold off</code>命令控制绘图区域的刷新,使得多个绘图结果同时保留在绘图区域中.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on% 提起画笔,开始绘制一组图片plot(cos(0:pi&#x2F;20:2*pi));plot(sin(0:pi&#x2F;20:2*pi));hold off% 放下画笔,该组图片绘制完毕<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213800.jpeg" alt="使用hold命令控制绘图区域的刷新"></p><h3 id="在一个窗口内绘制多个图像"><a href="#在一个窗口内绘制多个图像" class="headerlink" title="在一个窗口内绘制多个图像"></a>在一个窗口内绘制多个图像</h3><p>subplot</p><h2 id="图形对象的操作"><a href="#图形对象的操作" class="headerlink" title="图形对象的操作"></a>图形对象的操作</h2><p>在MATLAB中,图形都是以对象的形式储存在内存中,通过获取其图形句柄可以对其进行操作.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214106.png" alt="在MATLAB中图形都是以对象的形式储存的"></p><h3 id="获取图形句柄"><a href="#获取图形句柄" class="headerlink" title="获取图形句柄"></a>获取图形句柄</h3><p>图形句柄本质上就是一个浮点数,可以唯一确定一个图形对象.下面几个函数用于获取图形句柄.</p><div class="table-container"><table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody><tr><td><code>gca()</code></td><td>获取当前坐标轴的句柄</td></tr><tr><td><code>gcf()</code></td><td>获取当前图像的句柄</td></tr><tr><td><code>allchild(handle_list)</code></td><td>获取该对象的所有子对象的句柄</td></tr><tr><td><code>ancestor(h,type)</code></td><td>获取对象最近的<code>type</code>类型的祖先节点</td></tr><tr><td><code>delete(h)</code></td><td>删除某对象</td></tr><tr><td><code>findall(handle_list)</code></td><td>获取该对象的后代对象</td></tr></tbody></table></div><p>所有绘图函数也会返回图形对象的句柄.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214204.png" alt="绘图函数也会返回图形对象的句柄"></p><h3 id="通过图形句柄操作图形属性"><a href="#通过图形句柄操作图形属性" class="headerlink" title="通过图形句柄操作图形属性"></a>通过图形句柄操作图形属性</h3><p>使用<code>get()</code>和<code>set()</code>函数可以对图形对象的属性进行访问和修改.访问<a href="http://www.mathworks.com/help/matlab/ref/figure-properties.html">官方文档</a>可以查看所有图形对象的属性.</p><ul><li><p><code>set(H,Name,Value)</code></p></li><li><p><code>v = get(h,propertyName)</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214258.png" alt="图形对象的属性"></p><p>下面两个例子演示使用图形句柄操作图形对象:</p><ol><li><p>改变坐标轴属性:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 第一张图set(gca, &#39;FontSize&#39;, 25);% 第二张图set(gca, &#39;XTick&#39;, 0:pi&#x2F;2:2*pi);set(gca, &#39;XTickLabel&#39;, 0:90:360);% 第三张图set(gca, &#39;FontName&#39;, &#39;symbol&#39;);set(gca, &#39;XTickLabel&#39;, &#123;&#39;0&#39;, &#39;p&#x2F;2&#39;, &#39;p&#39;, &#39;3p&#x2F;2&#39;, &#39;2p&#39;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214348.jpeg" alt="句柄操作实例1"></p></li><li><p>改变线型</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h &#x3D; plot(x,y); set(h, &#39;LineStyle&#39;,&#39;-.&#39;, ...&#39;LineWidth&#39;, 7.0, ...&#39;Color&#39;, &#39;g&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214348.jpeg" alt="句柄操作实例2"></p></li></ol><h3 id="将图形保存到文件"><a href="#将图形保存到文件" class="headerlink" title="将图形保存到文件"></a>将图形保存到文件</h3><p>使用<code>saveas(fig,filename)</code>命令可以将图形对象保存到文件中,其中<code>fig</code>为图形句柄,<code>filname</code>为文件名.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">saveas(gcf, &#39;myfigure.png&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="绘制高级图表"><a href="#绘制高级图表" class="headerlink" title="绘制高级图表"></a>绘制高级图表</h1><h2 id="二维图表"><a href="#二维图表" class="headerlink" title="二维图表"></a>二维图表</h2><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><div class="table-container"><table><thead><tr><th>函数</th><th>图形描述</th></tr></thead><tbody><tr><td><code>loglog()</code></td><td>x轴和y轴都取对数坐标</td></tr><tr><td><code>semilogx()</code></td><td>x轴取对数坐标,y轴取线性坐标</td></tr><tr><td><code>semilogy()</code></td><td>x轴取线性坐标,y轴取对数坐标</td></tr><tr><td><code>plotyy()</code></td><td>带有两套y坐标轴的线性坐标系</td></tr><tr><td><code>ploar()</code></td><td>极坐标系</td></tr></tbody></table></div><h4 id="对数坐标系图线"><a href="#对数坐标系图线" class="headerlink" title="对数坐标系图线"></a>对数坐标系图线</h4><p>下面例子演示对数坐标系图线:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; logspace(-1,1,100); y &#x3D; x.^2;subplot(2,2,1);plot(x,y);title(&#39;Plot&#39;);subplot(2,2,2);semilogx(x,y);title(&#39;Semilogx&#39;);subplot(2,2,3);semilogy(x,y);title(&#39;Semilogy&#39;);subplot(2,2,4);loglog(x, y);title(&#39;Loglog&#39;); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203215844.jpeg" alt="对数坐标系"></p><p>对数坐标系可以加上<strong>网格</strong>,以区分线性坐标系与对数坐标系.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">set(gca, &#39;XGrid&#39;,&#39;on&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220009.jpeg" alt="对数坐标加网格的重要性"></p><h4 id="双y轴图线"><a href="#双y轴图线" class="headerlink" title="双y轴图线"></a>双y轴图线</h4><p><code>plotyy()</code>的返回值为数组<code>[ax,hlines1,hlines2]</code>,其中:</p><ul><li><code>ax</code>为一个向量,保存两个坐标系对象的句柄.</li><li><code>hlines1</code>和<code>hlines2</code>分别为两个图线的句柄.</li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 0:0.01:20;y1 &#x3D; 200*exp(-0.05*x).*sin(x);y2 &#x3D; 0.8*exp(-0.5*x).*sin(10*x);[AX,H1,H2] &#x3D; plotyy(x,y1,x,y2);set(get(AX(1),&#39;Ylabel&#39;),&#39;String&#39;,&#39;Left Y-axis&#39;)set(get(AX(2),&#39;Ylabel&#39;),&#39;String&#39;,&#39;Right Y-axis&#39;)title(&#39;Labeling plotyy&#39;);set(H1,&#39;LineStyle&#39;,&#39;--&#39;); set(H2,&#39;LineStyle&#39;,&#39;:&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220101.jpeg" alt="双y轴图线"></p><h3 id="统计图表"><a href="#统计图表" class="headerlink" title="统计图表"></a>统计图表</h3><div class="table-container"><table><thead><tr><th>函数</th><th>图形描述</th></tr></thead><tbody><tr><td><code>hist()</code></td><td>直方图</td></tr><tr><td><code>bar()</code></td><td>二维柱状图</td></tr><tr><td><code>pie()</code></td><td>饼图</td></tr><tr><td><code>stairs()</code></td><td>阶梯图</td></tr><tr><td><code>stem()</code></td><td>针状图</td></tr></tbody></table></div><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220732.jpeg" alt="直方图"></p><h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><ul><li><p>使用<code>bar()</code>和<code>bar3()</code>函数分别绘制二维和三维直方图</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 4 8]; y &#x3D; [x;1:5];subplot(1,3,1); bar(x); title(&#39;A bargraph of vector x&#39;);subplot(1,3,2); bar(y); title(&#39;A bargraph of vector y&#39;);subplot(1,3,3); bar3(y); title(&#39;A 3D bargraph&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191116210529183.jpg" alt="在这里插入图片描述"></p><blockquote><p><code>hist</code>主要用于查看变量的频率分布,而<code>bar</code>主要用于查看分立的量的统计结果.</p></blockquote></li><li><p>使用<code>barh()</code>函数可以绘制纵向排列的柱状图</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 4 8];y &#x3D; [x;1:5];barh(y);title(&#39;Horizontal&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191116212011255.jpg" alt="纵向排列的柱状图"></p></li><li><p>向<code>bar()</code>传入<code>&#39;stack&#39;</code>参数可以让柱状图以堆栈的形式画出.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 4 8];y &#x3D; [x;1:5];bar(y,&#39;stacked&#39;);title(&#39;Stacked&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220924.jpeg" alt="堆栈式柱状图"></p></li></ul><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>使用<code>pie()</code>和<code>pie3()</code>可以绘制二维和三维的饼图.向其传入一个bool向量表示每一部分扇区是否偏移.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; [10 5 20 30];subplot(1,3,1); pie(a);subplot(1,3,2); pie(a, [0,0,0,1]);subplot(1,3,3); pie3(a, [0,0,0,1]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221246.jpeg" alt="饼图"></p><h4 id="阶梯图和针状图-绘制离散数字序列"><a href="#阶梯图和针状图-绘制离散数字序列" class="headerlink" title="阶梯图和针状图:绘制离散数字序列"></a>阶梯图和针状图:绘制离散数字序列</h4><p><code>stairs()</code>和<code>stem()</code>函数分别用来绘制阶梯图和针状图,用于表示离散数字序列.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; linspace(0, 4*pi, 40); y &#x3D; sin(x);subplot(1,2,1); stairs(y);subplot(1,2,2); stem(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221311.jpeg" alt="在这里插入图片描述"></p><h2 id="三维图表"><a href="#三维图表" class="headerlink" title="三维图表"></a>三维图表</h2><h4 id="二维图转为三维图"><a href="#二维图转为三维图" class="headerlink" title="二维图转为三维图"></a>二维图转为三维图</h4><p>在MATLAB中,所有的图都是三维图,二维图只不过是三维图的一个投影.点击图形窗口的<code>Rotate 3D</code>按钮,即可通过鼠标拖拽查看该图形的三维视图.</p><h4 id="三维图转换为二维图"><a href="#三维图转换为二维图" class="headerlink" title="三维图转换为二维图"></a>三维图转换为二维图</h4><p>使用<code>imagesc()</code>函数可以将三维图转换为二维俯视图,通过点的颜色指示高度.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">[x, y] &#x3D; meshgrid(-3:.2:3,-3:.2:3); z &#x3D; x.^2 + x.*y + y.^2; subplot(1, 2, 1)surf(x, y, z); subplot(1, 2, 2)imagesc(z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221702.jpeg" alt="在这里插入图片描述"></p><p>使用<code>colorbar</code>命令可以在生成的二维图上增加颜色与高度间对应关系的图例,使用<code>colormap</code>命令可以改变配色方案.具体细节请参考<a href="https://ww2.mathworks.cn/help/matlab/ref/colormap.html?lang=en">官方文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221742.png" alt="在这里插入图片描述"></p><h3 id="三维图的绘制"><a href="#三维图的绘制" class="headerlink" title="三维图的绘制"></a>三维图的绘制</h3><h4 id="绘制三维图前的准备工作"><a href="#绘制三维图前的准备工作" class="headerlink" title="绘制三维图前的准备工作"></a>绘制三维图前的准备工作</h4><ul><li>使用<code>meshgrid()</code>生成二维网格</li></ul><p><code>meshgrid()</code>函数将输入的两个向量进行相应的行扩充和列扩充以得到两个增广矩阵,对该矩阵可应用二元函数.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -2:1:2;y &#x3D; -2:1:2;[X,Y] &#x3D; meshgrid(x,y)Z &#x3D; X.^2 + Y.^2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="绘制三维线"><a href="#绘制三维线" class="headerlink" title="绘制三维线"></a>绘制三维线</h4><p>使用<code>plot3()</code>函数即可绘制三维面,输入应为三个向量.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x&#x3D;0:0.1:3*pi; z1&#x3D;sin(x); z2&#x3D;sin(2.*x); z3&#x3D;sin(3.*x);y1&#x3D;zeros(size(x)); y3&#x3D;ones(size(x)); y2&#x3D;y3.&#x2F;2;plot3(x,y1,z1,&#39;r&#39;,x,y2,z2,&#39;b&#39;,x,y3,z3,&#39;g&#39;); grid on;xlabel(&#39;x-axis&#39;); ylabel(&#39;y-axis&#39;); zlabel(&#39;z-axis&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221905.jpeg" alt="三维曲线"></p><h4 id="绘制三维面"><a href="#绘制三维面" class="headerlink" title="绘制三维面"></a>绘制三维面</h4><p>使用<code>mesh()</code>和<code>surf()</code>命令可以绘制三维面,前者不会填充网格而后者会.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -3.5:0.2:3.5; y &#x3D; -3.5:0.2:3.5;[X,Y] &#x3D; meshgrid(x,y);Z &#x3D; X.*exp(-X.^2-Y.^2);subplot(1,2,1); mesh(X,Y,Z);subplot(1,2,2); surf(X,Y,Z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221954.png" alt="在这里插入图片描述"></p><h4 id="绘制三维图形的等高线"><a href="#绘制三维图形的等高线" class="headerlink" title="绘制三维图形的等高线"></a>绘制三维图形的等高线</h4><p>使用<code>contour()</code>和<code>contourf()</code>函数可以绘制三维图形的等高线,前者不会填充网格而后者会.</p><p>向<code>contour()</code>函数传入参数或操作图形句柄可以改变图像的细节:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -3.5:0.2:3.5; y &#x3D; -3.5:0.2:3.5;[X,Y] &#x3D; meshgrid(x,y); Z &#x3D; X.*exp(-X.^2-Y.^2);subplot(1,3,1); contour(Z,[-.45:.05:.45]); axis square;subplot(1,3,2); [C,h] &#x3D; contour(Z); clabel(C,h); axis square;subplot(1,3,3); contourf(Z); axis square;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222505.jpeg" alt="在这里插入图片描述"></p><p>使用<code>meshc()</code>和<code>surfc()</code>函数可以在绘制三维图形时绘制其等高线.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -3.5:0.2:3.5; y &#x3D; -3.5:0.2:3.5;[X,Y] &#x3D; meshgrid(x,y); Z &#x3D; X.*exp(-X.^2-Y.^2);subplot(1,2,1); meshc(X,Y,Z);subplot(1,2,2); surfc(X,Y,Z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222646.jpeg" alt="在这里插入图片描述"></p><h4 id="绘制三维体"><a href="#绘制三维体" class="headerlink" title="绘制三维体"></a>绘制三维体</h4><p>使用<code>patch()</code>函数可以绘制三维体.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">v &#x3D; [0 0 0; 1 0 0 ; 1 1 0; 0 1 0; 0.25 0.25 1; 0.75 0.25 1; 0.75 0.75 1; 0.25 0.75 1];f &#x3D; [1 2 3 4; 5 6 7 8; 1 2 6 5; 2 3 7 6; 3 4 8 7; 4 1 5 8];subplot(1,2,1); patch(&#39;Vertices&#39;, v, &#39;Faces&#39;, f, &#39;FaceVertexCData&#39;, hsv(6), &#39;FaceColor&#39;, &#39;flat&#39;);view(3); axis square tight; grid on;subplot(1,2,2); patch(&#39;Vertices&#39;, v, &#39;Faces&#39;, f, &#39;FaceVertexCData&#39;, hsv(8), &#39;FaceColor&#39;,&#39;interp&#39;);view(3); axis square tight; grid on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222800.jpeg" alt="在这里插入图片描述"></p><h3 id="三维图的视角与打光"><a href="#三维图的视角与打光" class="headerlink" title="三维图的视角与打光"></a>三维图的视角与打光</h3><h4 id="调整视角"><a href="#调整视角" class="headerlink" title="调整视角"></a>调整视角</h4><p>使用<code>view()</code>函数可以调整视角,<code>view()</code>函数接受两个浮点型参数,分别表示两个方位角<code>azimuth</code>和<code>elevation</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222959.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sphere(50); shading flat;material shiny;axis vis3d off;view(-45,20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203223018.png" alt="image-20220203223018744"></p><h1 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a>符号运算</h1><h2 id="创建符号变量"><a href="#创建符号变量" class="headerlink" title="创建符号变量"></a>创建符号变量</h2><h3 id="创建符号数字"><a href="#创建符号数字" class="headerlink" title="创建符号数字"></a>创建符号数字</h3><p>使用<code>sym</code>函数可以创建符号数字.使用符号数字可以精确地保存无理数,不会产生误差.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sym(1&#x2F;3)% 得到 1&#x2F;31&#x2F;3% 得到 0.3333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将无理数保存为符号数字可以避免将其转换为浮点数的误差:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sin(sym(pi))% 得到 0sin(pi)% 得到 1.2246e-16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建符号变量-1"><a href="#创建符号变量-1" class="headerlink" title="创建符号变量"></a>创建符号变量</h3><p>使用<code>sym</code>和<code>syms</code>可以创建符号变量,区别在于:</p><ol><li><p><code>sym</code>每次只能创建一个符号变量,而<code>syms</code>一次可以创建多个符号变量.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms a% sym命令只能创建一个符号变量syms b c d% syms命令可以创建多个符号变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>若所指定的符号变量已存在,<code>sym</code>不会保留其原有的值,而<code>syms</code>会清空其值.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yf &#x3D; x+y;% 隐式创建符号变量fsym f% 不清空变量f原有的值,即f &#x3D; x + y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yf &#x3D; x+y;% 隐式创建符号变量fsyms f% 清空变量f原有的值,即f &#x3D; f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>sym</code>可以创建符号变量矩阵.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A &#x3D; sym(&#39;a&#39;, [2 5])% 创建一个2*5的符号变量矩阵whos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到的输出如下:</p><pre class="line-numbers language-none"><code class="language-none">A &#x3D;[ a1_1, a1_2, a1_3, a1_4, a1_5][ a2_1, a2_2, a2_3, a2_4, a2_5]    Name      Size            Bytes  Class    Attributes  A         2x5               112  sym      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合使用<code>sym</code>和<code>syms</code>可以快速创建一系列带下标的变量</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear allsyms(sym(&#39;a&#39;, [1 5]))whos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到输出如下:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">Name      Size            Bytes  Class    Attributesa1        1x1                 8  sym                a2        1x1                 8  sym                a3        1x1                 8  sym                a4        1x1                 8  sym                a5        1x1                 8  sym                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="符号运算-1"><a href="#符号运算-1" class="headerlink" title="符号运算"></a>符号运算</h2><h3 id="符号表达式的化简与代入"><a href="#符号表达式的化简与代入" class="headerlink" title="符号表达式的化简与代入"></a>符号表达式的化简与代入</h3><h4 id="符号表达式的化简"><a href="#符号表达式的化简" class="headerlink" title="符号表达式的化简"></a>符号表达式的化简</h4><p>使用<code>simplify()</code>函数可以化简符号表达式.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x a b csimplify(sin(x)^2 + cos(x)^2);% 得到 1simplify(exp(c*log(sqrt(a+b))));% 得到 (a + b)^(c&#x2F;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>表达式化简的标准是不确定的,下面三个函数分别按照不同标准化简表达式:</p><ul><li><p><code>expand()</code>函数可以展开表达式</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xf &#x3D; (x ^2- 1)*(x^4 + x^3 + x^2 + x + 1)*(x^4 - x^3 + x^2 - x + 1);expand(f);% 得到 x^10 - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>factor()</code>函数可以分解因式</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xg &#x3D; x^3 + 6*x^2 + 11*x + 6;factor(g);% 得到 (x + 3)*(x + 2)*(x + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>horner()</code>函数可以将多项式变为嵌套形式</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xh &#x3D; x^5 + x^4 + x^3 + x^2 + x;horner(h);% 得到 x*(x*(x*(x*(x + 1) + 1) + 1) + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="符号表达式的代入"><a href="#符号表达式的代入" class="headerlink" title="符号表达式的代入"></a>符号表达式的代入</h4><p>使用<code>sub(expr, old, new)</code>函数可以将符号表达式<code>expr</code>中的<code>old</code>替换为<code>new</code>.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yf &#x3D; x^2*y + 5*x*sqrt(y);subs(f, x, 3);% 得到 9*y + 15*y^(1&#x2F;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求方程的解析解"><a href="#求方程的解析解" class="headerlink" title="求方程的解析解"></a>求方程的解析解</h3><p>使用<code>solve(eqn,var)</code>和<code>solve(eqns,vars)</code>可以求取方程式的解析解.</p><h4 id="解单变量方程"><a href="#解单变量方程" class="headerlink" title="解单变量方程"></a>解单变量方程</h4><p>使用<code>==</code>定义一个方程,并对其调用<code>solve</code>函数求解.（若不指定<code>==</code>符号右边的值,则默认等式右边为0.）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xeqn &#x3D; x^3 - 6*x^2 &#x3D;&#x3D; 6 - 11*x;solve(eqn);% 得到 [1 2 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解多变量方程"><a href="#解多变量方程" class="headerlink" title="解多变量方程"></a>解多变量方程</h4><p>对于多变量方程,我们需要指定针对哪个变量进行求解.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yeqn &#x3D; [6*x^2 - 6*x^2*y + x*y^2 - x*y + y^3 - y^2 &#x3D;&#x3D; 0];solve(eqn, y);% 得到 [1, 2*x, -3*x]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解方程组"><a href="#解方程组" class="headerlink" title="解方程组"></a>解方程组</h4><p>向<code>solve()</code>函数传入方程组可以解方程.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms u veqns &#x3D; [2*u + v &#x3D;&#x3D; 0, u - v &#x3D;&#x3D; 1];S &#x3D; solve(eqns,[u v]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过变量名索引方程的解,并可以将该解代入其他表达式中.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">S.u;% 得到 1&#x2F;3S.v;% 得到 -2&#x2F;3subs(3*v + u, S);% 得到 -3&#x2F;5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="符号微积分运算"><a href="#符号微积分运算" class="headerlink" title="符号微积分运算"></a>符号微积分运算</h3><h4 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h4><p>使用<code>limit(expr, var, a)</code>函数可以求取符号表达式<code>expr</code>在变量<code>var</code>趋近于<code>a</code>时的极限,添加参数<code>&#39;left&#39;</code>或<code>&#39;right&#39;</code>可以指定左极限或右极限.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x;expr &#x3D; 1&#x2F;x;limit(expr,x,0);% 得到NaNlimit(expr,x,0,&#39;left&#39;);% 得到-Inflimit(expr,x,0,&#39;right&#39;);% 得到Inf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h4><p>使用<code>diff(expr, var, n)</code>函数可以求取符号表达式<code>expr</code>对变量<code>var</code>的<code>n</code>阶微分.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms a b c x;expr &#x3D; a*x^2 + b*x + c;diff(expr, a);% 得到 x^2diff(expr, b);% 得到 xdiff(expr, x);% 得到 b + 2*a*xdiff(expr, x, 2);% 得到 2*a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p>使用<code>int(expr, var)</code>函数可以求取符号表达式<code>expr</code>对变量<code>var</code>的不定积分.使用<code>int(expr, var, [a, b])</code>函数可以指定上下限求定积分,<code>a</code>和<code>b</code>可以是符号表达式.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x a bexpr &#x3D; -2*x&#x2F;(1+x^2)^2;int(expr, x);% 得到 1&#x2F;(x^2 + 1)int(expr, x, [1, 2]);% 得到 -0.3int(expr, x, [1, Inf]);% 得到 -0.5int(expr, x, [a, b]);% 得到 1&#x2F;(b^2 + 1) - 1&#x2F;(a^2 + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一些函数,MATLAB不能求出其积分,这时MATLAB会返回一个未解析(unsolved)的积分形式.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xint(sin(sinh(x)));% 一个无解的积分,MATLAB返回 int(sin(sinh(x)),<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h4><p>使用<code>symsum(expr, k, [a b])</code>计算级数<code>expr</code>的索引<code>k</code>从<code>a</code>到<code>b</code>的加和.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms k xsymsum(k^2, k)% 得到 k^3&#x2F;3 - k^2&#x2F;2 + k&#x2F;6symsum(k^2, k, [0 10])% 得到 385symsum(x^k&#x2F;factorial(k),k,1,Inf)% 得到 exp(x) - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><p>使用<code>taylor(expr,var,a)</code>计算表达式<code>expr</code>在<code>var=a</code>处的泰勒级数.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xtaylor(exp(x))% 得到 x^5&#x2F;120 + x^4&#x2F;24 + x^3&#x2F;6 + x^2&#x2F;2 + x + 1taylor(sin(x))% 得到 x^5&#x2F;120 - x^3&#x2F;6 + xtaylor(cos(x))% 得到 x^4&#x2F;24 - x^2&#x2F;2 + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><p>可以对符号表达式绘制图像,常用的绘图函数如下:</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>fplot()</code></td><td>绘制符号表达式的二维线图像</td></tr><tr><td><code>fplot3()</code></td><td>绘制符号表达式的三维线图像</td></tr><tr><td><code>ezpolar()</code></td><td>绘制符号表达式的极坐标线图像</td></tr><tr><td><code>fmesh()</code></td><td>绘制网状面图像</td></tr><tr><td><code>fsurf()</code></td><td>绘制带颜色的面图像</td></tr><tr><td><code>fcontour()</code></td><td>绘制轮廓图像</td></tr><tr><td><code>fimplicit()</code></td><td>绘制隐含函数关系的图像</td></tr></tbody></table></div><ol><li><p>下面例子展示二维和三维线图像的绘制</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">subplot(1, 2, 1)syms xf &#x3D; x^3 - 6*x^2 + 11*x - 6;fplot(f, x)subplot(1, 2, 2)syms tfplot3(t^2*sin(10*t), t^2*cos(10*t), t)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191123174049841.png" alt="在这里插入图片描述"></p></li><li><p>下面例子演示三维面的绘制</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yfsurf(x^2 + y^2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191123194055609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25jZXB1X0NoZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>下面例子演示隐含函数关系图像的绘制</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yeqn &#x3D; (x^2 + y^2)^4 &#x3D;&#x3D; (x^2 - y^2)^2;fimplicit(eqn, [-1 1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191123174144464.png" alt="在这里插入图片描述"></p></li></ol><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="多项式的数值运算"><a href="#多项式的数值运算" class="headerlink" title="多项式的数值运算"></a>多项式的数值运算</h2><h3 id="使用MATLAB表示多项式"><a href="#使用MATLAB表示多项式" class="headerlink" title="使用MATLAB表示多项式"></a>使用MATLAB表示多项式</h3><h4 id="使用向量表示多项式"><a href="#使用向量表示多项式" class="headerlink" title="使用向量表示多项式"></a>使用向量表示多项式</h4><p>在MATLAB中,多项式可以用向量表示,向量中的元素为多项式的系数(降幂排序):第一位为多项式最高次项系数,最后一位为常数项.</p><p>例如多项式:<br>f(x) = x^3 - 2x - 5f(x)=x3−2x−5</p><p>可以用向量<code>p = [1 0 -2 -5]</code>表示.</p><h4 id="多项式求值-polyval"><a href="#多项式求值-polyval" class="headerlink" title="多项式求值:polyval()"></a>多项式求值:<code>polyval()</code></h4><p>使用<code>polyval(p, x)</code>可以计算多项式<code>p</code>在<code>x</code>的每个点处的值.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; [9,-5,3,7]; x &#x3D; -2:0.01:5;f &#x3D; polyval(a,x);plot(x,f);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204115820.jpeg" alt="在这里插入图片描述"></p><h4 id="多项式的乘法-conv"><a href="#多项式的乘法-conv" class="headerlink" title="多项式的乘法:conv()"></a>多项式的乘法:<code>conv()</code></h4><p>使用<code>conv(p1, p2)</code>函数可以对两个向量<code>p1</code>和<code>p2</code>进行卷积相乘,用于计算多项式的乘法.</p><p>例如多项式:<br>f(x) = (x^2+1) (2x+7)f(x)=(x2+1)(2x+7)</p><p>可以使用<code>conv()</code>函数得到展开后的多项式:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; conv([1 0 1], [2 7])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [2 7 2 7]</code>.</p><h3 id="多项式的数值运算-1"><a href="#多项式的数值运算-1" class="headerlink" title="多项式的数值运算"></a>多项式的数值运算</h3><h4 id="多项式的因式分解-roots"><a href="#多项式的因式分解-roots" class="headerlink" title="多项式的因式分解:roots()"></a>多项式的因式分解:<code>roots()</code></h4><p>使用<code>roots(p)</code>函数可以对多项式<code>p</code>进行因式分解,即求表达式值为0的根.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; roots([1 -3.5 2.75 2.125 -3.875 1.25])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [2 -1, 1+0.5i, 1-0.5i, 0.5]</code>,表示x^5 -3.5 x^4 +2.75 x^3 + 2.125 x^2 + -3.875 x+1.25 = (x-2)(x+1)(x-1-0.5i)(x-1+0.5i)(x-0.5)x5−3.5x4+2.75x3+2.125x2+−3.875x+1.25=(x−2)(x+1)(x−1−0.5i)(x−1+0.5i)(x−0.5).</p><h4 id="多项式的微分-polyder"><a href="#多项式的微分-polyder" class="headerlink" title="多项式的微分:polyder()"></a>多项式的微分:<code>polyder()</code></h4><p>使用<code>polyder(p)</code>函数可以计算多项式的导数.</p><p>例如对下面多项式求导:<br>f(x) = 5x^4 - 2x^2 + 1f(x)=5x4−2x2+1</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; polyder([5 0 -2 0 1]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [20 0 -4 0]</code>,表示计算得到导数f’(x) = 20 x^3 - 4xf′(x)=20x3−4x.</p><h4 id="多项式的积分-polyint"><a href="#多项式的积分-polyint" class="headerlink" title="多项式的积分:polyint()"></a>多项式的积分:<code>polyint()</code></h4><p>使用<code>polyint(p, k)</code>函数可以计算多项式<code>p</code>的积分,积分结果的常数项设为<code>k</code>.</p><p>例如对下面多项式求导:<br>f(x) = 5x^4 - 2x^2 + 1f(x)=5x4−2x2+1</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; polyint([5 0 -2 0 1], 3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [1 0 -0.6667 0 1 3]</code>,表示计算得到积分\int f(x) dx = x^5 -0.6667x^3 + x + 3∫f(x)dx=x5−0.6667x3+x+3.</p><h2 id="非线性表达式的数值运算"><a href="#非线性表达式的数值运算" class="headerlink" title="非线性表达式的数值运算"></a>非线性表达式的数值运算</h2><h3 id="方程-组-求根fsolve"><a href="#方程-组-求根fsolve" class="headerlink" title="方程(组)求根fsolve()"></a>方程(组)求根<code>fsolve()</code></h3><p>使用<code>fsolve(fun, x0)</code>求非线性方程组的根,<code>fun</code>为待求方程的函数句柄,<code>x0</code>为初值.</p><ol><li><p>求方程1.2x+x\sin(x)+0.3=01.2x+xsin(x)+0.3=0在x=0x=0附近的解.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f2 &#x3D; @(x) (1.2*x+x*sin(x)+0.3);fsolve(f2,0)% 得到 -0.3500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>解方程组<br>\begin{aligned} \left\{ \begin{aligned} e^{-e^{-(x_1+x_2)}} - x_2(1+x_1^2) = 0 \\ x_1 \cos x_2 + x_2 \sin x_1 - \frac{1}{2} = 0 \end{aligned} \right. \end{aligned}⎩⎪⎨⎪⎧​e−e−(x1​+x2​)−x2​(1+x12​)=0x1​cosx2​+x2​sinx1​−21​=0​​</p><p>设定初值为[0, 0][0,0]</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">fun &#x3D; @(x) [exp(-exp(-(x(1)+x(2))))-x(2)*(1+x(1)^2)...    x(1)*cos(x(2)) + x(2)*sin(x(1)) - 0.5]x0 &#x3D; [0,0];x &#x3D; fsolve(fun,x0)% 得到[0.3532 0.6061]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h3><h4 id="求差分-diff"><a href="#求差分-diff" class="headerlink" title="求差分:diff()"></a>求差分:<code>diff()</code></h4><p>使用<code>diff(X, n)</code>计算向量<code>X</code>的<code>n</code>阶差分,<code>n</code>默认为<code>1</code>.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 2 1];diff(x);% 得到 [1 3 -3 -1]diff(x,1);% 得到 [1 3 -3 -1]diff(x,2);% 得到 [2 -6 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求导数-diff-y-diff-x"><a href="#求导数-diff-y-diff-x" class="headerlink" title="求导数:diff(y)./diff(x)"></a>求导数:<code>diff(y)./diff(x)</code></h4><p>使用导数的定义</p><script type="math/tex; mode=display">f'(x_0) = \lim_{h\rarr 0} \frac{f(x_0 + h) - f(x_0)}{h}$</script><p>可以计算函数在某点的近似导数.</p><p>下面程序计算f(x) = x^3f(x)=x3的一阶和二阶导数的值.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -2:0.005:2; y &#x3D; x.^3;m &#x3D; diff(y).&#x2F;diff(x);% 计算一阶导数m2 &#x3D; diff(m).&#x2F;diff(x(1:end-1));% 计算二阶导数plot(x,y,x(1:end-1),m,x(1:end-2),m2);xlabel(&#39;x&#39;); ylabel(&#39;y&#39;);legend(&#39;f(x) &#x3D;x^3&#39;,&#39;f&#39;&#39;(x)&#39;,&#39;f&#39;&#39;&#39;&#39;(x)&#39;, 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204120807.jpeg" alt="在这里插入图片描述"></p><h3 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h3><h4 id="数值积分原理"><a href="#数值积分原理" class="headerlink" title="数值积分原理"></a>数值积分原理</h4><p>有三种常见算法用于计算数值积分: <strong>矩形法</strong>,<strong>梯形法</strong>,<strong>抛物线法</strong>,它们分别把微分区间的图形视为矩形,梯形,抛物线以计算面积.</p><div class="table-container"><table><thead><tr><th>算法</th><th>图示</th><th>表达式</th></tr></thead><tbody><tr><td>矩形法(Midpoint Rule)</td><td><img src="https://img-blog.csdnimg.cn/20191120165104999.png" alt="在这里插入图片描述"></td><td><script type="math/tex">\int_a^b f(x) dx = 2h \sum_{i=0}^{(n/2)-1} f(x_{2i+1})</script></td></tr><tr><td>梯形法(Trapezoid Rule)</td><td><img src="https://img-blog.csdnimg.cn/20191120165114624.png" alt="在这里插入图片描述"></td><td><script type="math/tex">\int_a^b f(x) dx = \frac{h}{2} \left[ f(a) + 2\sum_{i=1}^{n-1} f(x_i) +f(b) \right]</script></td></tr><tr><td>抛物线法(Simpson’s Rule)</td><td><img src="https://img-blog.csdnimg.cn/20191120165124685.png" alt="在这里插入图片描述"></td><td><script type="math/tex">\int_a^b f(x) dx = \frac{h}{3} \left[ f(a) + 2\sum_{i=1}^{(n/2)-1} f(x_{2i}) + 4\sum_{i=1}^{n/2} f(x_{2i-1}) + f(b) \right]</script></td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/20191120180550884.png" alt="在这里插入图片描述"></p><p>下面分别使用三种方法计算f(x) = 4x^3f(x)=4x3在区间(0, 2)(0,2)内的积分.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h &#x3D; 0.05; x &#x3D; 0:h:2;% 使用矩形法计算近似积分midpoint &#x3D; (x(1:end-1)+x(2:end)).&#x2F;2;y &#x3D; 4*midpoint.^3;s &#x3D; sum(h*y)% 得到 15.9950% 使用梯形法计算近似积分trapezoid &#x3D; (y(1:end-1)+y(2:end))&#x2F;2;s &#x3D; h*sum(trapezoid)% 得到 15.2246% 使用抛物线法计算数值积分s &#x3D; h&#x2F;3*(y(1)+2*sum(y(3:2:end-2))+4*sum(y(2:2:end))+y(end))% 得到 15.8240<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值积分函数-integral"><a href="#数值积分函数-integral" class="headerlink" title="数值积分函数:integral()"></a>数值积分函数:<code>integral()</code></h4><p><code>integral()</code>,<code>integral2()</code>,<code>integral3()</code>分别对函数在<code>xmin</code>至<code>xmax</code>间进行一重,二重,三重积分.</p><p>它们的第一个参数都应该是一个函数句柄,下面例子演示他们的用法:</p><ol><li><p>计算\int_0^2 \frac{1}{x^3-2x-5}∫02x3−2x−51</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x) 1.&#x2F;(x.^3-2*x-5);integral(f,0,2)% 得到 -0.4605<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>计算\int_0^\pi \int_\pi^{2\pi} (y\sin(x) + x \cos(y)) dx dy∫0π∫π2π(ysin(x)+xcos(y))dxdy</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x,y) y.*sin(x)+x.*cos(y);integral2(f,pi,2*pi,0,pi)% 得到 -9.8696<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>计算\int_{-1}^1 \int_0^1 \int_0^\pi (y\sin(x) + z \cos(y)) dx dy dz∫−11∫01∫0π(ysin(x)+zcos(y))dxdydz</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x,y,z) y.*sin(x)+z.*cos(y);integral3(f,0,pi,0,1,-1,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h1 id="统计与拟合"><a href="#统计与拟合" class="headerlink" title="统计与拟合"></a>统计与拟合</h1><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="描述性统计-Descriptive-Statistics"><a href="#描述性统计-Descriptive-Statistics" class="headerlink" title="描述性统计(Descriptive Statistics)"></a>描述性统计(Descriptive Statistics)</h3><p>描述性统计主要研究数据的<strong>中心趋势</strong>(Central Tendency)和Variation</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204121855.png" alt="在这里插入图片描述"></p><h4 id="中心趋势-Central-Tendency"><a href="#中心趋势-Central-Tendency" class="headerlink" title="中心趋势(Central Tendency)"></a>中心趋势(Central Tendency)</h4><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>mean()</code></td><td>计算平均值</td></tr><tr><td><code>median()</code></td><td>计算中位数</td></tr><tr><td><code>mode()</code></td><td>计算众数</td></tr><tr><td><code>prctile(X,num)</code></td><td>数据X的num%分位数为多少</td></tr><tr><td><code>max()</code></td><td>计算最大值</td></tr><tr><td><code>min()</code></td><td>计算最小值</td></tr></tbody></table></div><p>下列函数绘制统计图表:</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>bar()</code></td><td>绘制条形图</td></tr><tr><td><code>stem()</code></td><td>绘制针状图</td></tr><tr><td><code>area()</code></td><td>绘制填充图</td></tr><tr><td><code>boxplot()</code></td><td>绘制箱线图</td></tr></tbody></table></div><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 1:14;freqy &#x3D; [1 0 1 0 4 0 1 0 3 1 0 0 1 1];subplot(1,3,1); bar(x,freqy); xlim([0 15]);subplot(1,3,2); area(x,freqy); xlim([0 15]);subplot(1,3,3); stem(x,freqy); xlim([0 15]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191125180936445.jpg" alt="在这里插入图片描述"></p><p>  箱线图可以突出显示数据的四分位点.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204122616.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">marks &#x3D; [80 81 81 84 88 92 92 94 96 97];boxplot(marks) % prctile(marks, [25 50 75])% 得到 [81 90 94]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2019112517244367.jpg" alt="在这里插入图片描述"></p><h4 id="Variation"><a href="#Variation" class="headerlink" title="Variation"></a>Variation</h4><h5 id="离散程度"><a href="#离散程度" class="headerlink" title="离散程度"></a>离散程度</h5><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>std()</code></td><td>计算数据的标准差</td></tr><tr><td><code>var()</code></td><td>计算数据的方差</td></tr></tbody></table></div><h5 id="偏度-Skewness"><a href="#偏度-Skewness" class="headerlink" title="偏度(Skewness"></a>偏度(Skewness</h5><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>skewness()</code></td><td>计算数据的偏度</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/20191125164908565.png" alt="在这里插入图片描述"></p><p>偏度反映数据的对称程度</p><ul><li>数据左偏时,其偏度小于0.</li><li>数据完全对称时,其偏度等于0.</li><li>数据右偏时,其偏度大于0.</li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">X &#x3D; randn([10 3]);% 构造10*3的矩阵X(X(:,1)&lt;0, 1) &#x3D; 0; % 将第一列数据右偏X(X(:,3)&gt;0, 3) &#x3D; 0;% 将第二列数据左偏boxplot(X, &#123;&#39;Right-skewed&#39;, &#39;Symmetric&#39;, &#39;Left-skewed&#39;&#125;);skewness(X);% 得到 [0.5162 -0.7539 -1.1234]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191125172206776.jpg" alt="在这里插入图片描述"></p><h5 id="峰度-Kurtosis"><a href="#峰度-Kurtosis" class="headerlink" title="峰度(Kurtosis)"></a>峰度(Kurtosis)</h5><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>kurtosis()</code></td><td>计算数据的峰度</td></tr></tbody></table></div><p>峰度(Kurtosis)表征概率密度分布曲线在平均值处峰值的高低.直观来看,峰度反映了峰部的尖度.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204123115.png" alt="在这里插入图片描述"></p><h3 id="统计推断-Inferential-Statistics"><a href="#统计推断-Inferential-Statistics" class="headerlink" title="统计推断(Inferential Statistics)"></a>统计推断(Inferential Statistics)</h3><p>推论统计的核心即为假设检验.下列函数用于进行假设检验.</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>ttest()</code></td><td>进行T检验</td></tr><tr><td><code>ztest()</code></td><td>进行Z检验</td></tr><tr><td><code>ranksum()</code></td><td>进行秩和检验</td></tr><tr><td><code>signrank()</code></td><td>进行符号秩检验</td></tr></tbody></table></div><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">load examgradesx &#x3D; grades(:,1);y &#x3D; grades(:,2);[h,p] &#x3D; ttest(x,y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行上述程序,得到<code>[h p] = [0 0.9805]</code>,表示在默认显著性水平(5%)下我们没有理由拒绝<code>x</code>与<code>y</code>同分布.</p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><h3 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h3><h4 id="一元多项式拟合-polyfit"><a href="#一元多项式拟合-polyfit" class="headerlink" title="一元多项式拟合:polyfit()"></a>一元多项式拟合:<code>polyfit()</code></h4><p>使用<code>polyfit(x, y, n)</code>函数对数据<code>x</code>和<code>y</code>进行<code>n</code>次多项式拟合.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [-1.2 -0.5 0.3 0.9 1.8 2.6 3.0 3.5];y &#x3D; [-15.6 -8.5 2.2 4.5 6.6 8.2 8.9 10.0];for i &#x3D; 1:3 % 分别进行一次,二次,三次拟合    p &#x3D; polyfit(x, y, i);    xfit &#x3D; x(1):0.1:x(end); yfit &#x3D; polyval(p, xfit);    subplot(1, 3, i); plot(x, y, &#39;ro&#39;, xfit, yfit);    legend(&#39;Data points&#39;, &#39;Fitted curve&#39;, &#39;Location&#39;, &#39;southeast&#39;);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204123618.png" alt="untitled"></p><h4 id="多元线性拟合-regress"><a href="#多元线性拟合-regress" class="headerlink" title="多元线性拟合:regress()"></a>多元线性拟合:<code>regress()</code></h4><p>使用<code>regress(y, X)</code>函数对数据<code>X</code>和<code>y</code>进行多元线性回归.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">load carsmall;y &#x3D; MPG; x1 &#x3D; Weight; x2 &#x3D; Horsepower;% 导入数据集X &#x3D; [ones(length(x1),1) x1 x2];% 构建增广X矩阵b &#x3D; regress(y,X);% 进行线性回归% 下面是绘图语句x1fit &#x3D; min(x1):100:max(x1); x2fit &#x3D; min(x2):10:max(x2);[X1FIT,X2FIT] &#x3D; meshgrid(x1fit,x2fit);YFIT &#x3D; b(1)+b(2)*X1FIT+b(3)*X2FIT;scatter3(x1,x2,y,&#39;filled&#39;); hold on;mesh(X1FIT,X2FIT,YFIT); hold off;xlabel(&#39;Weight&#39;); ylabel(&#39;Horsepower&#39;); zlabel(&#39;MPG&#39;); view(50,10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204123757.png" alt="untitled"></p><h3 id="非线性拟合"><a href="#非线性拟合" class="headerlink" title="非线性拟合"></a>非线性拟合</h3><p>对于非线性拟合,需要使用曲线拟合工具箱.在命令窗口输入<code>cftool()</code>打开曲线拟合工具箱.</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="一维插值"><a href="#一维插值" class="headerlink" title="一维插值"></a>一维插值</h3><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>interp1(x,v)</code>或<code>interp1(x,v,xq)</code></td><td>线性插值</td></tr><tr><td><code>spline(x,v)</code>或<code>spline(x,v,xq)</code></td><td>三次样条插值</td></tr><tr><td><code>pchip(x,v)</code>或<code>pchip(x,v,xq)</code></td><td>三次Hermite插值</td></tr><tr><td><code>mkpp(breaks,coefs)</code></td><td>生成分段多项式</td></tr><tr><td><code>ppval(pp,xq)</code></td><td>计算分段多项式的插值结果</td></tr></tbody></table></div><p>下面例子演示使用<code>interp1(x, v, xq)</code>进行线性插值和使用<code>spline(x, v, xq)</code>进行三次样条插值.各参数意义如下:</p><ul><li><code>x</code>,<code>v</code>: 待插值样本点.</li><li><code>xq</code>: 查询点,函数返回在这些点处的插值结果.</li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 构造数据x &#x3D; linspace(0, 2*pi, 40); x_m &#x3D; x; x_m([11:13, 28:30]) &#x3D; NaN; y_m &#x3D; sin(x_m);plot(x_m, y_m, &#39;ro&#39;, &#39;MarkerFaceColor&#39;, &#39;r&#39;); hold on; % 对数据进行线性插值m_i &#x3D; ~isnan(x_m);y_i &#x3D; interp1(x_m(m_i), y_m(m_i), x);plot(x,y_i, &#39;-b&#39;); hold on;% 对数据进行三次样条插值m_i &#x3D; ~isnan(x_m);y_i &#x3D; spline(x_m(m_i), y_m(m_i), x);plot(x,y_i, &#39;-g&#39;); legend(&#39;Original&#39;, &#39;Linear&#39;, &#39;Spline&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204124746.jpeg" alt="在这里插入图片描述"></p><h3 id="二维插值"><a href="#二维插值" class="headerlink" title="二维插值"></a>二维插值</h3><p>使用<code>interp2()</code>可以进行二维插值,向其<code>method</code>参数传入字符串可以指定插值算法.</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th><th>连续性</th></tr></thead><tbody><tr><td><code>&#39;linear&#39;</code></td><td>(默认)在查询点插入的值基于各维中邻点网格点处数值的线性插值.</td><td>C0</td></tr><tr><td><code>&#39;spline&#39;</code></td><td>在查询点插入的值基于各维中邻点网格点处数值的三次插值.插值基于使用非结终止条件的三次样条.</td><td>C2</td></tr><tr><td><code>&#39;nearest&#39;</code></td><td>在查询点插入的值是距样本网格点最近的值.</td><td>不连续</td></tr><tr><td><code>&#39;cubic&#39;</code></td><td>在查询点插入的值基于各维中邻点网格点处数值的三次插值.插值基于三次卷积.</td><td>C1</td></tr><tr><td><code>&#39;makima&#39;</code></td><td>修改后的Akima三次Hermite插值.在查询点插入的值基于次数最大为3的多项式的分段函数,使用各维中相邻网格点的值进行计算.为防过冲,已改进 Akima 公式.</td><td>C1</td></tr></tbody></table></div><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 构建样本点xx &#x3D; -2:.5:2; yy &#x3D; -2:.5:3; [x,y] &#x3D; meshgrid(xx,yy); xx_i &#x3D; -2:.1:2; yy_i &#x3D; -2:.1:3; [x_i,y_i] &#x3D; meshgrid(xx_i,yy_i);z &#x3D; x.*exp(-x.^2-y.^2);% 线性插值subplot(1, 2, 1); z_i &#x3D; interp2(xx,yy,z,x_i,y_i);surf(x_i,y_i,z_i); hold on;plot3(x,y,z+0.01,&#39;ok&#39;,&#39;MarkerFaceColor&#39;,&#39;r&#39;); hold on;% 三次插值subplot(1, 2, 2); z_ic &#x3D; interp2(xx,yy,z,x_i,y_i, &#39;spline&#39;);surf(x_i,y_i,z_ic); hold on;plot3(x,y,z+0.01,&#39;ok&#39;,&#39;MarkerFaceColor&#39;,&#39;r&#39;); hold on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204125228.png" alt="untitled"></p>]]></content>
    
    
    <summary type="html">在b站学习‘MATLAB教程_台大郭彦甫（14课）’的笔记，梳理原课程的过程中，做了一点改动。</summary>
    
    
    
    <category term="建模" scheme="https://changqingaas.github.io/categories/%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="https://changqingaas.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="建模" scheme="https://changqingaas.github.io/tags/%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>美赛校选培训课笔记</title>
    <link href="https://changqingaas.github.io/others/math/%E7%BE%8E%E8%B5%9B%E6%A0%A1%E9%80%89%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/others/math/%E7%BE%8E%E8%B5%9B%E6%A0%A1%E9%80%89%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-17T01:29:34.000Z</published>
    <updated>2022-02-04T05:53:20.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多元统计分析"><a href="#多元统计分析" class="headerlink" title="多元统计分析"></a>多元统计分析</h1><h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>事先不知道类别的个数与结构；</li><li>进行分析的数据是对象间的相似性或相异性（距离）；</li><li>将距离近的对象归入一类。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>根据分类对象不同分为</p><ul><li><p>Q型聚类：对样本进行聚类</p></li><li><p>R型聚类：对变量进行聚类</p></li></ul></li><li><p>根据聚类方法主要分为</p><ul><li>系统聚类法</li><li>动态聚类法</li></ul></li></ul><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><h4 id="Minikowski距离："><a href="#Minikowski距离：" class="headerlink" title="Minikowski距离："></a>Minikowski距离：</h4><script type="math/tex; mode=display">d(x,y) = [\sum\limits_{k=1}^p|x_{k} - y_{k}|^{m}]^{\frac{1}{m}}，  x,y为p维列向量</script><ul><li>m = 1时，为绝对距离</li><li>m = 2时，为欧氏距离</li><li>m = $\infty$,  为切比雪夫距离，即 $\mathop{max}\limits_{1\le k \le p}|x_{k} - y_{k}|$</li></ul><h4 id="Mahalanobis距离-聚类分析中常用"><a href="#Mahalanobis距离-聚类分析中常用" class="headerlink" title="Mahalanobis距离(聚类分析中常用)"></a>Mahalanobis距离(聚类分析中常用)</h4><script type="math/tex; mode=display">d(x,y) = \sqrt{(x - y)^{T} \sum\nolimits^{-1} (x - y)}</script><p>其中x, y为来自 p 维总体Z的样本观测值，Σ为Z 的协方差矩阵，实际中Σ往往是不知道的，常常需要用样本协方差来估计。马氏距离对一切线性变换是不变的，故不受量纲的影响。 </p><h4 id="R语句："><a href="#R语句：" class="headerlink" title="R语句："></a>R语句：</h4><pre class="line-numbers language-R" data-language="R"><code class="language-R">dist(x,method&#x3D;“euclidean”, diag&#x3D;FALSE, upper&#x3D;FALSE, p&#x3D;2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>method: 计算距离的方法</p><ul><li><p>“euclidean”: 欧式距离</p></li><li><p>“maximum”: Chebyshev距离</p></li><li><p>“manhattan”: 绝对值距离</p></li><li><p>“minkowski”: Minkowski距离，p是Minkowski距离的阶数</p></li></ul></li><li><p>diag=TRUE: 输出对角线上的距离</p></li><li>upper=TRUE: 输出上三角矩阵的值（默认值仅输出下 三角矩阵的值）</li></ul><h4 id="python语句："><a href="#python语句：" class="headerlink" title="python语句："></a>python语句：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rpy2.robjects as robjectsx &#x3D; [1, 2, 6, 8, 11]r &#x3D; robjects.rres &#x3D; r.dist(x)print(res)#    1  2  3  4# 2  1# 3  5  4# 4  7  6  2# 5 10  9  5  3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rpy2import rpy2.robjects.numpy2riR &#x3D; rpy2.robjects.rr_code &#x3D; &quot;&quot;&quot;x&lt;-c(1,2,6,8,11)y&lt;-dist(x)print(y)&quot;&quot;&quot;R(r_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注：我用rpy2来实现这个感觉比较费劲。可能不太能从python 调用R语言，建议直接用R语言吧</li></ul><h3 id="标准化处理"><a href="#标准化处理" class="headerlink" title="标准化处理"></a>标准化处理</h3><p>当指标的测量值相差悬殊时，应先对数据进行标准化处理，再利用标准化的数据计算距离。</p><h4 id="普通标准化变换"><a href="#普通标准化变换" class="headerlink" title="普通标准化变换"></a>普通标准化变换</h4><script type="math/tex; mode=display">X_{ij}^{*} = \frac{X_{ij} - \overline{X}_{j}}{S_{j}}</script><p>i=1,2,…n表示第i个样本，j=1,2,…p表示样本的第j个指标，每个样本均有p个观测指标.       是第j个指标的样本均值</p><h4 id="极差标准化变换"><a href="#极差标准化变换" class="headerlink" title="极差标准化变换"></a>极差标准化变换</h4><script type="math/tex; mode=display">X_{ij}^{*} = \frac{X_{ij} - \overline{X}_{j}}{R_{j}} \\其中，R_{j} = \mathop{\max}\limits_{1\le k \le n}X_{kj} - \mathop{\max}\limits_{1 \le k \le n}X_{kj}</script><h4 id="极差正规化变换"><a href="#极差正规化变换" class="headerlink" title="极差正规化变换"></a>极差正规化变换</h4><script type="math/tex; mode=display">X_{ij}^{*} = \frac{X_{ij} - \mathop{\min}\limits_{1\le k\le n} X_{kj}}{R_{j}}</script><h4 id="程序语句"><a href="#程序语句" class="headerlink" title="程序语句"></a>程序语句</h4><h5 id="数据的中心化和标准化处理"><a href="#数据的中心化和标准化处理" class="headerlink" title="数据的中心化和标准化处理"></a>数据的中心化和标准化处理</h5><h6 id="R语句"><a href="#R语句" class="headerlink" title="R语句"></a>R语句</h6><pre class="line-numbers language-R" data-language="R"><code class="language-R">scale(X,center &#x3D; True, scale &#x3D; True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>X:样本数据矩阵，center = TURE表示对数据做中心化变换，scale=TRUE表示对数据做标准化变化</p><h6 id="python语句"><a href="#python语句" class="headerlink" title="python语句"></a>python语句</h6><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rpy2import numpyimport rpy2.robjects.numpy2rirpy2.robjects.numpy2ri.activate()R &#x3D; rpy2.robjects.rx &#x3D; numpy.array([[1.0, 2.0], [3.0, 1.0]])res &#x3D; R.scale(x, center&#x3D;True, scale&#x3D;True)print(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数据做极差标准化处理"><a href="#数据做极差标准化处理" class="headerlink" title="数据做极差标准化处理"></a>数据做极差标准化处理</h5><pre class="line-numbers language-R" data-language="R"><code class="language-R">x &lt;- data.frame(    points &#x3D; c(99, 97, 104, 79, 84, 88, 91, 99),    rebounds &#x3D; c(34, 40, 41, 38, 29, 30, 22, 25),    blocks &#x3D; c(12, 8, 8, 7, 8, 11, 6, 7))# apply（）函数必须应用于dataframe或matrixcenter &lt;- sweep(x, 2, apply(x, 2, mean))R &lt;- apply(x, 2, max) - apply(x, 2, min)x_star &lt;- sweep(center, 2, R, &quot;&#x2F;&quot;)# 若x_star&lt;-sweep(center, 2, sd(x), &quot;&#x2F;&quot;), 则得到（普通）标准化变换后的数据；print(x_star)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220117160257.png" alt="image-20220117160237414"></p><p>sweep(x, MARGIN, STATS, FUN=”-“, …)</p><ul><li><p>x:数组或矩阵；MARGIN:运算区域，对矩阵1表示行，2表示列；</p></li><li><p>STATS是统计量，apply(x, 2, mean)表示各列的均值；</p></li><li><p>FUN表示函数的运算，缺省值为减法运算。</p></li></ul><h3 id="相似系数"><a href="#相似系数" class="headerlink" title="相似系数"></a>相似系数</h3><p>计算样本不同指标间的相关系数，适用于对变量进行聚类。</p><h3 id="系统聚类法"><a href="#系统聚类法" class="headerlink" title="系统聚类法"></a>系统聚类法</h3><h4 id="聚类分析方法中最常用"><a href="#聚类分析方法中最常用" class="headerlink" title="聚类分析方法中最常用"></a>聚类分析方法中最常用</h4><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>（1）视各样本（或变量）自成一类，规定类与类之间的距离（或相似系数）；</li><li>（2）把最相似的样本（或变量）聚为小类，再将已聚合的小类按相似性再聚合；</li><li>（3）最后将一切子类都聚合到一个大类，从而得到一个按相似性大小聚集起来的谱系关系</li></ul><h4 id="3-根据距离定义的不同分为"><a href="#3-根据距离定义的不同分为" class="headerlink" title="3.根据距离定义的不同分为"></a>3.根据距离定义的不同分为</h4><ul><li>（1）最短距离法：类与类之间的距离定义为两类中最近样本间的距离；</li><li>（2）最长距离法：类与类之间的距离定义为两类中最远样本间的距离；</li><li>（3）类平均法：类与类之间的距离定义为两类中两两样本间距离的平均数；</li></ul><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><pre class="line-numbers language-R" data-language="R"><code class="language-R"> x&lt;-c(1,2,6,8,11); dim(x)&lt;-c(5,1); d&lt;-dist(x) #生成距离结构hc1&lt;-hclust(d, &quot;single&quot;); hc2&lt;-hclust(d, &quot;complete&quot;)hc3&lt;-hclust(d, &quot;median&quot;); hc4&lt;-hclust(d, &quot;mcquitty&quot;) #生成系统聚类opar &lt;- par(mfrow &#x3D; c(2, 2))plot(hc1,hang&#x3D;-1); plot(hc2,hang&#x3D;-1)plot(hc3,hang&#x3D;-1); plot(hc4,hang&#x3D;-1)par(opar)#  画出所有树形结构图，以2*2的形式画在一张图上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hclust():进行系统聚类的计算<br>plot():画出系统聚类的树形图<br>hclust(d, method = “complete”)<br>d:dist构成的距离结构，<br>method:系统聚类的方法（默认为最长距离法），其参数有：<br>（1）“single”：最短距离法<br>（2）“complete”：最长距离法<br>（3）“average”：类平均法<br>……<br>plot(x, labels = NULL, hang = 0.1, main = “Cluster<br>Dendrogram”, sb = NULL, xlab = NULL, ylab =”Height”, …)</p><p>x: hclust()函数生成的对象<br>hang: 表明树形图中各类的位置，取负值表示树形图中的类从底部画起<br>main: 绘图名称</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220117165301.png" alt="image-20220117165300798"></p><h3 id="动态聚类法"><a href="#动态聚类法" class="headerlink" title="动态聚类法"></a>动态聚类法</h3><p>系统聚类：一次形成类后就不再改变；<br>动态聚类：逐步聚类</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先粗略分类，然后按某种最优原则修改不合理的分类，直至分得比较合理为止，形成最终分类结果。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><p>kmeans(x, centers, <em>iter.max</em>=10, <em>nstart</em>=1, algorithm*=c(“Hartigan-Wong”, “Lloyd”, “MacQueen”))</p><ul><li>x是由数据构成的矩阵或数据框，</li><li>centers是聚类的个数或者初始类的中心，</li><li>iter.max为最大迭代次数（最大值为10），</li><li>nstart是随机集合的个数，</li><li>algorithm是动态聚类的算法。</li></ul><pre class="line-numbers language-R" data-language="R"><code class="language-R">X&lt;-data.frame(   x1&#x3D;c(2959.19, 2459.77, 1495.63, 1046.33, 1303.97, 1730.84, 1561.86, 1410.11, 3712.31, 2207.58, 2629.16, 1844.78, 2709.46, 1563.78, 1675.75, 1427.65, 1783.43, 1942.23, 3055.17, 2033.87, 2057.86, 2303.29, 1974.28, 1673.82, 2194.25, 2646.61, 1472.95, 1525.57, 1654.69, 1375.46, 1608.82),    x2&#x3D;c(730.79, 495.47, 515.90, 477.77, 524.29, 553.90, 492.42, 510.71, 550.74, 449.37, 557.32, 430.29, 428.11, 303.65, 613.32, 431.79, 511.88, 512.27, 353.23, 300.82, 186.44, 589.99, 507.76, 437.75, 537.01, 839.70, 390.89, 472.98, 437.77, 480.99, 536.05),   x3&#x3D;c(749.41, 697.33, 362.37, 290.15, 254.83, 246.91, 200.49, 211.88, 893.37, 572.40, 689.73, 271.28, 334.12, 233.81, 550.71, 288.55, 282.84, 401.39, 564.56, 338.65, 202.72, 516.21, 344.79, 461.61, 369.07, 204.44, 447.95, 328.90, 258.78, 273.84, 432.46),    x4&#x3D;c(513.34, 302.87, 285.32, 208.57, 192.17, 279.81, 218.36, 277.11, 346.93, 211.92, 435.69, 126.33, 160.77, 107.90, 219.79, 208.14, 201.01, 206.06, 356.27, 157.78, 171.79, 236.55, 203.21, 153.32, 249.54, 209.11, 259.51, 219.86, 303.00, 317.32, 235.82),   x5&#x3D;c(467.87, 284.19, 272.95, 201.50, 249.81, 239.18, 220.69, 224.65, 527.00, 302.09, 514.66, 250.56, 405.14, 209.70,272.59, 217.00, 237.60, 321.29, 811.88, 329.06, 329.65, 403.92, 240.24, 254.66, 290.84, 379.30, 230.61, 206.65, 244.93, 251.08, 250.28),   x6&#x3D;c(1141.82, 735.97, 540.58, 414.72, 463.09, 445.20, 459.62, 376.82, 1034.98, 585.23, 795.87, 513.18, 461.67, 393.99, 599.43, 337.76, 617.74, 697.22, 873.06, 621.74, 477.17, 730.05, 575.10, 445.59, 561.91, 371.04, 490.90, 449.69, 479.53, 424.75, 541.30),   x7&#x3D;c(478.42, 570.84, 364.91, 281.84, 287.87, 330.24, 360.48, 317.61, 720.33, 429.77, 575.76, 314.00, 535.13, 509.39, 371.62, 421.31, 523.52, 492.60, 1082.82, 587.02, 312.93,438.41, 430.36, 346.11, 407.70, 269.59, 469.10, 249.66, 288.56, 228.73, 344.85),   x8&#x3D;c(457.64, 305.08, 188.63, 212.10, 192.96, 163.86, 147.76, 152.85, 462.03, 252.54, 323.36, 151.39, 232.29, 160.12, 211.84, 165.32, 182.52, 226.45, 420.81, 218.27, 279.19, 225.80, 223.46, 191.48, 330.95, 389.33, 191.34, 228.19, 236.51, 195.93, 214.40),   row.names &#x3D; c(&quot;北京&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;山西&quot;, &quot;内蒙古&quot;, &quot;辽宁&quot;, &quot;吉林&quot;, &quot;黑龙江&quot;, &quot;上海&quot;, &quot;江苏&quot;, &quot;浙江&quot;, &quot;安徽&quot;, &quot;福建&quot;, &quot;江西&quot;, &quot;山东&quot;,  &quot;河南&quot;, &quot;湖北&quot;, &quot;湖南&quot;, &quot;广东&quot;, &quot;广西&quot;, &quot;海南&quot;, &quot;重庆&quot;, &quot;四川&quot;, &quot;贵州&quot;, &quot;云南&quot;, &quot;西藏&quot;, &quot;陕西&quot;, &quot;甘肃&quot;, &quot;青海&quot;, &quot;宁夏&quot;, &quot;新疆&quot;))kmeans(scale(X),5)K-means clustering with 5 clusters of sizes 10, 7, 3, 7, 4Clustering vector:  北京   天津   河北   山西 内蒙古   辽宁   吉林 黑龙江   上海   江苏      5      4      3      3      3      3      3      3      5      4   浙江   安徽   福建   江西   山东   河南   湖北   湖南   广东   广西      5      1      2      1      4      1      1      4      5      2   海南   重庆   四川   贵州   云南   西藏   陕西   甘肃   青海   宁夏      2      4      1      1      4      4      1      3      3      3   新疆     3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>实际问题中的变量的重要性有所不同，且众多变量间有一定的相关关系。通过这种相关性对这些变量加以改造，用为数较少的新变量反映原变量提供的大部分信息，简化原问题。即数据降维</p><p>主成分分析法就是在这种降维思想下产生的处理高维数据的统计方法。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>通过适当构造原变量的线性组合，产生一列互不相关的新变量，从中选出少数几个新变量并使它们含有尽可能多的原变量带有的信息，从而使用少数几个新变量代替原变量，以分析原问题。</p><p>变量中所含“信息”的大小通常用该变量的方差或样本方差来度量。</p><p>如常数a,Var(a) = 0 ,我们通过a，只能知道a这个常数，其所含信息少。</p><h3 id="主成分的定义"><a href="#主成分的定义" class="headerlink" title="主成分的定义"></a>主成分的定义</h3><p>设$X = (X_{1}, X_{2},……,X_{p})^{T}$为实际问题涉及的p个随机变量构成的向量，记X的均值为$\mu$，协方差阵为$\sum$.</p><p>考虑线性组合</p><script type="math/tex; mode=display">\left\{\begin{aligned}Y_{1} &  = & a_{1}^{T}X \\. \\. \\Y_{p} &  = & a_{p}^{T}X \\\end{aligned}\right.</script><p>………………………………………………………………………………………………………</p><p>warning： 直接写代码了</p><h3 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h3><h4 id="求矩阵的特征值和特征向量"><a href="#求矩阵的特征值和特征向量" class="headerlink" title="求矩阵的特征值和特征向量"></a>求矩阵的特征值和特征向量</h4><pre class="line-numbers language-R" data-language="R"><code class="language-R">a &lt;- c(1, -2, 0, -2, 5, 0, 0, 0, 2)# 由向量a构造一3列的矩阵， byrow&#x3D;T表示生成矩阵的数据按行放置；b &lt;- matrix(data &#x3D; a, ncol &#x3D; 3, byrow &#x3D; T)c &lt;- eigen(b) # 求b的特征值与特征向量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><p>1.变量之间的关系一般分为两类</p><ul><li>完全确定的关系，即可表达为函数解析式</li><li>非确定的关系，也称相关关系</li></ul><p>2.回归分析研究的主要内容</p><ul><li><p>通过观察或实验数据的处理，找出变量间相关系数的定量数学表达式—经验公式，即进行参数估计，并确定经验回归方程的具体形式</p></li><li><p>检验所建立的经验回归方程是否合理</p></li><li><p>利用合理的回归方程对随机变量Y进行预测和控制。</p></li></ul>]]></content>
    
    
    <summary type="html">美赛培训课：多元统计分析，线性模型</summary>
    
    
    
    
    <category term="数学" scheme="https://changqingaas.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="美赛" scheme="https://changqingaas.github.io/tags/%E7%BE%8E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Policy Gradient Methods</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Policy%20Gradient%20Mwthods/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Policy%20Gradient%20Mwthods/</id>
    <published>2021-10-06T15:00:33.000Z</published>
    <updated>2021-10-06T04:57:07.546Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博文的内容整理了我们如何去近似价值函数或者是动作价值函数的方法：</p><script type="math/tex; mode=display">V_{\theta}(s)\approx V^{\pi}(s) \\Q_{\theta}(s)\approx Q^{\pi}(s, a)</script><p>通过机器学习的方法我们一旦近似了价值函数或者是动作价值函数就可以通过一些策略进行控制，比如  ϵ-greedy。</p><p>通过机器学习的方法我们一旦近似了价值函数或者是动作价值函数就可以通过一些策略进行控制，比如 ϵ -greedy。</p><p>那么我们简单回顾下 RL 的学习目标：通过 agent 与环境进行交互，获取累计回报最大化。既然我们最终要学习如何与环境交互的策略，那么我们可以直接学习策略 ，而之前先近似价值函数，再通过贪婪策略控制的思路更像是”曲线救国”。<br>这就是本篇文章的内容，我们如何直接来学习策略，用数学的形式表达就是：</p><p>$\pi_{\theta}(s, a) = P[a | s, \theta]$</p><p>这就是被称为策略梯度（Policy Gradient，简称PG）算法。</p><p>当然，本篇内容同样的是针对 model-free 的强化学习。</p><h1 id="Value-Based-vs-Policy-Based-RL"><a href="#Value-Based-vs-Policy-Based-RL" class="headerlink" title="Value-Based vs. Policy-Based RL"></a>Value-Based vs. Policy-Based RL</h1><p>Value-Based：</p><ul><li>学习价值函数</li><li>Implicit policy，比如 ϵϵ-greedy</li></ul><p>Policy-Based：</p><ul><li>没有价值函数</li><li>直接学习策略</li></ul><p>Actor-Critic：</p><ul><li>学习价值函数</li><li>学习策略</li></ul><p>三者的关系可以形式化地表示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006124701.png" alt=""></p><p>认识到 Value-Based 与 Policy-Based 区别后，我们再来讨论Policy-Based RL 的优缺点：</p><p>优点：</p><ul><li>收敛性更好</li><li>对于具有高维或者连续动作空间的问题更加有效</li><li>可以学习随机策略</li></ul><p>缺点：</p><ul><li>绝大多数情况下收敛到局部最优点，而非全局最优</li><li>评估一个策略一般情况下低效且存在较高的方差</li></ul><h1 id="Policy-Search"><a href="#Policy-Search" class="headerlink" title="Policy Search"></a>Policy Search</h1><p>我们首先定义下目标函数。</p><h2 id="Policy-Objective-Functions"><a href="#Policy-Objective-Functions" class="headerlink" title="Policy Objective Functions"></a>Policy Objective Functions</h2><p>目标：给定一个带有参数 θ 的策略 π~θ~(s,a)  ，找到最优的参数 θ 。<br>但是我们如何评估不同参数下策略 π~θ(~s,a)  的优劣呢？</p><ul><li>对于episode 任务来说，我们可以使用start value：</li></ul><script type="math/tex; mode=display">J_1(\theta)=V^{\pi_{\theta}}(s_1)=E_{\pi_{\theta}}[v_1]</script><ul><li>对于连续性任务来说，我们可以使用 average value：</li></ul><script type="math/tex; mode=display">J_{avV}(\theta)=\sum_{s}d^{\pi_{\theta}}(s)V^{\pi_{\theta}}(s)</script><p>或者每一步的平均回报：</p><script type="math/tex; mode=display">J_{avR}(\theta)=\sum_{s}d^{\pi_{\theta}}(s)\sum_{a}\pi_{\theta}(s, a)R_s^a</script><p>其中 d^πθ^(s)  是马尔卡夫链在 π~θ~  下的静态分布。</p><h1 id="Policy-Optimisation"><a href="#Policy-Optimisation" class="headerlink" title="Policy Optimisation"></a>Policy Optimisation</h1><p>在明确目标以后，我们再来看基于策略的 RL 为一个典型的优化问题：找出 θ 最大化 J(θ)<br>最优化的方法有很多，比如不依赖梯度（gradient-free）的算法：</p><ul><li>爬山算法</li><li>模拟退火</li><li>进化算法</li><li>…</li></ul><p>但是一般来说，如果我们能在问题中获得梯度的话，基于梯度的最优化方法具有比较好的效果：</p><ul><li>梯度下降</li><li>共轭梯度</li><li>拟牛顿法</li><li>…</li></ul><p>我们本篇讨论梯度下降的方法。</p><h1 id="策略梯度定理"><a href="#策略梯度定理" class="headerlink" title="策略梯度定理"></a>策略梯度定理</h1><h1 id="蒙特卡洛策略梯度算法（REINFORCE）"><a href="#蒙特卡洛策略梯度算法（REINFORCE）" class="headerlink" title="蒙特卡洛策略梯度算法（REINFORCE）"></a>蒙特卡洛策略梯度算法（REINFORCE）</h1><h1 id="Actir-Critic-策略梯度算法"><a href="#Actir-Critic-策略梯度算法" class="headerlink" title="Actir-Critic 策略梯度算法"></a>Actir-Critic 策略梯度算法</h1><p>Monte-Carlo策略梯度的方差较高，因此放弃用return来估计行动-价值函数Q，而是使用 critic 来估计Q：</p><p>$Q_w(s, a)\approx Q^{\pi_{\theta}}(s, a)$</p><p>这就是大名鼎鼎的 Actor-Critic 算法，它有两套参数：</p><ul><li>Critic：更新动作价值函数参数 w </li><li>Actor： 朝着 Critic 方向更新策略参数 θ</li></ul><p>Actor-Critic 算法是一个近似的策略梯度算法：</p><script type="math/tex; mode=display">\triangledown_\theta J(\theta)\approx E_{\pi_{\theta}}[\triangledown_{\theta}\log \pi_{\theta}(s, a)Q_w(s, a)]\\\Delta\theta = \alpha\triangledown_\theta\log\pi_{\theta}(s,a)Q_w(s,a)</script><p>Critic 本质就是在进行策略评估：How good is policy π~θ~  for current parameters θ </p><p>策略评估我们之前介绍过MC、TD、TD(λλ)，以及价值函数近似方法。如下所示，简单的 Actir-Critic 算法 Critic 为动作价值函数近似，使用最为简单的线性方程，即：$Q_w(s, a) = \phi(s, a)^T w$，具体的伪代码如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006125435.png" alt="img"></p><p>在 Actir-Critic 算法中，对策略进行了估计，这会产生误差（bias），但是当满足以下两个条件时，策略梯度是准确的：</p><ul><li>价值函数的估计值没有和策略相违背，即： $\triangledown_w Q_w(s,a) = \triangledown_\theta\log\pi_{\theta}(s,a)$</li><li>价值函数的参数w能够最小化误差，即： $\epsilon = E_{\pi_{\theta}}[(Q^{\pi_{\theta}}(s, a) - Q_w(s,a))^2]$</li></ul><p>最后总结一下策略梯度算法：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006125705.png" alt="img"></p>]]></content>
    
    
    <summary type="html">Policy Gradient Methods</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Value Function Approximation</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Value%20Function%20Approximation/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Value%20Function%20Approximation/</id>
    <published>2021-10-06T15:00:33.000Z</published>
    <updated>2021-10-06T04:08:01.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要值函数近似？"><a href="#为什么需要值函数近似？" class="headerlink" title="为什么需要值函数近似？"></a>为什么需要值函数近似？</h1><p>之前我们提到过各种计算值函数的方法，比如对于 MDP 已知的问题可以使用 Bellman 期望方程求得值函数；对于 MDP 未知的情况，可以通过 MC 以及 TD 方法来获得值函数，为什么需要再进行值函数近似呢？</p><p>其实到目前为止，我们介绍的值函数计算方法都是通过查表的方式获取的：</p><ul><li>表中每一个状态 s  均对应一个 V(s) </li><li>或者每一个状态-动作 <s,a ></li></ul><p>但是对于大型 MDP 问题，上述方法会遇到瓶颈：</p><ul><li>太多的 MDP 状态、动作需要存储</li><li>单独计算每一个状态的价值都非常的耗时</li></ul><p>因此我们需要有一种能够适用于解决大型 MDP 问题的通用方法，这就是本文介绍的值函数近似方法。即：</p><script type="math/tex; mode=display">\hat{v}(s, \mathbf{w}) \approx v_{\pi}(s) \\\text{or } \hat{q}(s, a, \mathbf{w}) \approx q_{\pi}(s, a)</script><p>那么为什么值函数近似的方法可以求解大型 MDP 问题？</p><blockquote><p>对于大型 MDP 问题而言，我们可以近似认为其所有的状态和动作都被采样和计算是不现实的，那么我们一旦获取了近似的值函数，我们就可以对于那些在历史经验或者采样中没有出现过的状态和动作进行泛化（generalize）。</p></blockquote><p>进行值函数近似的训练方法有很多，比如：</p><ul><li>线性回归</li><li>神经网络</li><li>决策树</li><li>…</li></ul><p>此外，针对 MDP 问题的特点，训练函数必须可以适用于非静态、非独立同分布（non-i.i.d）的数据。</p><h1 id="增量方法"><a href="#增量方法" class="headerlink" title="增量方法"></a>增量方法</h1><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="通过随机梯度下降进行值函数近似"><a href="#通过随机梯度下降进行值函数近似" class="headerlink" title="通过随机梯度下降进行值函数近似"></a>通过随机梯度下降进行值函数近似</h3><p>我们优化的目标函数是找到一组参数 w  来最小化最小平方误差（MSE），即：</p><script type="math/tex; mode=display">J(\mathbf{w}) = E_{\pi}[(v_{\pi}(S) - \hat{v}(S, \mathbf{w}))^2]</script><p>通过梯度下降方法来寻优：</p><script type="math/tex; mode=display">\begin{align}\Delta\mathbf{w}&=-\frac{1}{2}\alpha\triangledown_{\mathbf{w}}J(\mathbf{w})\\&=\alpha E_{\pi}\Bigl[\Bigl(v_{\pi}(S) - \hat{v}(S, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}J(\mathbf{w})\Bigr]\end{align}</script><p>对于随机梯度下降（Stochastic Gradient Descent，SGD），对应的梯度：</p><script type="math/tex; mode=display">\Delta\mathbf{w} = \alpha\underbrace{\Bigl(v_{\pi}(S) - \hat{v}(S, \mathbf{w})\Bigr)}_{\text{error}}\underbrace{\triangledown_{\mathbf{w}}\hat{v}(S, \mathbf{w})}_{\text{gradient}}</script><h2 id="值函数近似"><a href="#值函数近似" class="headerlink" title="值函数近似"></a>值函数近似</h2><p>上述公式中需要真实的策略价值函数 vπ(S)vπ(S) 作为学习的目标（supervisor），但是在RL中没有真实的策略价值函数，只有rewards。在实际应用中，我们用v~π~(S)来代替target vπ(S)：</p><ul><li>对于MC，target 为 return G~t ~：</li></ul><script type="math/tex; mode=display">\Delta\mathbf{w}=\alpha\Bigl(G_t - \hat{v}(S_t, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(S_t, \mathbf{w})</script><ul><li>对于TD(0)，target 为TD target $_{t+1}+\gamma\hat{v}(S_{t+1}, \mathbf{w})$：</li></ul><script type="math/tex; mode=display">\Delta\mathbf{w}=\alpha\Bigl(R_{t+1} + \gamma\hat{v}(S_{t+1}, \mathbf{w})- \hat{v}(S_t, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(S_t, \mathbf{w})</script><ul><li>对于TD(λ)，target 为 TD λ-return  $G_t^{\lambda}$：</li></ul><script type="math/tex; mode=display">\Delta\mathbf{w}=\alpha\Bigl(G_t^{\lambda}- \hat{v}(S_t, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(S_t, \mathbf{w})</script><p>在获取了值函数近似后就可以进行控制了，具体示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006115744.png" alt=""></p><h2 id="动作价值函数近似"><a href="#动作价值函数近似" class="headerlink" title="动作价值函数近似"></a>动作价值函数近似</h2><p>动作价值函数近似：</p><script type="math/tex; mode=display">\hat{q}(S, A, \mathbf{w})\approx q_{\pi}(S, A)</script><p>优化目标：最小化MSE</p><script type="math/tex; mode=display">J(\mathbf{w}) = E_{\pi}[(q_{\pi}(S, A) - \hat{q}(S, A, \mathbf{w}))^2]</script><p>使用SGD寻优：</p><script type="math/tex; mode=display">\begin{align} \Delta\mathbf{w} &=-\frac{1}{2}\alpha\triangledown_{\mathbf{w}}J(\mathbf{w})\\ &=\alpha\Bigl(q_{\pi}(S, A)-\hat{q}_{\pi}(S, A, \mathbf{w})\Bigr) \triangledown_{\mathbf{w}}\hat{q}_{\pi}(S, A, \mathbf{w}) \end{align}</script><h1 id="批量方法"><a href="#批量方法" class="headerlink" title="批量方法"></a>批量方法</h1><p>随机梯度下降SGD简单，但是批量的方法可以根据agent的经验来更好的拟合价值函数。</p><h2 id="值函数近似-1"><a href="#值函数近似-1" class="headerlink" title="值函数近似"></a>值函数近似</h2><p>优化目标：批量方法解决的问题同样是  $\hat{v}(s, \mathbf{w})\approx v_{\pi}(s)$</p><p>经验集合  D 包含了一系列的 <state, value> pair：</p><script type="math/tex; mode=display">D=\{<s_1, v_1^{\pi}>, <s_2, v_2^{\pi}>, ..., <s_T, v_T^{\pi}>\}</script><p>根据最小化平方误差之和来拟合 $\hat{v}(s, \mathbf{w})$和 v~π~(s) ，即：</p><script type="math/tex; mode=display">\begin{align}LS(w) &= \sum_{t=1}^{T}(v_{t}^{\pi}-\hat{v}(s_t, \mathbf{w}))^2\\&= E_{D}[(v^{\pi}-\hat{v}(s, \mathbf{w}))^2]\end{align}</script><p>经验回放（Experience Replay）：</p><blockquote><p>给定经验集合：</p><script type="math/tex; mode=display">D=\{<s_1, v_1^{\pi}>, <s_2, v_2^{\pi}>, ..., <s_T, v_T^{\pi}>\}</script><p>Repeat：</p><ol><li>从经验集合中采样状态和价值：<s,v^π^>∼D </li><li>使用SGD进行更新：$\Delta\mathbf{w}=\alpha\Bigl(v^{\pi}-\hat{v}(s, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(s, \mathbf{w})$<br>通过上述经验回放，获得最小化平方误差的参数值：</li></ol><p>$\mathbf{w}^{\pi}=\arg\min_{\mathbf{w}}LS(\mathbf{w})$</p></blockquote><p>我们经常听到的 DQN 算法就使用了经验回放的手段，这个后续会在《深度强化学习》中整理。</p><p>通过上述经验回放和不断的迭代可以获取最小平方误差的参数值，然后就可以通过 greedy 的策略进行策略提升，具体如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006120213.png" alt=""></p><h2 id="动作价值函数近似-1"><a href="#动作价值函数近似-1" class="headerlink" title="动作价值函数近似"></a>动作价值函数近似</h2><p>同样的套路：</p><ul><li>优化目标： $\hat{q}(s, a, \mathbf{w})\approx q_{\pi}(s, a)$</li><li>采取包含 <state, action, value> 的经验集合 D </li><li>通过最小化平方误差来拟合</li></ul><p>对于控制环节，我们采取与Q-Learning一样的思路：</p><ul><li>利用之前策略的经验</li><li>但是考虑另一个后继动作 $A’=\pi_{\text{new}}(S_{t+1})$</li><li>朝着另一个后继动作的方向去更新 $\hat{q}(S_t, A_t, \mathbf{w})$，即</li></ul><p>$\delta = R_{t+1} + \gamma\hat{q}(S_{t+1}, \pi{S_{t+1}, \mathbf{\pi}}) - \hat{q}(S_t, A_t, \mathbf{w})$</p><ul><li>梯度：线性拟合情况，$\Delta\mathbf{w}=\alpha\delta\mathbf{x}(S_t, A_t)$</li></ul>]]></content>
    
    
    <summary type="html">Value Function Approximation</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Model-Free Control</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Model-Free%20Control/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Model-Free%20Control/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-06T03:46:55.610Z</updated>
    
    <content type="html"><![CDATA[<p>上篇总结了 Model-Free Predict 问题及方法，本文内容介绍 Model-Free Control 方法，即 “Optimise the value function of an unknown MDP”。</p><p>在这里说明下，Model-Free Predict/Control 不仅适用于 Model-Free 的情况，其同样适用于 MDP 已知的问题：</p><ul><li>MDP model is unknown, but experience can be sampled.</li><li>MDP model is known, but is too big to use, except by samples.</li></ul><p>在正式介绍 Model-Free Control 方法之前，我们先介绍下 On-policy Learning 及 Off-policy Learning。</p><h2 id="On-policy-Learning-vs-Off-policy-Learning"><a href="#On-policy-Learning-vs-Off-policy-Learning" class="headerlink" title="On-policy Learning vs. Off-policy Learning"></a>On-policy Learning vs. Off-policy Learning</h2><p>On-policy Learning：</p><ul><li>“Learn on the job”</li><li>Learn about policy π from experience sampled from π（即采样的策略与学习的策略一致）</li></ul><p>Off-policy Learning：</p><ul><li>“Look over someone’s shoulder”</li><li>Learn about policy π from experience sampled from μ（即采样的策略与学习的策略不一致）</li></ul><h2 id="On-Policy-Monte-Carlo-Learning"><a href="#On-Policy-Monte-Carlo-Learning" class="headerlink" title="On-Policy Monte-Carlo Learning"></a>On-Policy Monte-Carlo Learning</h2><h3 id="Generalized-Policy-Iteration"><a href="#Generalized-Policy-Iteration" class="headerlink" title="Generalized Policy Iteration"></a>Generalized Policy Iteration</h3><p>具体的 Control 方法，在《动态规划》一文中我们提到了 Model-based 下的广义策略迭代 GPI 框架，那在 Model-Free 情况下是否同样适用呢？<br>如下图为 Model-based 下的广义策略迭代 GPI 框架，主要分两部分：策略评估及基于 Greedy 策略的策略提升。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006105433.png" alt=""></p><h4 id="Model-Free-策略评估"><a href="#Model-Free-策略评估" class="headerlink" title="Model-Free 策略评估"></a>Model-Free 策略评估</h4><p>在《Model-Free Predict》中我们分别介绍了两种 Model-Free 的策略评估方法：MC 和 TD。我们先讨论使用 MC 情况下的 Model-Free 策略评估。<br>如上图GPI框架所示：</p><ul><li>基于 V(s) 的贪婪策略提升需要 MDP 已知：</li></ul><script type="math/tex; mode=display">\pi'(s) = \arg\max_{a\in A}\Bigl(R_{s}^{a}+P_{ss'}^{a}V(s')\Bigr)</script><ul><li>基于 Q(s,a) 的贪婪策略提升不需要 MDP 已知，即 Model-Free：</li></ul><script type="math/tex; mode=display">\pi'(s) = \arg\max_{a\in A}Q(s, a)</script><p>因此 Model-Free 下需要对 Q(s,a) 策略评估，整个GPI策略迭代也要基于 Q(s,a) </p><h4 id="Model-Free-策略提升"><a href="#Model-Free-策略提升" class="headerlink" title="Model-Free 策略提升"></a>Model-Free 策略提升</h4><p>确定了策略评估的对象，那接下来要考虑的就是如何基于策略评估的结果 Q(s,a) 进行策略提升。<br>由于 Model-Free 的策略评估基于对经验的 samples（即评估的 q(s,a)  存在 bias），因此我们在这里不采用纯粹的 greedy 策略，防止因为策略评估的偏差导致整个策略迭代进入局部最优，而是采用具有 explore 功能的  ϵ-greedy 算法：</p><script type="math/tex; mode=display">\pi(a|s) = \begin{cases}&\frac{\epsilon}{m} + 1 - \epsilon, &\text{if } a^*=\arg\max_{a\in A}Q(s, a)\\&\frac{\epsilon}{m}, &\text{otherwise}\end{cases}</script><p>因此，我们确定了 Model-Free 下的 Monto-Carlo Control：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006105953.png" alt=""></p><h3 id="GLIE"><a href="#GLIE" class="headerlink" title="GLIE"></a>GLIE</h3><p>先直接贴下David的课件，GLIE 介绍如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006110036.png" alt=""></p><p>对于 ϵ-greedy 算法而言，如果 ϵ 随着迭代次数逐步减为0，那么  ϵ-greedy 是 GLIE，即：</p><script type="math/tex; mode=display">\epsilon_{k} = \frac{1}{k}</script><h4 id="GLIE-Monto-Carlo-Control"><a href="#GLIE-Monto-Carlo-Control" class="headerlink" title="GLIE Monto-Carlo Control"></a>GLIE Monto-Carlo Control</h4><ul><li>对于 episode 中的每个状态 S~t~  和动作 A~t~</li></ul><script type="math/tex; mode=display">N(S_t, A_t) ← N(S_t, A_t) + 1 \\Q(S_t, A_t) ← Q(S_t, A_t) + \frac{1}{N(S_t, A_t)}(G_t - Q(S_t, A_t))</script><ul><li>基于新的动作价值函数提升策略：</li></ul><script type="math/tex; mode=display">\epsilon ← \frac{1}{k}\\\pi ← \epsilon\text{-greedy}(Q)</script><p>定理：GLIE Monto-Carlo Control 收敛到最优的动作价值函数，即：</p><script type="math/tex; mode=display">Q(s, a) → q_*(s, a)</script><h2 id="On-Policy-Temporal-Difference-Learning"><a href="#On-Policy-Temporal-Difference-Learning" class="headerlink" title="On-Policy Temporal-Difference Learning"></a>On-Policy Temporal-Difference Learning</h2><h3 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h3><p>我们之前总结过 TD 相对 MC 的优势：</p><ul><li>低方差</li><li>Online</li><li>非完整序列</li></ul><p>那么一个很自然的想法就是在整个控制闭环中用 TD 代替 MC：</p><ul><li>使用 TD 来计算 Q(S,A) </li><li>仍然使用  ϵ-greedy 策略提升</li><li>每一个 step 进行更新</li></ul><p>通过上述改变就使得 On-Policy 的蒙特卡洛方法变成了著名的 Sarsa。</p><ul><li>更新动作价值函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006110844.png" alt=""></p><ul><li>Control</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006110937.png" alt=""></p><p>Sarsa算法的伪代码如下：<br><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006111038.png" alt="img"></p><h3 id="Sarsa-λ"><a href="#Sarsa-λ" class="headerlink" title="Sarsa(λ)"></a>Sarsa(λ)</h3><p>n-step Sarsa returns 可以表示如下：<br>n=1 时：$q_{t}^{(1)} = R_{t+1} + \gamma Q(S_{t+1})$<br>n=2 时：$q_{t}^{(2)} = R_{t+1} + \gamma R_{t+2} + \gamma^2 Q(S_{t+2})$<br>…<br>n=∞ 时：$q_{t}^{\infty} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{T-1} R_T)$<br>因此，n-step return $q_{t}^{(n)} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{n}Q(S_{t+n})$</p><p>n-step Sarse 更新公式：</p><p>$Q(S_t,A_t) ← Q(S_t,A_t) + \alpha (q_t^{(n)} - Q(S_t,A_t))$</p><p> 具体的 Sarsa(λ) 算法伪代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006111817.png" alt="img"></p><p>其中 E(s,a)   为资格迹。</p><p>下图为 Sarsa(λ) 用于 Gridworld 例子的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006112106.png" alt=""></p><h2 id="Off-Policy-Learning"><a href="#Off-Policy-Learning" class="headerlink" title="Off-Policy Learning"></a>Off-Policy Learning</h2><p>Off-Policy Learning 的特点是评估目标策略 π(a|s) 来计算 v~π~(s) 或者 q~π~(s,a) 但是跟随行为策略 {S~1~,A~1~,R~2~,…,S~T~}∼μ(a|s) </p><p>Off-Policy Learning 有什么意义？</p><ul><li>Learn from observing humans or other agents</li><li>Re-use experience generated from old policies π~1~,π~2~,…,π~t−1~ </li><li>Learn about optimal policy while following exploratory policy</li><li>Learn about multiple policies while following one policy</li></ul><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>重要性采样的目的是：Estimate the expectation of a different distribution。</p><script type="math/tex; mode=display">\begin{align}E_{X\sim P}[f(X)]&= \sum P(X)f(X)\\&= \sum Q(X)\frac{P(X)}{Q(X)}f(X)\\&= E_{X\sim Q}[\frac{P(X)}{Q(X)}f(X)]\end{align}</script><h4 id="Off-Policy-MC-重要性采样"><a href="#Off-Policy-MC-重要性采样" class="headerlink" title="Off-Policy MC 重要性采样"></a>Off-Policy MC 重要性采样</h4><p>使用策略 π  产生的 return 来评估 μ ：</p><script type="math/tex; mode=display">G_t^{\pi/\mu} = \frac{\pi(A_t|S_t)}{\mu(A_t|S_t)} \frac{\pi(A_{t+1}|S_{t+1})}{\mu(A_{t+1}|S_{t+1})}...\frac{\pi(A_T|S_T)}{\mu(A_T|S_T)}G_t</script><p>朝着正确的 return 方向去更新价值：</p><script type="math/tex; mode=display">V(S_t) ← V(S_t) + \alpha\Bigl(\textcolor{Red}{G_t^{\pi/\mu}}-V(S_t)\Bigr)</script><p>需要注意两点：</p><ul><li>Cannot use if μ  is zero when π  is non-zero</li><li>重要性采样会显著性地提升方差</li></ul><h4 id="Off-Policy-TD-重要性采样"><a href="#Off-Policy-TD-重要性采样" class="headerlink" title="Off-Policy TD 重要性采样"></a>Off-Policy TD 重要性采样</h4><p>TD 是单步的，所以使用策略 π  产生的 TD targets 来评估 μ ：</p><script type="math/tex; mode=display">V(S_t) ← V(S_t) + \alpha\Bigl(\frac{\pi(A_t|S_t)}{\mu(A_t|S_t)}(R_{t+1}+\gamma V(S_{t+1}))-V(S_t)\Bigr)</script><ul><li>方差比MC版本的重要性采样低很多</li></ul><h3 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h3><p>前面分别介绍了对价值函数 V(s)  进行 off-policy 学习，现在我们讨论如何对动作价值函数 Q(s,a)  进行 off-policy 学习：</p><ul><li><p>不需要重要性采样</p></li><li><p>使用行为策略选出下一步的动作：$A_{t+1}\sim\mu(·|S_t)$</p></li><li><p>但是仍需要考虑另一个后继动作：$A’\sim\pi(·|S_t)$</p></li><li><p>朝着另一个后继动作的价值更新 $Q(S_t, A_t)$</p></li></ul><script type="math/tex; mode=display">Q(S_t, A_t) ← Q(S_t, A_t) + \alpha\Bigl(R_{t+1}+\gamma Q(S_{t+1}, A')-Q(S_t, A_t)\Bigr)</script><p>讨论完对动作价值函数的学习，我们接着看如何通过 Q-Learning 进行 Control：</p><ul><li>行为策略和目标策略均改进</li><li>目标策略 π  以greedy方式改进：</li></ul><script type="math/tex; mode=display">\pi(S_t) = \arg\max_{a'}Q(S_{t+1}, a')</script><ul><li>行为策略 μ  以  ϵ-greedy 方式改进</li><li>Q-Learning target：</li></ul><script type="math/tex; mode=display">\begin{align}&R_{t+1}+\gamma Q(S_{t+1}, A')\\=&R_{t+1}+\gamma Q\Bigl(S_{t+1}, \arg\max_{a'}Q(S_{t+1}, a')\Bigr)\\=&R_{t+1}+\max_{a'}\gamma Q(S_{t+1}, a')\end{align}</script><p>Q-Learning 的 backup tree 如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114145.png" alt=""></p><p>关于 Q-Learning 的结论：</p><blockquote><p>Q-learning control converges to the optimal action-value function, Q(s,a)→q~∗~(s,a) </p></blockquote><p>Q-Learning 算法具体的伪代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114205.png" alt=""></p><p>对比 Sarsa 与 Q-Learning 可以发现两个最重要的区别：</p><ul><li>TD target 公式不同</li><li>Q-Learning 中下一步的动作从行为策略中选出，而不是目标策略</li></ul><h2 id="DP-vs-TD"><a href="#DP-vs-TD" class="headerlink" title="DP vs. TD"></a>DP vs. TD</h2><p>两者的区别见下表：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114507.png" alt="">  </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114532.png" alt=""></p>]]></content>
    
    
    <summary type="html">Model-Free Control</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Model-Free Prediction</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Model-Free%20Prediction/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Model-Free%20Prediction/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T15:15:35.589Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了 Model-based 的通用方法——动态规划，本文内容介绍 Model-Free 情况下 Prediction 问题，即 “Estimate the value function of an unknown MDP”。</p><ul><li>Model-based：MDP已知，即转移矩阵和奖赏函数均已知</li><li>Model-Free：MDP未知</li></ul><h2 id="蒙特卡洛学习"><a href="#蒙特卡洛学习" class="headerlink" title="蒙特卡洛学习"></a>蒙特卡洛学习</h2><p>蒙特卡洛方法（Monte-Carlo Methods，简称MC）也叫做蒙特卡洛模拟，是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。其实本质就是，通过尽可能随机的行为产生后验，然后通过后验来表征目标系统。</p><p>在Model-Free的情况下，MC在强化学习中的应用就是获取价值函数，其特点如下：</p><ul><li>MC 可以从完整的 episodes 中学习（no bootstrapping）</li><li>MC 以均值来计算价值，即 value = mean(return)</li><li>MC 只能适用于 episodic MDPs（有限MDPs）</li></ul><h3 id="First-Visit-蒙特卡洛策略评估"><a href="#First-Visit-蒙特卡洛策略评估" class="headerlink" title="First-Visit 蒙特卡洛策略评估"></a>First-Visit 蒙特卡洛策略评估</h3><p>First-Visit Monte-Carlo Policy Evaluation：</p><blockquote><p>评估状态 s  在给定策略 π  下的价值函数 v~π~(s))时，在一次 episode 中，状态 s  在时刻  t <strong>第一次</strong>被访问时，计数器 N(s)←N(s)+1 ，累计价值 S(s)←S(s)+Gt<br>当整个过程结束后，状态 s 的价值  $V(s) = \frac{S(s)}{N(s)}$根据大数定理（Law of Large Numbers）：$V(s) → v_{\pi}(s) \text{ as } N(s) → \infty$</p></blockquote><h3 id="Every-Visit-蒙特卡洛策略评估"><a href="#Every-Visit-蒙特卡洛策略评估" class="headerlink" title="Every-Visit 蒙特卡洛策略评估"></a>Every-Visit 蒙特卡洛策略评估</h3><p>Every-Visit Monte-Carlo Policy Evaluation：</p><blockquote><p>评估状态 s  在给定策略 π 下的价值函数 v~π(~s)时，在一次 episode 中，状态 s 在时刻 t <strong>每次</strong>被访问时，计数器 N(s)←N(s)+1，累计价值 S(s)←S(s)+Gt<br>当整个过程结束后，状态 s 的价值 V(s)=S(s)/N(s)<br>根据大数定理（Law of Large Numbers）：V(s)→v~π~(s) as N(s)→∞</p></blockquote><h3 id="Incremental-Monte-Carlo"><a href="#Incremental-Monte-Carlo" class="headerlink" title="Incremental Monte-Carlo"></a>Incremental Monte-Carlo</h3><p>增量式求平均：<br>The mean μ1,μ2,… of a sequence x1,x2,… . can be computed incrementally：</p><script type="math/tex; mode=display">\begin{align}\mu_k &= \frac{1}{k}\sum_{j=1}^{k}x_j\\&= \frac{1}{k}\Bigl(x_k+\sum_{j=1}^{k-1}x_j \Bigr)\\&= \frac{1}{k}(x_k + (k-1)\mu_{k-1})\\&= \mu_{k-1} + \frac{1}{k}(x_k - \mu_{k-1})\end{align}</script><p>根据上式我们可以得出增量式进行MC更新的公式：<br>每次 episode 结束后，增量式更新 V(s) ，对于每个状态 St ，其对应的 return 为 Gt :</p><p> $N(S_t) ← N(S_t) + 1 \\ V(S_t) ← V(S_t) + \frac{1}{N(S_t)}(G_t - V(S_t))$</p><p>在非静态问题中，更新公式形式可以改为如下：</p><p>$V(S_t) ← V(S_t) + \alpha (G_t - V(S_t))$</p><h2 id="时序差分学习"><a href="#时序差分学习" class="headerlink" title="时序差分学习"></a>时序差分学习</h2><p>时序差分方法（Temporal-Difference Methods，简称TD）特点：</p><ul><li>TD 可以通过 bootstrapping 从非完整的 episodes 中学习</li><li>TD updates a guess towards a guess</li></ul><h3 id="TD-λ"><a href="#TD-λ" class="headerlink" title="TD(λ)"></a>TD(λ)</h3><p>下图为 TD target 在不同 n 下的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005224847.png" alt=""></p><p>从上图可以看出，当 n 达到终止时，即为一个episode，此时对应的方法为MC，因此从这个角度看，MC属于TD的特殊情况。</p><h3 id="n-step-Return"><a href="#n-step-Return" class="headerlink" title="n-step Return"></a>n-step Return</h3><p>n-step returns 可以表示如下：<br>n=1 时：$G_{t}^{(1)} = R_{t+1} + \gamma V(S_{t+1})$<br>n=2 时：$G_{t}^{(2)} = R_{t+1} + \gamma R_{t+2} + \gamma^2 V(S_{t+2})$<br>…<br>n=∞ 时：$G_{t}^{\infty} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{T-1} R_T)$<br>因此，n-step return $G_{t}^{(n)} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{n}V(S_{t+n})$</p><p>n-step TD 更新公式：</p><p>$V(S_t) ← V(S_t) + \alpha (G_t^{(n)} - V(S_t))$</p><h3 id="Forward-View-of-TD-λ"><a href="#Forward-View-of-TD-λ" class="headerlink" title="Forward View of TD(λ)"></a>Forward View of TD(λ)</h3><p>我们能否把所有的 n-step return 组合起来？答案肯定是可以，组合后的return被称为是λ-return，其中λ是为了组合不同的n-step returns引入的权重因子。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005225422.png" alt=""></p><p>λ-return:</p><p>$G_t^{\lambda} = (1-\lambda)\sum_{n=1}^{\infty}\lambda^{n-1}G_t^{(n)}$</p><p>Forward-view TD(λλ)：</p><p>$V(S_t) ← V(S_t) + \alpha\Bigl(G_t^{\lambda} - V(S_t)\Bigr)$</p><p>TD(λ)对应的权重公式为 (1−λ)λ^n−1^，分布图如下所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181029093216246-346895182.png" alt=""></p><p>Forward-view TD(λ)的特点：</p><ul><li>Update value function towards the λ-return</li><li>Forward-view looks into the future to compute GλtGtλ</li><li>Like MC, can only be computed from complete episodes</li></ul><h3 id="Backward-View-TD-λ"><a href="#Backward-View-TD-λ" class="headerlink" title="Backward View TD(λ)"></a>Backward View TD(λ)</h3><ul><li>Forward view provides theory</li><li>Backward view provides mechanism</li><li>Update online, every step, from incomplete sequences</li></ul><p>带有资格迹的TD(λλ)：</p><script type="math/tex; mode=display">\delta_t = R_{t+1} + \gamma V(S_{t+1}) - V(S_t)\\V(s) ← V(s) + \alpha \delta_t E_t(s)</script><p>其中δt为TD-error，Et(s)为资格迹。</p><p><strong>资格迹(Eligibility Traces)</strong></p><blockquote><p>资格迹本质就是对于频率高的，最近的状态赋予更高的信任（credit）/ 权重。</p></blockquote><p>下图是对资格迹的一个描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005230115.png" alt=""></p><p>关于TD(λ)有一个结论：</p><blockquote><p>The sum of offline updates is identical for forward-view and backward-view TD(λ).</p></blockquote><p>这一块的内容不再深入介绍了，感兴趣的可以看Sutton的书和David的教程。</p><h2 id="蒙特卡洛学习-vs-时序差分学习"><a href="#蒙特卡洛学习-vs-时序差分学习" class="headerlink" title="蒙特卡洛学习 vs. 时序差分学习"></a>蒙特卡洛学习 vs. 时序差分学习</h2><h3 id="MC与TD异同点"><a href="#MC与TD异同点" class="headerlink" title="MC与TD异同点"></a>MC与TD异同点</h3><p>相同点：都是从经验中在线的学习给定策略 π 的价值函数 v~π~</p><p>不同点：</p><ul><li>Incremental every-visit Monte-Carlo：朝着真实的 return G~t~  更新 V(S~t~) </li></ul><p>$V(S_t) ← V(S_t) + \alpha (\textcolor{Red}{G_t}   - V(S_t))$</p><ul><li><p>Simplest temporal-difference learning algorithm: TD(0)</p><ul><li>朝着已预估的 return  $\color{Red}{R_{t+1} + \gamma V(S_{t+1})}$ 更新 V(S~t~) </li></ul><script type="math/tex; mode=display">V(S_t) ← V(S_t) + \alpha (\textcolor{Red}{R_{t+1} + \gamma V(S_{t+1})} - V(S_t))</script><ul><li>$\color{Red}{R_{t+1} + \gamma V(S_{t+1})}$称为是 TD target</li><li>$\color{Red}{R_{t+1} + \gamma V(S_{t+1})}−V(S_{t})$ 称为是 TD error</li></ul></li></ul><p>下图以 Drive Home 举例说明两者的不同，MC 只能在回家后才能改变对回家时间的预判，而 TD 在每一步中不断根据实际情况来调整自己的预判。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231045.png" alt=""></p><h2 id="MC与TD优缺点"><a href="#MC与TD优缺点" class="headerlink" title="MC与TD优缺点"></a>MC与TD优缺点</h2><h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><ul><li>TD 可以在知道最后结果之前学习（如上图举例）<ul><li>TD can learn online after every step</li><li>MC must wait until end of episode before return is known</li></ul></li><li>TD 可以在不存在最后结果的情况下学习（比如无限/连续MDPs）<ul><li>TD can learn from incomplete sequences</li><li>MC can only learn from complete sequences</li><li>TD works in continuing (non-terminating) environments</li><li>MC only works for episodic (terminating) environments</li></ul></li></ul><h3 id="方差与偏差"><a href="#方差与偏差" class="headerlink" title="方差与偏差"></a>方差与偏差</h3><ul><li>MC has high variance, zero bias（高方差，零偏差）<ul><li>Good convergence properties</li><li>Not very sensitive to initial value</li><li>Very simple to understand and use</li></ul></li><li>TD has low variance, some bias（低方差，存在一定偏差）<ul><li>Usually more efficient than MC</li><li>TD(0) converges to vπ(s)vπ(s)</li><li>More sensitive to initial value</li></ul></li></ul><p>关于 MC 和 TD 中方差和偏差问题的解释：</p><blockquote><ul><li>MC 更新基于真实的 return  $G_t = R_{t+1} + \gamma R_{t+2} + … + \gamma^{T-1}R_{T}$是 v~π~(St)  的无偏估计。</li><li>真实的TD target $R_{t+1} + \gamma v_{\pi}(S_{t+1})$ 也是 vπ(St) 的无偏估计。但是实际更新时用的 TD target $R_{t+1} + \gamma V(S_{t+1})$ 是 vπ(St)  的有偏估计。</li><li>TD target 具有更低的偏差：<ul><li>Return 每次模拟依赖于许多的随机动作、转移概率以及回报</li><li>TD target 每次只依赖一次随机动作、转移概率以及回报</li></ul></li></ul></blockquote><h3 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h3><ul><li>TD exploits Markov property<ul><li>Usually more efficient in Markov environments</li></ul></li><li>MC does not exploit Markov property<ul><li>Usually more effective in non-Markov environments</li></ul></li></ul><h2 id="DP、MC以及TD-0"><a href="#DP、MC以及TD-0" class="headerlink" title="DP、MC以及TD(0)"></a>DP、MC以及TD(0)</h2><p>首先我们从 backup tree 上去直观地认识三者的不同。</p><ul><li>DP backup tree：Full-Width step（完整的step）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231417.png" alt=""></p><ul><li>MC backup tree：完整的episode</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231438.png" alt=""></p><ul><li>TD(0) backup tree：单个step</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231514.png" alt=""></p><h2 id="Bootstrapping-vs-Sampling"><a href="#Bootstrapping-vs-Sampling" class="headerlink" title="Bootstrapping vs. Sampling"></a>Bootstrapping vs. Sampling</h2><p>Bootstrapping：基于已预测的值进行更新</p><ul><li>DP bootstraps</li><li>MC does not bootstrap</li><li>TD bootstraps</li></ul><p>Sampling：基于采样的期望来更新</p><ul><li>DP does not sample（model-based methods don’t need sample）</li><li>MC samples（model-free methods need sample）</li><li>TD samples（model-free methods need sample）</li></ul><p>下图从宏观的视角显示了 RL 的几种基本方法的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231530.png" alt=""></p>]]></content>
    
    
    <summary type="html">Model-Free Prediction</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Cross-entrpy Method</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Cross-entroy%20Method/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Cross-entroy%20Method/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:26:06.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CEM-amp-amp-RL"><a href="#CEM-amp-amp-RL" class="headerlink" title="CEM &amp;&amp; RL"></a>CEM &amp;&amp; RL</h3><p>注：以下内容引自博文《进化策略优化算法CEM(Cross Entropy Method)》[1]。</p><p>CEM也可以用来求解马尔可夫决策过程，也就是强化学习问题。我们知道，强化学习也是一种动态规划过程，在某个状态下选择某个动作就像在某个节点选择路径一样，整个过程就是一个从初始状态到末状态的路径规划问题，只不过我们希望得到一条能最大化收益的路径。在这种考虑下，就可以用CEM建模了，我们让一条完整的路径成为一个样本x=(s0,a0,s1,a1,…,sn,an)，路径获得的总收益为S(x)=∑Ni=0r(si,ai)，目标是最大化这个S(x)，那么如何采样出这些样本呢？我们可以构建一个pp矩阵：矩阵行表示状态，列表示动作，如pij表示在状态si下执行aj动作的概率，我们通过对这个pp矩阵进行多次采样就可以获得多个样本，然后选出S(x)较高的样本用来更新pp矩阵，不断迭代，最终找到最优p^矩阵。</p><p>这是一种类似于策略迭代(policy iteration)的强化学习方法：通过p矩阵找到在每一步状态下各个动作的概率来形成决策策略，但参数更新并没有用到梯度。从另外一个角度，你也可以认为这是一种值迭代(value iteration)的强化学习方法，此时p矩阵就是经典Q-learning中的Q矩阵，只不过Q矩阵中第i行第j列元素表示的是状态si下动作aj的未来收益的期望，基于贝尔曼方程(Bellman equation)来更新Q值；而p矩阵表示的是概率值，通过交叉墒来更新。</p><p>[1] <a href="https://blog.csdn.net/ppp8300885/article/details/80567682">进化策略优化算法CEM(Cross Entropy Method)</a></p>]]></content>
    
    
    <summary type="html">Cross-entrpy Method</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:25:54.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，简称DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于具有如下性质的问题：</p><ul><li>具有最优子结构（Optimal substructure）<ul><li>Principle of optimality applies</li><li>Optimal solution can be decomposed into subproblems</li></ul></li><li>重叠子问题（Overlapping subproblems）<ul><li>Subproblems recur many times</li><li>Solutions can be cached and reused</li></ul></li></ul><p>动态规划方法所耗时间往往远少于朴素解法。</p><p>马尔可夫决策过程MDP满足上述两个性质：</p><ul><li>贝尔曼方程提供了递归分解的结构；</li><li>价值函数可以保存和重复使用递归时的结果。</li></ul><h2 id="使用动态规划解决MDP-MRP"><a href="#使用动态规划解决MDP-MRP" class="headerlink" title="使用动态规划解决MDP/MRP"></a>使用动态规划解决MDP/MRP</h2><p>动态规划需要满足MDP过程是已知的（model-based）。</p><ul><li>For Predict：<ul><li>Input：MDP  <S,A,P,R,$\gamma$> 和策略 π 或者是 MRP <S,P,R,$\gamma$> </li><li>Output：价值函数 v~π~</li></ul></li><li>For Control：<ul><li>Input：MDP <S,A,P,R,$\gamma$> </li><li>Output：最优价值函数 v∗  或者最优策略 π∗</li></ul></li></ul><h2 id="策略评估"><a href="#策略评估" class="headerlink" title="策略评估"></a>策略评估</h2><p>策略评估（Policy Evaluation）指的是计算给定策略的价值，解决的问题是 “How to evaluate a policy”。</p><p>策略评估的思路：迭代使用贝尔曼期望方程（关于 MDP 的贝尔曼期望方程形式见《马尔可夫决策过程》）。</p><p>策略评估过程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005220219.png" style="zoom: 67%;" /></p><script type="math/tex; mode=display">v_{k+1} = \sum_{a\in A}\pi(a|s) \Bigl( R_{s}^a + \gamma\sum_{s'\in S}P_{ss'}^a v_{k}(s') \Bigr)</script><p>使用向量形式表示：</p><script type="math/tex; mode=display">\mathbf{v^{k+1}} = \mathbf{R^{\pi}} + \gamma \mathbf{P^{\pi}v^{k}}</script><h2 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h2><p>策略迭代（Policy Iteration，简称PI）解决的问题是 “How to improve a policy”。</p><p>给定一个策略 π ：</p><ul><li>评估策略 π </li></ul><script type="math/tex; mode=display">v_{\pi}(s) = E[R_{t+1} + \gamma R_{t+2} + ...| S_t = s]</script><ul><li>提升策略：通过采用贪婪方法来提升策略：<script type="math/tex; mode=display">\pi ' = \text{greedy}(v_{\pi})</script></li></ul><p>可以证明，策略迭代不断进行总是能收敛到最优策略，即 π′=π∗</p><p>策略迭代可以使用下图来形式化的描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005221105.png" alt=""></p><h2 id="广义策略迭代"><a href="#广义策略迭代" class="headerlink" title="广义策略迭代"></a>广义策略迭代</h2><p>通过上述提到的策略评估我们不难发现，策略评估是一个不断迭代的过程：</p><script type="math/tex; mode=display">v_{\pi}(s) = E[R_{t+1} + \gamma R_{t+2} + ...| S_t = s]</script><p>那么问题来了，Does policy evaluation need to converge to vπvπ?<br>我们是不是可以引入一个停止规则或者规定在迭代 kk 次后停止策略评估？<br>再进一步想，我们为什么不在每次策略评估的迭代过程中进行策略提升（等同于策略评估迭代1次后停止）？<br>注：这和后续要介绍的值迭代等价。</p><p>因此我们可以把上述策略迭代的过程一般化，即广义策略迭代（Generalised Policy Iteration，简称GPI）框架：</p><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005221407.png" alt=""></p><h1 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h1><p>介绍值迭代之前，我们先介绍下最优化原理。</p><h2 id="最优化原理"><a href="#最优化原理" class="headerlink" title="最优化原理"></a>最优化原理</h2><p>最优化原理（Principle of Optimality）定义：</p><blockquote><p>一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后诸策略对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略。</p></blockquote><p>最优化原理如果用数学化一点的语言来描述的话就是：</p><blockquote><p>以状态 ss 为起始点，策略 π(a|s) 可以得到最优值   $v_{\pi}(s) = v_*(s)$当且仅当：</p><ul><li>任意状态 s′ 对于状态 s  均可达；</li><li>以状态 s′ 为起始点，策略 π 可以得到最优值$v_{\pi}(s’) = v_*(s’)$</li></ul></blockquote><p>根据最优化原理可知，如果我们得到了子问题的解 v∗(s′)v∗(s′)，那么以状态 ss 为起始点的最优解 v∗(s)v∗(s) 可以通过一步回退（one-step lookahead）就能获取：</p><script type="math/tex; mode=display">v_*(s) ← \max_{a\in A}\Bigl(R_s^a + \gamma \sum_{s'\in S}P_{ss'}^{a}v_*(s') \Bigr)</script><p>也就是说，我们可以从最后开始向前回退从而得到最优解，值迭代就是基于上述思想进行迭代更新的。</p><h2 id="MDP值迭代"><a href="#MDP值迭代" class="headerlink" title="MDP值迭代"></a>MDP值迭代</h2><p>值迭代（Value Iteration，简称VI）解决的问题也是 “Find optimal policy ππ”。<br>但是不同于策略迭代使用贝尔曼期望方程的是，值迭代使用贝尔曼最优方程进行迭代提升。</p><p>值迭代与策略迭代不同的地方在于：</p><ul><li>Use Bellman optimal function, rather than Bellman expectation function</li><li>Unlike policy iteration, there is no explicit policy</li><li>Intermediate value functions may not correspond to any policy</li></ul><p>如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181028144014755-573375074.png" alt=""></p><script type="math/tex; mode=display">v_{k+1}(s) = \max_{a\in A}\Bigl(R_s^a + \gamma\sum_{s'\in S}P_{ss'}^a v_k(s') \Bigr)</script><p>对应的向量表示为：</p><script type="math/tex; mode=display">\mathbf{v}_{k+1} = \max_{a\in A}\mathbf{R}^a + \gamma \mathbf{P^av}^k</script><p>下图为三种方法的总结：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181028144022645-1891229163.png" alt=""></p><h2 id="动态规划扩展"><a href="#动态规划扩展" class="headerlink" title="动态规划扩展"></a>动态规划扩展</h2><h3 id="异步动态规划（Asynchronous-Dynamic-Programming）"><a href="#异步动态规划（Asynchronous-Dynamic-Programming）" class="headerlink" title="异步动态规划（Asynchronous Dynamic Programming）"></a>异步动态规划（Asynchronous Dynamic Programming）</h3><ul><li>In-place dynamic programming</li><li>Prioritised sweeping</li><li>Real-time dynamic programming</li></ul><h3 id="Full-Width-Backups-vs-Sample-Backups"><a href="#Full-Width-Backups-vs-Sample-Backups" class="headerlink" title="Full-Width Backups vs. Sample Backups"></a>Full-Width Backups vs. Sample Backups</h3><h4 id="Full-Width-Backups"><a href="#Full-Width-Backups" class="headerlink" title="Full-Width Backups"></a>Full-Width Backups</h4><ul><li>DP uses full-width backups（DP is model-based）<ul><li>Every successor state and action is considered</li><li>Using knowledge of the MDP transitions and reward function</li></ul></li><li>DP is effective for medium-sized problems (millions of states)</li><li>For large problems, DP suffers Bellman’s curse of dimensionality（维度灾难）</li></ul><blockquote><p>维度灾难：Number of states n=|S|  grows exponentially with number of state variables</p></blockquote><ul><li>Even one backup can be too expensive</li></ul><h4 id="Sample-Backups"><a href="#Sample-Backups" class="headerlink" title="Sample Backups"></a>Sample Backups</h4><p>后续将要讨论的时序差分方法</p><ul><li>Using sample rewards and sample transitions ⟨S,A,R,S’⟩ </li><li>Instead of reward function R and transition dynamics P</li><li>Advantages:<ul><li>Model-free: no advance knowledge of MDP required</li><li>Breaks the curse of dimensionality through sampling</li><li>Cost of backup is constant, independent of n=|S|</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Model-based 的通用方法——动态规划</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习介绍</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:26:00.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强化学习四元素"><a href="#强化学习四元素" class="headerlink" title="强化学习四元素"></a>强化学习四元素</h2><ul><li>策略（Policy）：环境的感知状态到行动的映射方式。</li><li>反馈（Reward）：环境对智能体行动的反馈。</li><li>价值函数（Value Function）：评估状态的价值函数，状态的价值即从当前状态开始，期望在未来获得的奖赏。</li><li>环境模型（Model）：模拟环境的行为</li></ul><h2 id="强化学习的特点"><a href="#强化学习的特点" class="headerlink" title="强化学习的特点"></a>强化学习的特点</h2><ul><li>起源于动物学习心理学的试错法（trial-and-error），因此符合行为心理学。</li><li>寻求探索（exploration）和采用（exploitation）之间的权衡：强化学习一面要采用（exploitation）已经发现的有效行动，另一方面也要探索（exploration）那些没有被认可的行动，已找到更好的解决方案。</li><li>考虑整个问题而不是子问题。</li><li>通用AI解决方案。</li></ul><h2 id="强化学习-vs-机器学习"><a href="#强化学习-vs-机器学习" class="headerlink" title="强化学习 vs. 机器学习"></a>强化学习 vs. 机器学习</h2><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005205458.png" alt="img"></p><p>强化学习与其他机器学习的不同：</p><ul><li>强化学习更加专注于在线规划，需要在探索（explore 未知领域）和采用（exploit 现有知识）之间找到平衡。</li><li>强化学习不需要监督者，只需要获取环境的反馈。</li><li>反馈是延迟的，不是立即生成的。</li><li>时间在强化学习中很重要，其数据为序列数据，并不满足独立同分布假设（i.i.d）。</li></ul><h2 id="强化学习-vs-监督学习"><a href="#强化学习-vs-监督学习" class="headerlink" title="强化学习 vs. 监督学习"></a>强化学习 vs. 监督学习</h2><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005205751.png" alt="img"></p><p>两者的目标都是学习一个model，而区别在于：</p><p>监督学习：</p><ul><li>Open loop</li><li>Learning from labeled data</li><li>Passive data</li></ul><p>强化学习：</p><ul><li>Closed loop</li><li>Learning from decayed reward</li><li>Explore environment</li></ul><h2 id="强化学习-vs-进化算法"><a href="#强化学习-vs-进化算法" class="headerlink" title="强化学习 vs. 进化算法"></a>强化学习 vs. 进化算法</h2><p>进化算法（Evolutionary Algorithms，简称EA）是通过生物进化优胜略汰，适者生存的启发而发展的一类算法，通过种群不断地迭代达到优化的目标。 </p><p>进化算法最大的优点在于整个优化过程是gradients-free的，其思想可以通过下图表示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005205858.gif" alt=""></p><p>RL和EA虽然都属于优化问题的求解框架，而且两者都需要大量的算力，但是两者有着本质上的区别。</p><p>Sutton在其强化学习介绍一书中也重点谈到了RL与EA的区别</p><ul><li>RL通过与环境交互来进行学习，而EA通过种群迭代来进行学习；</li><li>RL通过最大化累计回报来解决序列问题，而EAs通过最大化适应函数（Fitness Function）来寻求单步最优；</li><li><p>RL对于state过于依赖，而EA在agent不能准确感知环境的状态类问题上也能适用。</p><p>很多研究也尝试通过将EA和RL结合解决优化问题， </p></li></ul><h2 id="强化学习分类"><a href="#强化学习分类" class="headerlink" title="强化学习分类"></a>强化学习分类</h2><p>强化学习分类比较多样：</p><ul><li>按照环境是否已知可以分为Model-based &amp; Model-free；</li><li>按照学习方式可以分为On-Policy &amp; Off-Policy；</li><li>按照学习目标可以分为Value-based &amp; Policy-based。</li></ul><p>下图为根据环境是否已知进行细分的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005210120.png" alt=""></p><h2 id="强化学习相关推荐资料"><a href="#强化学习相关推荐资料" class="headerlink" title="强化学习相关推荐资料"></a>强化学习相关推荐资料</h2><ul><li>Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto：介绍强化学习很全面的一本书籍，相关的电子书及源码见<a href="http://incompleteideas.net/book/the-book.html">这里</a>。</li><li>David Silver在UCL的强化学习视频教程：介绍强化学习的视频教程，基本与Sutton的书籍可以配套学习，Silver来自于Google Deepmind，视频和课件可以从<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html">Silver的主页</a>获取，中文字幕版视频YouTube链接点<a href="https://www.youtube.com/playlist?list=PLjSwXXbVlK6K2enbNmPGjnmB8QBRgCv5s">这里</a>。</li><li>强化学习在阿里的技术演进与业务创新：介绍强化学习在阿里巴巴的落地，可以拓展强化学习应用的业务思路，电子版见<a href="https://pan.baidu.com/s/1jMj1e5zt_g3R7zgWRJ5t2A">这里</a>，密码：yh48。</li><li>Tutorial: Deep Reinforcement Learning：同样来自于Sliver的一个课件，主要针对RL与DL的结合进行介绍，电子版见<a href="https://pan.baidu.com/s/1jLAHZXJqsWg8JVHDBcunvw">这里</a>，密码：9mrp。</li><li>莫烦PYTHON强化学习视频教程：可以通过简短的视频概括地了解强化学习相关内容，适合于入门的同学，视频见<a href="https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/">这里</a>。</li><li>OpenAI Gym：Gym is a toolkit for developing and comparing reinforcement learning algorithms，Gym包含了很多的控制游戏（比如过山车、二级立杆、Atari游戏等），并提供了非常好的接口可以学习，链接见<a href="https://gym.openai.com/docs/">这里</a>。</li><li>Lil’Log：介绍DL和RL的一个优质博客，RL相关包括RL介绍、Policy Gradients算法介绍及Deep RL结合Tensorflow和Gym的源码实现，主页链接见<a href="https://lilianweng.github.io/lil-log/">这里</a>。</li></ul><p>转载自：<a href="https://www.cnblogs.com/maybe2030/p/9862353.html#_label0">[Reinforcement Learning] 强化学习介绍 - Poll的笔记 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">强化学习介绍</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>马尔可夫决策过程</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:25:37.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情节性任务-vs-连续任务"><a href="#情节性任务-vs-连续任务" class="headerlink" title="情节性任务 vs. 连续任务"></a>情节性任务 vs. 连续任务</h2><ul><li>情节性任务（Episodic Tasks），所有的任务可以被可以分解成一系列情节，可以看作为有限步骤的任务。</li><li>连续任务（Continuing Tasks），所有的任务不能分解，可以看作为无限步骤任务。</li></ul><h2 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h2><p>马尔可夫性：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。</p><p>马尔可夫过程即为具有马尔可夫性的过程，即过程的条件概率仅仅与系统的当前状态相关，而与它的过去历史或未来状态都是独立、不相关的。</p><h2 id="马尔可夫奖赏过程"><a href="#马尔可夫奖赏过程" class="headerlink" title="马尔可夫奖赏过程"></a>马尔可夫奖赏过程</h2><p>马尔可夫奖赏过程（Markov Reward Process，MRP）是带有奖赏值的马尔可夫过程，其可以用一个四元组表示 <S,P,R,$\gamma$> </p><ul><li>S 为有限的状态集合；</li><li>P 为状态转移矩阵，$P_{ss^{‘}} = P[S_{t+1} = s^{‘}|S_t = s]$</li><li>R 是奖赏函数；</li><li>$\gamma$为折扣因子（discount factor），其中 $\gamma$∈[0,1]</li></ul><h3 id="奖赏函数"><a href="#奖赏函数" class="headerlink" title="奖赏函数"></a>奖赏函数</h3><p>在 t 时刻的奖赏值 Gt :</p><script type="math/tex; mode=display">G_t = R_{t+1} + \gamma R_{t+2} + ... = \sum_{k=0}^{\infty}\gamma^{k}R_{t+k+1}</script><h3 id="Why-Discount"><a href="#Why-Discount" class="headerlink" title="Why Discount"></a>Why Discount</h3><p>关于Return的计算为什么需要 $\gamma$ 折扣系数:</p><blockquote><ul><li>数学表达的方便</li><li>避免陷入无限循环</li><li>远期利益具有一定的不确定性</li><li>在金融学上，立即的回报相对于延迟的回报能够获得更多的利益</li><li>符合人类更看重眼前利益的特点</li></ul></blockquote><h3 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h3><p>状态 s 的长期价值函数表示为：</p><script type="math/tex; mode=display"> v(s)=E[Gt|St=s]</script><h3 id="Bellman-Equation-for-MRPs"><a href="#Bellman-Equation-for-MRPs" class="headerlink" title="Bellman Equation for MRPs"></a>Bellman Equation for MRPs</h3><script type="math/tex; mode=display">\begin{align}v(s) &= E[G_t|S_t=s]\\&= E[R_{t+1} + \gamma R_{t+2} + ... | S_t = s]\\&= E[R_{t+1} + \gamma (R_{t+2} + \gamma R_{t+3} ... ) | S_t = s]\\&= E[R_{t+1} + \gamma G_{t+1} | S_t = s]\\&= E[R_{t+1} + \gamma v(s_{t+1}) | S_t = s]\end{align}</script><p>下图为MRP的 backup tree 示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005211526.png" alt="img"></p><p>注：backup tree 中的白色圆圈代表状态，黑色圆点对应动作。</p><p>根据上图可以进一步得到：</p><script type="math/tex; mode=display">v(s) = R_s + \gamma \sum_{s' \in S}P_{ss'}v(s')</script><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p>马尔可夫决策过程（Markov Decision Process，MDP）是带有决策的MRP，其可以由一个五元组构成 <S,A,P,R,$\gamma$> 。</p><ul><li>S 为有限的状态集合；</li><li>A 为有限的动作集合；</li><li>P 为状态转移矩阵，$P_{ss^{‘}}^{a} = P[S_{t+1} = s^{‘}|S_t = s,A_t=a]$</li><li>R 是奖赏函数；</li><li>$\gamma$ 为折扣因子（discount factor），其中 $\gamma$∈[0,1] ]</li></ul><p>我们讨论的MDP一般指有限（离散）马尔可夫决策过程。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>策略（Policy）是给定状态下的动作概率分布，即：</p><script type="math/tex; mode=display">\pi(a|s) = P[A_t = a|S_t = a]</script><h2 id="状态价值函数-amp-最优状态价值函数"><a href="#状态价值函数-amp-最优状态价值函数" class="headerlink" title="状态价值函数 &amp; 最优状态价值函数"></a>状态价值函数 &amp; 最优状态价值函数</h2><p>给定策略 π 下状态 s 的状态价值函数（State-Value Function） $v_{\pi}(s)$</p><script type="math/tex; mode=display">v_{\pi}(s) = E_{\pi}[G_t|S_t = s]</script><p>状态 s 的最优状态价值函数（The Optimal State-Value Function）v~∗~(s) </p><script type="math/tex; mode=display">v_{*}(s) = \max_{\pi}v_{\pi}(s)</script><h2 id="动作价值函数-amp-最优动作价值函数"><a href="#动作价值函数-amp-最优动作价值函数" class="headerlink" title="动作价值函数 &amp; 最优动作价值函数"></a>动作价值函数 &amp; 最优动作价值函数</h2><p>给定策略 π，状态 s，采取动作 a 的动作价值函数（Action-Value Function）q~π~(s,a)</p><script type="math/tex; mode=display">q_{\pi}(s, a) = E_{\pi}[G_t|S_t = s, A_t = a]</script><p>状态 s 下采取动作 a 的最优动作价值函数（The Optimal Action-Value Function）q∗(s,a):</p><script type="math/tex; mode=display">q_{*}(s, a) = \max_{\pi}q_{\pi}(s, a)</script><h2 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h2><p>如果策略 π 优于策略 π′：</p><script type="math/tex; mode=display">\pi \ge \pi^{'} \text{ if } v_{\pi}(s) \ge v_{\pi^{'}}(s), \forall{s}</script><p>最优策略 v∗ 满足：</p><ul><li>v∗≥π,∀π</li><li>v~π∗~(s)=v~∗~(s) </li><li>q~π∗~(s,a)=q~∗~(s,a) </li></ul><p>如何找到最优策略？</p><p>可以通过最大化 q~∗~(s,a)  来找到最优策略：</p><script type="math/tex; mode=display">v_{*}(a|s) =\begin{cases}& 1 \text{ if } a=\arg\max_{a \in A}q_{*}(s,a)\\& 0 \text{ otherwise }\end{cases}</script><p><strong>对于MDP而言总存在一个确定的最优策略，而且一旦我们获得了q~∗~(s,a) ，我们就能立即找到最优策略。</strong></p><h2 id="Bellman-Expectation-Equation-for-MDPs"><a href="#Bellman-Expectation-Equation-for-MDPs" class="headerlink" title="Bellman Expectation Equation for MDPs"></a>Bellman Expectation Equation for MDPs</h2><p>我们先看下状态价值函数 v^π^。</p><p>状态 s 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180345098-1901972119.png" alt=""></p><p>根据上图可得：</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A}\pi(a|s)q_{\pi}(s, a)  \qquad (1)</script><p>再来看动作价值函数 q~π~(s,a) </p><p>状态 s，动作 a 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180402049-1747500206.png" alt=""></p><p>因此可得：</p><script type="math/tex; mode=display">q_{\pi}(s,a)=R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{\pi}(s')  \qquad (2)</script><p>进一步细分 backup tree 再来看 v^π^  与 q~π~(s,a)  对应的表示形式。</p><p>细分状态 ss 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180411412-1063042128.png" alt=""></p><p>将式子(2)代入式子(1)可以进一步得到 vπ(s)vπ(s) 的贝尔曼期望方程：</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A} \pi(a | s) \Bigl( R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{\pi}(s') \Bigr)  \qquad (3)</script><p>细分状态 ss，动作 aa 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180421183-498067530.png" alt=""></p><p>将式子(1)代入式子(2)可以得到 qπ(s,a)的贝尔曼期望方程：</p><script type="math/tex; mode=display">q_{\pi}(s,a)=R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a \Bigl(\sum_{a' \in A}\pi(a'|s')q_{\pi}(s', a') \Bigr)  \qquad (4)</script><h2 id="Bellman-Optimality-Equation-for-MDPs"><a href="#Bellman-Optimality-Equation-for-MDPs" class="headerlink" title="Bellman Optimality Equation for MDPs"></a>Bellman Optimality Equation for MDPs</h2><p>同样我们先看 v~∗~(s)：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180430574-1927151238.png" alt=""></p><p>对应可以写出公式：</p><script type="math/tex; mode=display">v_{*}(s) = \max_{a}q_{*}(s, a)   \qquad (5)</script><p> 再来看q~∗~(s,a)：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180436870-598952431.png" alt=""></p><p>对应公式为：</p><script type="math/tex; mode=display">q_{*}(s, a) =  R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{*}(s') \qquad (6)</script><p>同样的套路获取 v∗(s) 对应的 backup tree 以及贝尔曼最优方程：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180450776-607271585.png" alt=""></p><p>贝尔曼最优方程：</p><script type="math/tex; mode=display">v_{*}(s) = \max_{a} \Bigl( R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{*}(s') \Bigr) \qquad (7)</script><p>q∗(s,a)  对应的 backup tree 以及贝尔曼最优方程：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180500521-1105213902.png" alt=""></p><p>对应的贝尔曼最优方程：</p><script type="math/tex; mode=display">R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a\max_{a}q_{*}(s, a) \qquad (8)</script><h3 id="贝尔曼最优方程特点"><a href="#贝尔曼最优方程特点" class="headerlink" title="贝尔曼最优方程特点"></a>贝尔曼最优方程特点</h3><ul><li>非线性（non-linear）</li><li>通常情况下没有解析解（no closed form solution）</li></ul><h3 id="贝尔曼最优方程解法"><a href="#贝尔曼最优方程解法" class="headerlink" title="贝尔曼最优方程解法"></a>贝尔曼最优方程解法</h3><ul><li>Value Iteration</li><li>Policy Iteration</li><li>Sarsa</li><li>Q-Learning</li></ul><h2 id="MDPs的相关扩展问题"><a href="#MDPs的相关扩展问题" class="headerlink" title="MDPs的相关扩展问题"></a><del>MDPs的相关扩展问题</del></h2><ul><li><del>无限MDPs/连续MDPs</del></li><li><del>部分可观测的MDPs</del></li><li><del>Reward无折扣因子形式的MDPs/平均Reward形式的MDPs</del></li></ul>]]></content>
    
    
    <summary type="html">马尔可夫决策过程</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>WSL踩坑</title>
    <link href="https://changqingaas.github.io/%E8%B8%A9%E5%9D%91/%E8%B8%A9%E5%9D%91/wsl%E8%B8%A9%E5%9D%91/"/>
    <id>https://changqingaas.github.io/%E8%B8%A9%E5%9D%91/%E8%B8%A9%E5%9D%91/wsl%E8%B8%A9%E5%9D%91/</id>
    <published>2021-10-03T15:30:16.000Z</published>
    <updated>2022-01-17T01:14:02.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL踩坑"><a href="#WSL踩坑" class="headerlink" title="WSL踩坑"></a>WSL踩坑</h1><p>大二上学期期末，稀里糊涂装了wsl, 一直用到现在。<br>本来是打算，和OS相关，那就装到C盘把。<br>这么一大意，在大三上装东西的时候出了不少问题。（当时没仔细装，而且也不懂）<br>这次为了装temu的交叉编译环境，装了不少东西，直接把C盘干到2G了，这么下去肯定不行。（Ubuntu20。04的主要文件夹就有至少15G了）<br>于是，我就上网搜，发现别人早就整好了vhdx(一个叫虚拟硬盘的东西，我当时没有做，现在做也来不及了），<br>所以别人的限制硬盘占用的方法，转移到别的位置的办法，我都没办法用了。</p><p>打算卸载重装到D盘。用这个帖子解决问题了：<a href="https://blog.csdn.net/LaughingMei/article/details/109736965">https://blog.csdn.net/LaughingMei/article/details/109736965</a> </p><p>卸载完C盘有16G了。</p><p>比较脑瘫，当时看到的有两种方式，第一种要vhdx，第二种不用</p>]]></content>
    
    
    <summary type="html">稀里糊涂</summary>
    
    
    
    <category term="踩坑" scheme="https://changqingaas.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑" scheme="https://changqingaas.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101</title>
    <link href="https://changqingaas.github.io/CG/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/CG/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-13T11:50:19.000Z</published>
    <updated>2022-02-04T05:51:43.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lecture1-intro"><a href="#Lecture1-intro" class="headerlink" title="Lecture1:  intro"></a>Lecture1:  intro</h2><h3 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h3><p>使用计算机synthesize(合成)  manipulate（操作) 可视化信息</p><h3 id="why-study-computer-graphics"><a href="#why-study-computer-graphics" class="headerlink" title="why study computer graphics?"></a>why study computer graphics?</h3><ul><li>Application<ul><li>video games 电子游戏</li><li>animations 动画</li><li>visualization 可视化</li><li>virtual reality</li><li>augmented reality 增强现实</li><li>digital illustration 数码插画</li><li>simulation 模拟</li><li>graphical user interfaces 图形用户界面</li><li>typography  排版</li></ul></li><li>technical chanllenges </li></ul><h3 id="Course-topics"><a href="#Course-topics" class="headerlink" title="Course topics"></a>Course topics</h3><ul><li><p>Rasterization  光栅化</p><ul><li><p>project geometry primitives (3D triangles / polygons) onto the screen</p><p>将几何图形（3D三角形 / 多边形）投射到屏幕上</p></li><li><p>break projected primitives into fragments (pixels)</p><p>将投影图元分解到片段(像素)</p></li><li><p>gold standard in video games (real-time applications)</p></li></ul></li><li><p>curves and meshes 曲线和栅格</p><ul><li>怎样represent geometry in CG</li></ul></li><li><p>ray tracing 光线追踪</p><ul><li>shoot rays from camera though each pixel<ul><li>calculate intersection and shading 交叉点和阴影</li><li>continue to bounce the rays till they hit light sources</li></ul></li><li>gold standard in animations / movies (offline离线 application)</li></ul></li><li><p>animation simulation</p><ul><li>key frame animation 关键帧动画</li><li>mass-spring system 弹簧振子系统</li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="differences-between-cg-and-cv"><a href="#differences-between-cg-and-cv" class="headerlink" title="differences between cg and cv"></a>differences between cg and cv</h3><p>No clear boundaries</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231736.png" alt="image-20210913210044004"></p><h2 id="Lecture2-review-of-linear-algebra"><a href="#Lecture2-review-of-linear-algebra" class="headerlink" title="Lecture2:  review of linear algebra"></a>Lecture2:  review of linear algebra</h2><h3 id="Graphics’-dependcies"><a href="#Graphics’-dependcies" class="headerlink" title="Graphics’ dependcies"></a>Graphics’ dependcies</h3><ul><li>basic mathematics<ul><li>Linear algebra 线性代数<ul><li>mostly dependent on linear algebra</li><li>vectors（dot products点乘,cross products叉乘<ul><li>An operation like translating or rotating objects  can be matrix-vector multiplication</li></ul></li><li>matrices 矩阵（复数</li></ul></li><li>calculus 微积分</li><li>statistics 统计</li></ul></li><li>basic physics <ul><li>Optics, 光学的</li><li>Mechanics  机械的</li></ul></li><li>misc 杂项<ul><li>Numerical analysis  数值分析</li><li>signal processing 信号处理</li><li>aesthetics 审美</li></ul></li></ul><h3 id="vectors"><a href="#vectors" class="headerlink" title="vectors"></a>vectors</h3><p>noting: 只记了part</p><ul><li><p>unit vector </p><ul><li>单位向量，</li><li>用来代表方向</li></ul></li><li><p>dot  product in graphics</p><ul><li><p>$\vec{a}\cdot\vec{b} = |\vec{a}|\cdot|\vec{b}|cos\theta$ </p></li><li><p>Find angle between two vectors  (e.g. cosine of angle between light source 光源 and surface表面)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231823.png" alt="image-20210913215253056"></p></li><li><p>Finding <strong>projection</strong> of one vector on another</p><ul><li><p>measure how close two directions are</p></li><li><p>decompose分解 a vector </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231937.png" alt="image-20210913215715680" style="zoom:50%;" /></p></li><li><p>determine forward or backward</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231938.png" alt="image-20210913215758162" style="zoom: 50%;" /></p></li></ul></li></ul></li><li><p>cross product in graphics</p><p>​    <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231939.png" alt="image-20210913220439863" style="zoom: 50%;" /></p><ul><li>Direction determined by right-hand rule</li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231940.png" alt="image-20210913220739158"></p><ul><li>Useful in constructing coordinate systems (later)</li><li>Determine left / right</li><li>Determine inside / outside</li></ul></li><li>Orthonormal bases and coordinate frames  正交基底和坐标系<ul><li>Critical issue is transforming between these systems/ bases</li></ul></li></ul><h3 id="matrices"><a href="#matrices" class="headerlink" title="matrices"></a>matrices</h3><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231941.png" alt="image-20210913223344462" style="zoom:50%;" /></p><ul><li>$(AB)^{T} = B^{T}A^{T}$</li><li>$AA^{-1} = A^{-1}A = I$</li><li>$(AB)^{-1} = B^{-1}A^{-1}$</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231942.png" alt="image-20210913223854494" style="zoom: 50%;" /></p><p>In Graphics, pervasively used to represent transformations</p><ul><li>translation, rotation,shear剪切,scale缩放</li></ul><h2 id="Lecture-3-Transformation"><a href="#Lecture-3-Transformation" class="headerlink" title="Lecture 3: Transformation"></a>Lecture 3: Transformation</h2><h3 id="why-study-transformation"><a href="#why-study-transformation" class="headerlink" title="why study transformation"></a>why study transformation</h3><ul><li>modeling<ul><li>translation</li><li>rotation</li><li>scaling</li></ul></li><li>viewing<ul><li>3D (projection)</li><li>2D (projection)</li></ul></li></ul><h3 id="2D-transformations"><a href="#2D-transformations" class="headerlink" title="2D transformations:"></a>2D transformations:</h3><ul><li><p>representing transformations using matrices</p></li><li><p>rotation</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914135044.png" alt="image-20210914135044036" style="zoom:50%;" /></p><ul><li>$R_{\theta} = \begin{bmatrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{bmatrix} $</li><li>$R_{-\theta} = \begin{bmatrix} cos\theta &amp; sin\theta \\ -sin\theta &amp; cos\theta \end{bmatrix} = R_{\theta}^{T} = R_{\theta}^{-1}(by \quad definition) $</li><li>正交矩阵： A·A^T^ = E</li><li>默认绕原点旋转</li><li>默认逆时针旋转</li></ul></li><li><p>scale matrix</p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} s_{x} &amp; 0 \\ 0 &amp; s_{y} \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</p></li><li><p>reflection matrix 反射（镜像）矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914124142.png" alt="image-20210914124142211" style="zoom: 50%;" /></p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} -1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</p></li><li><p>shear matrix</p><p>​    <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914134639.png" alt="image-20210914134632720" style="zoom: 50%;" /></p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} -1 &amp; a \\ 0 &amp; 1\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</p><ul><li>Hints:<ul><li>horizontal shift is 0 at y = 0</li><li>horizontal shift is a at y = 1</li><li>vertical shift is always</li></ul></li></ul></li><li><p>Linear transforms </p><ul><li>线性变换：可以用一个矩阵表示的变换</li><li>x’ = ax + by</li><li>y’ = cx + dy</li><li>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</li></ul></li></ul><h3 id="Homogeneous-coordinates-齐次坐标"><a href="#Homogeneous-coordinates-齐次坐标" class="headerlink" title="Homogeneous coordinates 齐次坐标"></a>Homogeneous coordinates 齐次坐标</h3><ul><li><p>Why homogeneous coordinates  </p><p>for example:  translation</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914135553.png" alt="image-20210914135548707" style="zoom:50%;" /></p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix} + \begin{bmatrix} t_{x} \\ t_{y} \end{bmatrix} $</p><ul><li><p>so, translation is not linear transform!</p></li><li><p>因为平移变换不能直接用一个矩阵表示，必须加一个向量；  </p></li><li><p>add a third coordinates</p><p>引入齐次坐标可以解决问题，让平移也能只用一个矩阵表示</p></li><li><p>2D point = (x,y,1)^T^</p></li><li><p>2D vector = (x,y,0)^T^</p></li><li><p>向量 + 向量，结果齐次项是0，还是向量</p></li><li><p>点 - 点，得到的是一个向量，齐次项也变成0 </p></li><li><p>点 + 向量，表示一个点的移动，结果 还是点 ！</p></li><li><p>点 + 点是什么呢？齐次项变成2。将所有项除以2，齐次项又变为1 。所以点 + 点结果实际上是两个点的中点。</p></li></ul></li><li><p>Affine  transformation 仿射变换</p><ul><li><p>仿射变换：先线性变换再加上一次平移</p></li><li><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \\ 1 \end{bmatrix} = \begin{bmatrix} a &amp; b &amp; t_{x}\\ c &amp; d  &amp; t_{y}  \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\  y \\ 1 \end{bmatrix} $</p></li><li><p>scale </p><p>$ S(s_{x}, s_{y}) = \begin{bmatrix} s_{x} &amp; 0 &amp; 0 \\ 0 &amp; s_{y}  &amp; 0  \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p></li><li><p>rotation </p><p>$ R(\alpha) = \begin{bmatrix} cos\alpha &amp; -sin\alpha &amp; 0 \\ sin\alpha &amp; cos\alpha  &amp; 0  \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p></li><li><p>translation</p><p>$ T(t_{x}, t_{y}) = \begin{bmatrix} 1 &amp; 0 &amp; t_{x} \\ 0 &amp; 1  &amp; t_{y} \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p></li></ul></li><li><p>transform ordering matters</p><ul><li>matrix multiplication is not commutative 可交换的</li></ul></li></ul><h3 id="composing-transforms"><a href="#composing-transforms" class="headerlink" title="composing transforms"></a>composing transforms</h3><ul><li><p>decomposing complex transforms</p><ul><li>translate center to origin</li><li>rotate</li><li>translate back</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914142248.png" alt="image-20210914142248083"></p><p>which means $T(c) · R(\alpha) · T(-c)$</p><ul><li><p>分解：变换可以分解，注意先后顺序是从右到左</p></li><li><p>2D变换矩阵（缩放，旋转，平移变换）</p></li></ul></li><li></li></ul><h2 id="Lecture-4：-Transformation-Cont"><a href="#Lecture-4：-Transformation-Cont" class="headerlink" title="Lecture 4： Transformation Cont"></a>Lecture 4： Transformation Cont</h2><h3 id="3D-transformations"><a href="#3D-transformations" class="headerlink" title="3D transformations"></a>3D transformations</h3><ul><li><p>3D point = (x,y,z,1)^T^</p></li><li><p>3D vector = (x,y,z,0)^T^</p></li><li><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \\ z_{‘} \\ 1 \end{bmatrix} = \begin{bmatrix} a &amp; b &amp; c &amp; t_{x}\\ d &amp; e &amp; f &amp; t_{y}\\g &amp; h &amp; i &amp; t_{z}  \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\ y \\z \\ 1 \end{bmatrix} $</p></li><li><p>三维空间中的齐次变换，最后一行和二维变换类似，是0 0 0 1，平移还是在矩阵最后一列</p></li><li><p>对于仿射变换，是先应用线性变换，再加上平移</p></li><li><p>what is order?</p><ul><li><p>linear transform first or translation first?</p></li><li><p>scale </p><p> $S(s_{x}, s_{y},s_{z}) = \begin{bmatrix} s_{x} &amp; 0 &amp; 0 &amp; 0\\ 0 &amp;  s_{y} &amp; 0 &amp; 0\\0 &amp; 0 &amp;  s_{z} &amp; 0  \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}  $</p></li><li><p>translation</p><p> $T(t_{x}, t_{y}, t_{z}) = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_{x}\\ 0 &amp;  1 &amp; 0 &amp; t_{y} \\0 &amp; 0 &amp;  1 &amp; t_{z}  \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}  $</p></li><li><p>rolation</p><ul><li>rolation around x-, y-,or  z-axis</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914203113.png" alt="image-20210914203043532" style="zoom:50%;" /></p><ul><li>绕哪个轴旋转，哪个坐标就不变</li><li><p>不过𝑅𝑦矩阵稍微不同，其他两个都是右上角𝑠𝑖𝑛是负的，只有他是左下角𝑠𝑖𝑛是负的 因为𝑥叉乘𝑦得到𝑧，𝑧叉乘𝑦得到𝑥，但是𝑧叉乘𝑥得到𝑦（而不是𝑥叉乘𝑧），所以是反的</p></li><li><p>$R_{xyz}(\alpha, \beta, \gamma) = R_{x}(\alpha)R_{y}(\beta)R_{z}(\gamma)$</p></li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914220209.png" alt="image-20210914220208915"></p></li></ul></li></ul><h3 id="Viewing-观测-transformation"><a href="#Viewing-观测-transformation" class="headerlink" title="Viewing (观测) transformation"></a>Viewing (观测) transformation</h3><ul><li><p>View (视图) / Camera transformation  </p><ul><li>Think about how to take a photo <ul><li>Find a good place and arrange people (model transformation) </li><li>Find a good “angle” to put the camera (view transformation)</li><li>Cheese! (projection transformation)<ul><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914224154.png" alt="image-20210914224154439"></li><li>定义相机</li><li>位置</li><li>往哪看</li><li>向上方向</li><li>现实中是移动相机，变换景物</li><li>图形学中，相机不动，永远在原点</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914223830.png" alt="image-20210914223829896" style="zoom:50%;" /></li><li>经过变换，把相机的位置移动到原点，同时保持看到的景物不变</li></ul></li></ul></li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914225726.png" alt="image-20210914225726865"></p></li><li><p>这个从“歪”的坐标轴旋转回正的坐标轴，不太好写。 但是这个变换的逆过程，即：从正的坐标轴旋转到“歪”的坐标轴，是好写的， 于是我们先写从“正”坐标轴变换到“歪”坐标轴的变换矩阵，再求其逆矩阵，就可以得到待求的变换矩阵。 又因为旋转矩阵是正交矩阵，所以他的逆矩阵就只需要转置一下就可以得到了！ 注意，不但相机要做这个变换，其他物体也要做这个变换，因为我们想让相机看到的景物相对不变。 （以上部分个人认为非常巧妙和关键！）</p></li><li><p>Projection (投影) transformation</p><ul><li><p>3D to 2D</p></li><li><p>Orthographic (正交) projection  </p><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914230822.png" alt="image-20210914230821994"></p><ul><li><em>没有近大远小</em></li><li>平行投影<ul><li>首先定义空间中一个立方体，将其translate，使其中心在原点，再scale成标准立方体（边长为2</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915120758.png" alt="image-20210915120758604"></li><li>再次提醒，注意𝑧轴是近大远小 OpenGL等API是反过来的</li></ul></li><li><p>Perspective (透视) projection</p><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914230840.png" alt="image-20210914230840011"></p><ul><li><p>更像人眼看到的场景</p></li><li><p>Most common in Computer Graphics, art, visual system </p></li><li><p>Further objects are smaller </p></li><li><p>Parallel lines not parallel; converge to single point</p></li><li>Recall: property of homogeneous coordinates<ul><li>(x, y, z, 1), (kx, ky, kz, k != 0), (xz, yz, z2, z != 0) all represent  the same point (x, y, z) in 3D </li><li>e.g. (1, 0, 0, 1) and (2, 0, 0, 2) both represent (1, 0, 0)</li></ul></li><li>how to do perspective projection<ul><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915122816.png" alt="image-20210915122816233"></li><li>先将frustum远平面，挤压成和近平面一样大（从左图变成右图）</li><li>再做正交投影，投影到近平面</li><li>上述操作过程中几点假设：<ul><li>1）近平面保持不变 </li><li>2）z值保持不变，只是向内收缩</li></ul></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915122907.png" alt="image-20210915122907760"></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915122956.png" alt="image-20210915122956833"></li><li>挤压这一步怎么做？ 上图是从侧面观察frustum 用相似三角形知识可以得到新坐标的表达式，但是第三个分量目前还不知道（这里利用之前讲的那个性质： 齐次坐标，如果我们对点的坐标所有分量同时乘以k，他表示的还是原来那个点！  </li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123123.png" alt="image-20210915123123207"></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123140.png" alt="image-20210915123140120"></li><li>如何求解第三行<ul><li>任何近平面上的点不会改变（也就是对于任意的(𝑥, 𝑦, 𝑛, 1)，经过这个矩阵变换后，点的位置仍然不变）</li><li>任何远平面上的点，𝑧值不会改变</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123415.png" alt="image-20210915123415483"></li><li>点(𝑥, 𝑦, 𝑧, 1)是可以通过矩阵变换得到(𝑛𝑥, 𝑛𝑦, 𝑢𝑛𝑘𝑛𝑤𝑜𝑛, 𝑧)向量的。 根据上文提到的性质（1），经过这个变换，点实际没有改变 而同时，(𝑥, 𝑦, 𝑧, 1)本身可以写成(𝑥, 𝑦, 𝑛, 1)（为什么把𝑧替换成𝑛？因为近平面的𝑧坐标就是都是𝑛，所以可以做这个替换。）然后同时乘以𝑛， 变成(𝑛𝑥, 𝑛𝑦, 𝑛 ଶ , 𝑛) 经过上面两个推导，可以看出，第三行前两个数一定是0 因为𝑛 ଶ这个分量和𝑥和𝑦都毫无关系，因此前两个数必定是0 这样，我们就解出了第三行前两个数，都是0 接下来求A和B</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123500.png" alt="image-20210915123459854"></li><li>远平面上有一个特殊点，(0, 0, 𝑓)经过变换挤压仍然不变 所以(0, 0, 𝑓)经过变换仍然是(0, 0, 𝑓) 根据近平面我们得到$An + B = n^{2}$,根据远平面的中心点我们得到$Af + B = f^{2}</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123625.png" alt="image-20210915123625508"></li><li>这样我们就能解出A和B了， 这样终于把从透视投影挤压成正交投影的矩阵，解出来了</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123651.png" alt="image-20210915123651566"></li></ul></li></ul></li><li><p>思考题</p><ul><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123710.png" alt="image-20210915123709902"></li></ul></li></ul></li></ul><h2 id="Lecture05-Rasterization-1-Triangles"><a href="#Lecture05-Rasterization-1-Triangles" class="headerlink" title="Lecture05: Rasterization 1(Triangles)"></a>Lecture05: Rasterization 1(Triangles)</h2><h3 id="Finishing-up-Viewing"><a href="#Finishing-up-Viewing" class="headerlink" title="Finishing up Viewing"></a>Finishing up Viewing</h3><ul><li>Viewport(视口) transformation</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005190732.png" alt="image-20211005190731847" style="zoom: 50%;" /></p><p>上节课把透视投影转化成正交投影 这里引入另外一个概念 Field of View，表示你能看到的角度的范围 注意看上图中红色线的夹角，就是垂直可视角度，他越大，可视角度越大 同理还有水平可视角度</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005190927.png" alt="image-20211005190926969"></p><p>MVP这三个变换之后，所有东西都会停留在一个1，1，1的位于原点的标准立方体中 下一步就要把这立方体画在屏幕上</p><h3 id="Rasterization（光栅化，即把东西花在屏幕上"><a href="#Rasterization（光栅化，即把东西花在屏幕上" class="headerlink" title="Rasterization（光栅化，即把东西花在屏幕上"></a>Rasterization（光栅化，即把东西花在屏幕上</h3><h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><ul><li><p>像素是最小的屏幕单位</p></li><li><p>每个像素有不同的颜色</p></li><li><p>屏幕空间：就是给屏幕定义一个坐标系 比如，可以定义左下角是原点。 </p></li><li><p>实际上像素的中心是(𝑥 + 0.5, 𝑦 + 0.5)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191523.png" alt="image-20211005191523440"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191557.png" alt="image-20211005191556944"></p><p>我们要做的就是把标准立方体空间映射到屏幕这个二维世界中去 𝑧暂时不管 其他两个坐标是[−1, 1] ଶ转换到 [0, 𝑤𝑖𝑑𝑡ℎ] ∗ [0, ℎ𝑒𝑖𝑔ℎ𝑡] 使用上面这个矩阵做变换</p></li></ul><h4 id="Rasterizing-a-triangle"><a href="#Rasterizing-a-triangle" class="headerlink" title="Rasterizing  a triangle"></a>Rasterizing  a triangle</h4><ul><li><p>三角形可以拼接在三维空间中的面，或者二维空间中复杂的图形 </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191718.png" alt="image-20211005191718242"></p></li><li><p>三角形内部一定是平面的 </p></li><li>给三角形顶点定义不同属性，可以在三角形内部进行插值</li><li>通过采样的方式，来画出三角形<ul><li>采样就是把函数离散化的过程</li><li>可以对时间，面积，方向，体积… 进行采样</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191941.png" alt="image-20211005191941468"></p><p>定义二值函数：</p><script type="math/tex; mode=display">inside(tri, x,y) = \left\{\begin{array}{rcl}1  &      & {Point(x,y) \ in  \ triangle \ t}\\0  &      & {otherwise}\\\end{array}\right.</script><ul><li><p>这里我们要做的就是给定一个三角形，判断像素中心是否在三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005192820.png" alt="image-20211005192820679"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005192920.png" alt="image-20211005192920137"></p><p>那么，如何判断一个点是否在三角形内？用叉乘！！ 比如对上图，判断Q是否在三角形内部 首先$𝑃1𝑃2 \  X \ 𝑃1𝑄 $，将会得到一个z为正数的向量，也就是结果向量朝向屏幕外的，利 用右手定则，可以得知𝑄在𝑃1𝑃2的左侧（因为如果在右侧，那么结果将会是向量𝑧为负 数，那么结果向量就朝向屏幕内部） 类似的𝑃2𝑃0 𝑋 𝑃2𝑄，得到𝑄在右侧，不对劲！ 𝑃0𝑃1 𝑋 𝑃0𝑄，得到𝑄在左侧</p><p>注意，向量按照一定的顺序去判断，比如我们上面是按照P1, P2, P0去判断的</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005193137.png" alt="image-20211005193137111"></p><p>检查屏幕所有的像素太花时间！ 可以只检查蓝色的包围盒（Bounding box）部分</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005193213.png" alt="image-20211005193213667"></p><p>也可以每一行设置一个包围盒，进一步减小包围盒 很适用于那种三角形很小，但是包围盒很大的（窄长三角形</p><h2 id="some-words"><a href="#some-words" class="headerlink" title="some words"></a>some words</h2><p>syllabus  教学大纲</p><p>cube  立方体</p><p>canonical 标准的</p><p>aspect ratio 横纵比</p><p>requirements 要求</p><p>submission 提交</p><p>slides 幻灯片</p><p>Bulletin Board System BBS</p><p>Semantic Segmentation 语义切割</p><p>code skeletons 代码框架</p><p>IDE: Integrated Development Environment</p><p>parse 解析</p><p>Academic integrity 学术诚信</p><p>Valentine’s Day 情人节</p><p>brutal 粗暴的</p><p>coordinates 坐标</p><p> Parallelogram law 平行四边形法则</p><p>Triangle law 三角法则</p><p>orthogonal 正交的</p><p> scalar 标量</p><p>decompose 分解</p><p>haunt 出没</p><p>pervasively 普遍地</p><p>multiplication 乘法</p><p>trivial 琐碎的</p>]]></content>
    
    
    <summary type="html">GAMES101:现代计算机图形学入门</summary>
    
    
    
    <category term="CG" scheme="https://changqingaas.github.io/categories/CG/"/>
    
    
    <category term="CG" scheme="https://changqingaas.github.io/tags/CG/"/>
    
  </entry>
  
  <entry>
    <title>墨子平台训练教程</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E5%A2%A8%E5%AD%90%E5%B9%B3%E5%8F%B0%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E5%A2%A8%E5%AD%90%E5%B9%B3%E5%8F%B0%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/</id>
    <published>2021-09-03T15:00:33.000Z</published>
    <updated>2021-09-04T11:34:06.947Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍一下windows版本墨子平台的使用流程：</p><ol><li><h2 id="进入华戍防务-官网-hs-defense-com-下载软件"><a href="#进入华戍防务-官网-hs-defense-com-下载软件" class="headerlink" title="进入华戍防务 官网(hs-defense.com)下载软件"></a>进入<a href="http://www.hs-defense.com/col.jsp?id=105">华戍防务 官网(hs-defense.com)</a>下载软件</h2></li></ol><p>我下载的是<code>墨子·联合作战推演系统（个人版）</code> </p><p><code>墨子·AI开发包</code>主要是一些开发会用到的代码和文档。代码也可以在gitee.com上找到：<a href="https://gitee.com/hs-defense/moziai">moziai: 墨子AI开发包及“子牙”智能体开源代码  </a></p><p><code>竞赛客户端(互联网)</code> 主要是用来军事推演比赛的，与强化学习训练关系不大，可以不下载。</p><p><code>墨子·AI版（Linux)</code> 因为一开始没办法下载，后面断断续续也没有弄出什么效果</p><p>注：</p><ul><li><p>文件采用ftp协议下载，下载链接格式为：ftp: ip/port/文件夹s/文件</p></li><li><p>由于部分浏览器不支持，推荐使用QQ浏览器下载</p></li><li><p>一般点击下载按钮后，会默认让迅雷接管下载</p></li></ul><ol><li><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>​    根据安装手册安装该软件，基本上按照手册进行就可以了</p></li><li><h2 id="启动该软件"><a href="#启动该软件" class="headerlink" title="启动该软件"></a>启动该软件</h2><ol><li>进入安装目录下的\MoziData，右键点击<code>mysql.bat</code>，以管理员身份运行它，随后退出</li><li>进入安装目录下的\MoziServer，运行MoziServer.exe，尽量关掉杀毒软件，最好以管理员身份运行<ul><li>这里大概会遇到一个问题：<code>临时许可码过期，请联系华戍防务重新授权</code>，具体解决方案略</li><li>我在数据库方面也出过问题，不过忘了具体细节了</li></ul></li></ol></li><li><h2 id="运行代码，进行仿真训练"><a href="#运行代码，进行仿真训练" class="headerlink" title="运行代码，进行仿真训练"></a>运行代码，进行仿真训练</h2><ol><li><p>获取代码，在IDE打开代码</p></li><li><p>加载代码所需的scen想定文件</p><ul><li>进入墨子平台，可以在想定一栏下找到<code>加载想定</code>的选项，想定文件是从<code>安装路径\MoziServer\bin\Scenarios\</code>获取的，因此需要把代码包里的scen文件放到这里。</li><li>加载想定文件，选择推演方</li><li>随后可以看到墨子平台上有了具体的想定环境</li><li>如果要更改想定文件，改完之后，需要保存，再重新加载<ul><li>因为训练的每个回合都会刷新环境，如果不保存更改到新scen文件，那么这个更改只能用于一个回合</li></ul></li></ul></li><li><p>运行main.py代码即可看到效果</p><ul><li><p>注：</p><ul><li><p>这里可能需要指定一下 墨子平台的路径，可以执行代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os.environ[&#39;MOZIPATH&#39;] &#x3D; &#39;D:\\MoZiSystem\\Mozi\\MoziServer\\bin&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以在<code>编辑系统环境变量</code>中添加路径</p></li></ul></li></ul></li></ol></li></ol><p>注：Linux版本的墨子平台还在折腾，因为虚拟机比较卡，服务器上又没办法弄出显示界面，还折腾了一堆配置，最近还没弄，如果有结果了，会在这里更新的</p>]]></content>
    
    
    <summary type="html">墨子推演平台强化学习训练教程，主要是写给队友用的</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
    <category term="机器学习" scheme="https://changqingaas.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>收藏的文章</title>
    <link href="https://changqingaas.github.io/MARL/others/%E6%94%B6%E8%97%8F%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://changqingaas.github.io/MARL/others/%E6%94%B6%E8%97%8F%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2021-09-01T14:00:33.000Z</published>
    <updated>2022-02-04T05:54:00.386Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.justlovesmile.top/posts/bfa4054.html">深度学习 | 《深度学习入门之PyTorch》阅读笔记 | Justlovesmile’s BLOG</a></p><p>注： 这本书的github代码已经4年没更新了，只适合速览一下，做个overview, 并不适合手敲学习</p><p><a href="https://blog.justlovesmile.top/posts/43678.html">深度学习 | “花书”，Deep Learning笔记 | Justlovesmile’s BLOG</a></p><p> 注：偏数学</p><p><a href="https://blog.justlovesmile.top/posts/16050.html">大学课程 | 《算法分析与设计》笔记 | Justlovesmile’s BLOG</a></p><p><a href="https://blog.justlovesmile.top/posts/41347.html">大学课程 | 数据库基础 | Justlovesmile’s BLOG</a></p>]]></content>
    
    
    <summary type="html">放在本地的收藏夹不方便分享，所以就放在这里了</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>什么是node.js</title>
    <link href="https://changqingaas.github.io/js/js/%E4%BB%80%E4%B9%88%E6%98%AFnode.js/"/>
    <id>https://changqingaas.github.io/js/js/%E4%BB%80%E4%B9%88%E6%98%AFnode.js/</id>
    <published>2021-08-31T08:56:30.000Z</published>
    <updated>2021-08-31T01:09:23.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js简介"><a href="#node-js简介" class="headerlink" title="node.js简介"></a>node.js简介</h1><ul><li><p>node.js是运行在服务端的JavaScript,是一个事件驱动I\O服务端JavaScript环境</p></li><li><p>查看版本</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>node版本管理工具nvm</p></li></ul><h1 id="Node-js应用"><a href="#Node-js应用" class="headerlink" title="Node.js应用"></a>Node.js应用</h1><ul><li>Node.js应用的构成：<ul><li>引入required模块</li><li>创建服务器</li><li>接收请求与相应请求</li></ul></li></ul><h2 id="创建Node-js应用"><a href="#创建Node-js应用" class="headerlink" title="创建Node.js应用"></a>创建Node.js应用</h2><ul><li><p>步骤一：引入required模块</p><ul><li>使用require指令来载入http模块，并将实例化的HTTP复制给变量http，实例如下：  <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>步骤二： 创建服务器</p><ul><li>创建一个server.js的文件：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">,</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span>response</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 发送http头部</span>    <span class="token comment">//HTTP状态值：200：OK</span>    <span class="token comment">//内容类型：text/plain</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token string">'Content-Type'</span><span class="token operator">:</span>'text<span class="token operator">/</span>plain<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//发送响应数据 “Hello World"</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//终端打印如下信息</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server running at http://127.0.0.1:8888/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用node命令执行以上代码</p>  <pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">node server.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>访问<a href="http://127.0.0.1:8888">http://127.0.0.1:8888</a></p></li></ul></li></ul><h2 id="npm使用介绍"><a href="#npm使用介绍" class="headerlink" title="npm使用介绍"></a>npm使用介绍</h2><ul><li><p>查看npm版本</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>升级版本</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm install npm -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装包</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm install &lt;Module Name&gt; # 本地安装npm install &lt;Module Name&gt; -g # 全局安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看安装信息</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm list -g # 查看全局安装的模块npm ist &lt;Module Name&gt;# 查看某个模块的版本号npm ls# 查看当前目录下的包信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>卸载模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm un &lt;Module Name&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>更新模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm update &lt;Module Name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>搜索模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm search &lt;Module Name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$npm init# 会自动生成package.json$npm adduser # 在npm资源库中注册用户Username:XXXXPassword:XXXXEmail:XXXX$npm publish# 发布模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h2><ul><li><p>REPL(Read Eval Print Loop:交互式解释器)，Node自带交互式解释器，可以执行读取,执行,打印,循环等任务</p></li><li><p>在Node的REPL中可以执行：</p><ul><li>简单的表达式计算</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$node&gt;1 + 45&gt; 5 &#x2F; 22.5&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用变量</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node&gt; 1+45&gt; 5&#x2F;22.5&gt; x&#x3D;1010&gt; var y&#x3D;10undefined&gt; x+y20&gt; console.log(&quot;Hello World!&quot;)Hello World!undefined&gt;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>多行表达式</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node&gt; do &#123;... x++;... console.log(&quot;x:&quot;+x);... &#125;while(x&lt;5);x:1x:2x:3x:4x:5undefined&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>下划线变量<strong>[使用下划线(_)获取上一个表达式的运算结果]</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node&gt; var x&#x3D;10;undefined&gt; y&#x3D;10;10&gt; x+y20&gt; var sum&#x3D;_undefined&gt; console.log(sum)20undefined&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>两次ctrl+c停止REPL</p><h2 id="Node-js的回调函数"><a href="#Node-js的回调函数" class="headerlink" title="Node.js的回调函数"></a>Node.js的回调函数</h2><ul><li><p>Node.js异步编程的直接体现就是回调</p></li><li><p>阻塞代码实例</p><ul><li><p>创建一个文件 input.txt ，内容如下：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建 main.js 文件, 代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"程序执行结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>以上代码执行结果如下：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node main.jsHello World！程序执行结束!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>非阻塞代码实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"程序执行结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码执行结果如下：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node main.js程序执行结束!Hello World!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p></li><li><p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">学习node.js</summary>
    
    
    
    <category term="js" scheme="https://changqingaas.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>How-to-be-a-good-programmer</title>
    <link href="https://changqingaas.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/others/To-be-a-good-programmer/"/>
    <id>https://changqingaas.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/others/To-be-a-good-programmer/</id>
    <published>2021-08-29T12:30:16.000Z</published>
    <updated>2022-01-17T01:18:37.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实例驱动学习"><a href="#实例驱动学习" class="headerlink" title="实例驱动学习"></a>实例驱动学习</h2><p>在知识爆炸的年代, 想成为一个好的程序员, 要具备这样一个精神:</p><p><strong>开发者精神</strong></p><blockquote><p>开发者精神是指, 从学习编程第一天起, 你的目标, 你所做的事, 永远不是以<code>要学会XX</code>为目标, 而是以<code>开发出XX</code>为目标, 深刻意识到你学习的一切, 最终是为了你的开发而服务的。</p></blockquote><p>而开发者精神的反面则是<code>学生气</code>:</p><p><strong>学生气</strong></p><blockquote><p>从学习编程的第一天起, 就把自己当学生, 上课听讲记笔记为第一位, 记忆知识点为第一位, 买教材读教材为第一位, 追求<code>学会XX</code>, 而不是<code>用它开发出XX</code>。</p></blockquote><p>我们举个例子， 假如你要学习Java，<code>学生气</code>的学生行为模式:</p><pre><code>读教材, 听课, 记笔记, 追求把这个语言的每个知识点都记得很清楚, 追求一种&quot;内功&quot;的修炼, 在这个过程中, 从来不想着用它去&quot;创造&quot;什么. 在学习的第一天起, 他给自己定下了一个目标:&quot;我这个学期一定要把这个语言的基础打牢, 最后在考试中取得高分, 并且为以后的学习提供更坚实的基础.&quot;</code></pre><p>那么具有<code>开发者精神</code>的人会这样做:</p><pre><code>先大体了解一下Java语言在哪些领域比较强势, 做一个简单的调研, 得出了Java在Web领域很强势这一个信号, 于是在学习Java的第一天起, 他就给自己定下了一个目标: &quot;我要在半年内通过学习Java, 运用Java做出一个中小型的, 基于Web的企业管理后台&quot;</code></pre><p>这两种人, 起点都一样, 都是<code>完全不会Java</code>, 但是最后的结果往往是, 后者无论是知识熟练度还是实用性都会超过前者, 而且整个学习过程会有源源不断地动力.</p><p><code>夯实基础</code>这个目标, 其实是空洞的, 什么叫做夯实? 什么叫做基础? 而且就算你真的夯实了基础, 你也极有可能陷入一种<code>虚无感</code>中, 因为你的所有知识, 都会遗忘.</p><p>这就是为什么很多计算机专业学生很爱问的一个问题:</p><pre><code>&quot;学了这么多知识, 忘了怎么办?&quot;</code></pre><p>如果你具备<code>开发者精神</code>, 那么你根本不会理会这个问题, 因为, 你开发出的东西, 你做出的产品, 它就是永久存在在这个世界上的, 你的成就感来源于真实的, 具体的, 可持久延续的项目中, 而不是来源于”我学会了什么”.</p><p>我们一定要明白:</p><pre><code>一切不谈成就感, 不谈反馈的学习劝导, 都是在耍流氓</code></pre><p>既然我们想获得反馈, 那么一个很现实的建议就是, 在Github上创建你的第一个开源代码仓库, 长期地, 稳定地commit, 当然, 至于这个仓库到底是干啥的, 这个因人而异, 有可能是你自己开发的一个VScode插件, 有可能是你自己写的读书笔记, 在这个不断地commit的过程中, 感受你的代码仓库不断增长不断完善的过程中, 你会获得一个比较持久的反馈和成就感, 一旦有了反馈和成就感, 那么你的学习动力就会一直保持, 也可以从学习中获得快乐.</p><p><strong>记住, 你不是学生, 你是开发者.</strong></p><h2 id="知识输入与输出"><a href="#知识输入与输出" class="headerlink" title="知识输入与输出"></a>知识输入与输出</h2><p>当你学习一个东西的时候, 如果学完马上用语言讲给别人听, 你会学的更好, 而且会发现新问题.</p><p>很多学习理论都指出, 知识的学习, 输入固然重要, 输出更为重要.</p><p>输入就是学习别人的知识, 输出就是把自己学会的知识用文字, 语言的形式表达出来, 很多人的学习, 只有输入, 没有输出, 这样的学习肯定是不行的.</p><p>几乎所有优秀的程序员, 都有撰写技术文章的习惯, 很多时候, 并不是他们什么都懂, 而是他们刚学会了什么, 然后就围绕着这个刚学会的东西, 用自己的语言讲出来, 久而久之, 就会被别人觉得是大牛, 但是他和你的区别, 有可能仅仅是是否输出的区别.</p><p>建议所有计算机学习者, 都要有写技术文章/读书笔记的习惯, 可以发表在自己的个人主页, 其他平台上, 攥写技术文章也可以很好地增加面试官对你的好感.</p><p>写技术文章的时候, 最好用<code>MarkDown</code>哦, 程序员是不需要用<code>Word</code>这种东西的, 我们的内容是要方便发表在网站上, <code>Word</code>不能直接在网站里显示, 而<code>MarkDown</code>可以轻易地转换成<code>html</code>格式文件, 在浏览器中显示.</p><h2 id="代码风格篇"><a href="#代码风格篇" class="headerlink" title="代码风格篇"></a>代码风格篇</h2><p>现在几乎所有主流语言都有相应的代码风格检查工具, 一般已IDE或Editor的插件或扩展形式给出</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式并不是针对任何一种语言, 而是一种用编程语言描述现实世界问题广泛采用的各种模式, 比如, 观察者模式, 工厂模式, 依赖注入模式等.</p><p>好的设计模式, 是好代码的保证, 只有先学会了设计模式, 才能在软件设计中游刃有余, 而且更现实的问题是, 现在很多框架, 比如Spring, Angular等, 都充斥了大量的设计模式, 比如<code>Factory Pattern</code>, <code>Dependency Injection Pattern</code>, 你必须理解这些设计模式, 你才能理解这个框架.</p><p>个人认为设计模式没有必要买本教材, 结合视频和技术文章, 就足以理解和运用.</p><h3 id="小习惯"><a href="#小习惯" class="headerlink" title="小习惯"></a>小习惯</h3><ol><li>不要嫌变量名长, 最好可以直接通过变量名推测变量的作用.</li><li>重复出现的代码, 封装成独立的类或函数.</li><li>提前降低代码的耦合度, 不同作用, 不同类别的代码, 不要混在一起, 最好分成独立的文件</li><li>将代码进行业务分层, 比如在Web开发中, 有数据层, 服务层, DTO层, Controller层, 渲染层等, 只有将层次分开了, 才能获得足够的可拓展性, 不然代码多了你就全乱了.</li><li>用良好的设计模式去”设计”软件, 在执行一些算法的时候, 可以想一想它的时空复杂度, 想一想怎么可以让它执行地更快.</li></ol><h2 id="如何管理自己的电脑"><a href="#如何管理自己的电脑" class="headerlink" title="如何管理自己的电脑"></a>如何管理自己的电脑</h2><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p>为了更好的管理我们的各种应用包，最好使用包管理工具来进行各种包，软件的安装和使用, 方便进行卸载, 更新, 安装, 无需打开浏览器即可完成一系列操作.</p><blockquote><p>linux : apt-get (ubuntu distro)<br>    osx : brew<br>    windows: Chocolatey</p></blockquote><p>另外, windows平台上的包管理工具, 在国内的网络环境下经常慢的感人, 所以<code>Chocolatey</code>可能使用体验并不好.  推荐使用今年微软新发布的 <code>WSL2</code>, 这个东西不是那种传统的虚拟机, 有了它你可以像操作linux系统那样操作windows系统, 而且支持 <code>docker</code>, 甚至我推荐以后大家所有命令都可以在<code>WSL2</code>里执行.</p><h3 id="容器-Docker"><a href="#容器-Docker" class="headerlink" title="容器 - Docker"></a>容器 - Docker</h3><p>为了更方便的进行开发环境配置，我推荐所有计算机学生尽早了解和使用Docker。</p><p>Docker 就是为了解决复杂的环境配置问题而生的。</p><p>它将你的软件和软件所依赖的所有环境打包成一个镜像(Image), 该镜像可以在任何一台装有docker 的电脑上运行, 和操作系统无关, 也就是docker 把运行环境和你的操作系统隔离开来了，中间隔了一层docker engine 。</p><p>写过不少代码的你一定见过这种现象：你的代码在自己电脑上能运行，但是在别人电脑上就会报错，无法运行，原因很简单，任何软件的运行都需要环境。</p><p>比如，jar包的运行需要jre ，python脚本的运行需要python 解释器安装在电脑上，以后你可能还需要运行一些服务，比如数据库mysql server , redis , rabbitmq , 随着软件运行环境复杂度的增加, 你的软件运行条件也变得苛刻，如果你想把本地的应用部署到服务器上，那事更多，需要的环境得一个个地装到你的linux服务器上，如何彻底解决这个问题？</p><p>只需在你的电脑中安装docker , 你就可以毫无后顾之忧。</p><p>所有的环境，服务，软件都是以Image 的形式打包的，Image 中包含了运行你软件的所有东西，比如你的软件是个python 脚本, 并且使用了第三方库flask，那这个Image 中就包含了python ,也就是它的base image , 也同时包含了flask, 这样的话任何一个装有docker的电脑都可以运行你的image。</p>]]></content>
    
    
    <summary type="html">记住, 你不是学生, 你是开发者.</summary>
    
    
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="Advice" scheme="https://changqingaas.github.io/tags/Advice/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="https://changqingaas.github.io/%E7%88%AC%E8%99%AB/Python/Python%E7%88%AC%E8%99%AB/"/>
    <id>https://changqingaas.github.io/%E7%88%AC%E8%99%AB/Python/Python%E7%88%AC%E8%99%AB/</id>
    <published>2021-08-27T06:25:32.000Z</published>
    <updated>2022-02-04T05:46:45.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬虫概念"><a href="#爬虫概念" class="headerlink" title="爬虫概念"></a>爬虫概念</h1><h2 id="1-robots协议"><a href="#1-robots协议" class="headerlink" title="1.robots协议"></a>1.robots协议</h2><p>也叫robots.txt，是存放在网站根目录下的文本文件，用来告诉搜索引擎该网站哪些内容是不应该被抓取的，哪些是可以抓取的。</p><p>如<a href="https://www.csdn.net/robots.txt">https://www.csdn.net/robots.txt</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">User-agent: *Disallow: &#x2F;scriptsDisallow: &#x2F;publicDisallow: &#x2F;css&#x2F;Disallow: &#x2F;images&#x2F;Disallow: &#x2F;content&#x2F;Disallow: &#x2F;ui&#x2F;Disallow: &#x2F;js&#x2F;Disallow: &#x2F;scripts&#x2F;Disallow: &#x2F;article_preview.html*Disallow: &#x2F;tag&#x2F;Disallow: &#x2F;*?*Disallow: &#x2F;link&#x2F;Sitemap: https:&#x2F;&#x2F;www.csdn.net&#x2F;sitemap-aggpage-index.xmlSitemap: https:&#x2F;&#x2F;www.csdn.net&#x2F;article&#x2F;sitemap.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-常见的反爬虫措施"><a href="#2-常见的反爬虫措施" class="headerlink" title="2.常见的反爬虫措施"></a>2.常见的反爬虫措施</h2><h4 id="1-请求头校验"><a href="#1-请求头校验" class="headerlink" title="1.请求头校验"></a>1.请求头校验</h4><p>一般网站会对请求头进行校验，比如Host，UA，Content-Type字段等，模拟请求的时候，这些常见的请求头最好是带上。</p><h4 id="2-IP访问次数控制"><a href="#2-IP访问次数控制" class="headerlink" title="2.IP访问次数控制"></a>2.IP访问次数控制</h4><p>同一个IP地址短时间内大量发起请求，会引起IP限制，解决方法是用代理IP，或者构建自己的代理IP池。</p><h4 id="3-接口请求频率限制"><a href="#3-接口请求频率限制" class="headerlink" title="3.接口请求频率限制"></a>3.接口请求频率限制</h4><p>有的网站会控制接口访问的频率，比如有些查询接口，控制两三秒访问一次。</p><h4 id="4-接口访问次数限制"><a href="#4-接口访问次数限制" class="headerlink" title="4.接口访问次数限制"></a>4.接口访问次数限制</h4><p>每天限制某个IP或账号访问接口的次数，达到上限后出现二次验证或者直接封账号/IP.比如登录接口</p><h4 id="5-行为认证"><a href="#5-行为认证" class="headerlink" title="5.行为认证"></a>5.行为认证</h4><p>请求次数过多会出现人工认证，如图片验证码，滑动认证，点击认证等，可以对接打码平台。</p><h4 id="6，自动化环境检测"><a href="#6，自动化环境检测" class="headerlink" title="6，自动化环境检测"></a>6，自动化环境检测</h4><p>selenium自动化工具有的网站会检测出来，大部分可以通过下面两种方式跳过检测,下面两种方式无法处理的话，还可以尝试把页面改为移动端页面(手机模式)，最后还有一种方法就是代理服务器拦截修改js代码，把检测selenium的js修改掉。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">options &#x3D; webdriver.ChromeOptions()# 躲避部分网站selenium检测options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])options.add_experimental_option(&quot;useAutomationExtension&quot;, False)driver &#x3D; webdriver.Chrome(executable_path&#x3D;chromedriver_path, options&#x3D;options)# 躲避部分网站selenium检测script &#x3D; &quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;);&quot;driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: script&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于移动端appium的检测，可以尝试替换为uiautomator2实现自动化</p><h4 id="7-数据动态加载"><a href="#7-数据动态加载" class="headerlink" title="7.数据动态加载"></a>7.数据动态加载</h4><p>有的数据不是通过html页面的接口请求返回的，抓包分析请求，找到正确的数据接口。</p><h4 id="8-请求参数加密"><a href="#8-请求参数加密" class="headerlink" title="8.请求参数加密"></a>8.请求参数加密</h4><p>网易云音乐的post请求的请求体就是前端经过js加密后计算得到的，需要逆向js代码</p><h4 id="9-返回数据加密"><a href="#9-返回数据加密" class="headerlink" title="9.返回数据加密"></a>9.返回数据加密</h4><p>需要逆向js代码，分析如何解密。还有一种像大众点评的评论，需要通过定位去找到文本。</p><h4 id="10-动态更新cookies"><a href="#10-动态更新cookies" class="headerlink" title="10.动态更新cookies"></a>10.动态更新cookies</h4><p>华为手机云服务，每次请求接口都会重新设置cookies，并且请求头参数也需要跟着cookies一起变化</p><h1 id="Python爬虫之requests库"><a href="#Python爬虫之requests库" class="headerlink" title="Python爬虫之requests库"></a>Python爬虫之requests库</h1><h2 id="一-发送请求"><a href="#一-发送请求" class="headerlink" title="一.发送请求"></a>一.发送请求</h2><p>requests提供了http的所有基本请求方式：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsr &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;)r &#x3D; requests.put(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;put&quot;)r &#x3D; requests.delete(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;delete&quot;)r &#x3D; requests.head(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;)r &#x3D; requests.options(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>基本get请求中参数的传递：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># requests允许使用params关键字参数，以字典的形式来提供get请求url中的参数。payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;r &#x3D; requests.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;, params&#x3D;payload)print(r.url)  # http:&#x2F;&#x2F;httpbin.org&#x2F;get?key2&#x3D;value2&amp;key1&#x3D;value1# 字典中的value还可以以列表的形式传入payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: [&#39;value2&#39;, &#39;value3&#39;]&#125;r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, params&#x3D;payload)print(r.url)http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;value1&amp;key2&#x3D;value2&amp;key2&#x3D;value3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加请求头headers<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;some&#x2F;endpoint&#39;headers &#x3D; &#123;&#39;user-agent&#39;: &#39;my-app&#x2F;0.0.1&#39;&#125;r &#x3D; requests.get(url, headers&#x3D;headers)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>Post请求<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;, data&#x3D;payload)print(r.text)# 可以为 data 参数传入一个元组列表# 在表单中多个元素使用同一 key 的时候，这种方式尤其有效：payload &#x3D; ((&#39;key1&#39;, &#39;value1&#39;), (&#39;key1&#39;, &#39;value2&#39;))r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;, data&#x3D;payload)print(r.text)&#123;  ...  &quot;form&quot;: &#123;    &quot;key1&quot;: [      &quot;value1&quot;,      &quot;value2&quot;    ]  &#125;,  ...&#125;# post的为json对象url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;some&#x2F;endpoint&#39;payload &#x3D; &#123;&#39;some&#39;: &#39;data&#39;&#125;r &#x3D; requests.post(url, json&#x3D;payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>超时设置：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">requests.get(&#39;http:&#x2F;&#x2F;github.com&#39;, timeout&#x3D;0.001)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二-响应内容"><a href="#二-响应内容" class="headerlink" title="二.响应内容"></a>二.响应内容</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsr &#x3D; requests.get(&#39;https:&#x2F;&#x2F;github.com&#x2F;timeline.json&#39;)r.encoding&#x3D;&#39;utf-8&#39;r.text# [&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https:&#x2F;&#x2F;github.com&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网页乱码问题:<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查看网页编码print(res.apparent_encoding)# 设置编码res.encoding &#x3D; &#39;GB2312&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>二进制响应内容(r.content)<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import Imagefrom io import BytesIO#BytesIO用于操作内存中的二进制数据img&#x3D;Image.open(BytesIO(r.content))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>JSON响应内容（r.json()）<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsr &#x3D; requests.get(&#39;https:&#x2F;&#x2F;github.com&#x2F;timeline.json&#39;)r.json()# [&#123;u&#39;repository&#39;: &#123;u&#39;open_issues&#39;: 0, u&#39;url&#39;: &#39;https:&#x2F;&#x2F;github.com&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>响应状态码（r.status_code）<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)r.status_code200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>响应头(r.headers)<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">r.headers&#123;    &#39;content-encoding&#39;: &#39;gzip&#39;,    &#39;transfer-encoding&#39;: &#39;chunked&#39;,    &#39;connection&#39;: &#39;close&#39;,    &#39;server&#39;: &#39;nginx&#x2F;1.0.4&#39;,    &#39;x-runtime&#39;: &#39;148ms&#39;,    &#39;etag&#39;: &#39;&quot;e1ca502697e5c9317743dc078f67693f&quot;&#39;,    &#39;content-type&#39;: &#39;application&#x2F;json&#39;&#125;r.headers[&#39;Content-Type&#39;]&#39;application&#x2F;json&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="三-Cookies"><a href="#三-Cookies" class="headerlink" title="三.Cookies"></a>三.Cookies</h2><p>如果某个响应中包含一些 cookie，你可以快速访问它们：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; &#39;http:&#x2F;&#x2F;example.com&#x2F;some&#x2F;cookie&#x2F;setting&#x2F;url&#39;r &#x3D; requests.get(url)r.cookies[&#39;example_cookie_name&#39;]# &#39;example_cookie_value&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>要想发送你的cookies到服务器，可以使用 cookies 参数：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;cookies &#x3D; dict(cookies_are&#x3D;&#39;working&#39;)r &#x3D; requests.get(url, cookies&#x3D;cookies)r.text# &#39;&#123;&quot;cookies&quot;: &#123;&quot;cookies_are&quot;: &quot;working&quot;&#125;&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="四-会话"><a href="#四-会话" class="headerlink" title="四.会话"></a>四.会话</h2><p>requests.Session()这样可以在会话中保留状态，保持cookie等<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestss &#x3D; requests.Session()s.headers.update(&#123;&#39;x-test&#39;: &#39;true&#39;&#125;)r &#x3D; s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;headers&#39;, headers&#x3D;&#123;&#39;x-test2&#39;: &#39;true&#39;&#125;)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="五-代理"><a href="#五-代理" class="headerlink" title="五.代理"></a>五.代理</h2><p>如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"># http代理import requestsproxies &#x3D; &#123;  &quot;https&quot;: &quot;http:&#x2F;&#x2F;41.118.132.69:4433&quot;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;, proxies&#x3D;proxies)# socks代理proxies &#x3D; &#123;    &#39;http&#39;: &#39;socks5:&#x2F;&#x2F;user:pass@host:port&#39;,    &#39;https&#39;: &#39;socks5:&#x2F;&#x2F;user:pass@host:port&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="六-Prepared-Request"><a href="#六-Prepared-Request" class="headerlink" title="六.Prepared Request"></a>六.Prepared Request</h2><p>构造requests.Request对象，将Request对象作为参数传入requests.Session()对象的prepare_request()方法中，最后通过Session对象的send()方法发送请求。<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfrom requests import Requesturl &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;# 创建Session对象s &#x3D; requests.Session()# 构造Request对象req &#x3D; Request(&#39;GET&#39;,url)# 将Request对象转换成 PreparedRequest对象prepped &#x3D; s.prepare_request(req)# 利用Session对象的send()方法，发送PreparedRequest对象res &#x3D; s.send(prepped)print(res.text)print(type(prepped))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h1 id="Python爬虫之BeautifulSoup"><a href="#Python爬虫之BeautifulSoup" class="headerlink" title="Python爬虫之BeautifulSoup"></a>Python爬虫之BeautifulSoup</h1><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">html_doc &#x3D; &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p class&#x3D;&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt; and&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; class&#x3D;&quot;sister bro&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;;and they lived at the bottom of a well.&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt;&quot;&quot;&quot;soup &#x3D; BeautifulSoup(html_doc, &#39;html.parser&#39;)print(soup.prettify())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="find-all-name-attrs-recursive-string-kwargs"><a href="#find-all-name-attrs-recursive-string-kwargs" class="headerlink" title="find_all(name , attrs , recursive , string , **kwargs)"></a>find_all(name , attrs , recursive , string , **kwargs)</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查找所有的a标签res &#x3D; soup.find_all(&#39;a&#39;)# # 查找所有的a标签和p标签res &#x3D; soup.find_all([&#39;a&#39;, &#39;p&#39;])# 查找class&#x3D;title的p标签res &#x3D; soup.find_all(&#39;p&#39;, &#39;title&#39;)# 指定属性查找  可支持字符串，正则表达式，或者函数# 指定id查找元素res &#x3D; soup.find_all(id&#x3D;&quot;link1&quot;)# 指定href查找 [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;]res &#x3D; soup.find_all(href&#x3D;re.compile(&#39;elsie&#39;))# 指定多个属性查找res &#x3D; soup.find_all(id&#x3D;&#39;link1&#39;, href&#x3D;re.compile(&#39;elsie&#39;))# 指定多个属性查找 attrs参数res &#x3D; soup.find_all(attrs&#x3D;&#123;&#39;id&#39;: &#39;link1&#39;, &#39;href&#39;: re.compile(&#39;elsie&#39;)&#125;)# 通过css搜索res &#x3D; soup.find_all(class_&#x3D;&quot;sister bro&quot;)# 通过函数过滤,查找类名长度大于6的元素res &#x3D; soup.find_all(class_&#x3D;lambda x: x is not None and len(x) &gt; 6)# recursive参数，如果只想搜索直接子节点  recursive&#x3D;Falseres &#x3D; soup.find_all(&#39;title&#39;, recursive&#x3D;False)# find_all() 方法的返回结果是值包含一个元素的列表# 而find()方法直接返回第一个结果，没有则返回None.res &#x3D; soup.find(&#39;a&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 类查找res &#x3D; soup.select(&#39;.sister&#39;)# ID查找res &#x3D; soup.select(&#39;#link1&#39;)res &#x3D; soup.select(&#39;a#link1&#39;)# 通过是否存在某个属性查找res &#x3D; soup.select(&#39;a[href]&#39;)# 指定属性值查找res &#x3D; soup.select(&#39;a[href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot;]&#39;)# 查找返回第一个元素res &#x3D; soup.select_one(&#39;a[href]&#39;)# 获取元素的属性值res &#x3D; soup.select_one(&#39;a[href]&#39;).get(&#39;href&#39;)# 获取元素的文本res &#x3D; soup.select_one(&#39;a[href]&#39;).text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Selenium自动化"><a href="#Selenium自动化" class="headerlink" title="Selenium自动化"></a>Selenium自动化</h1><h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1.基础操作"></a>1.基础操作</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium import webdriverimport timefrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # 谷歌浏览器驱动    chromedriver_path &#x3D; &#39;chromedriver72.exe&#39;    options &#x3D; webdriver.ChromeOptions()    # 躲避部分网站selenium检测    options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])    options.add_experimental_option(&quot;useAutomationExtension&quot;, False)    driver &#x3D; webdriver.Chrome(executable_path&#x3D;chromedriver_path, options&#x3D;options)    # 躲避部分网站selenium检测    script &#x3D; &quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;);&quot;    driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: script&#125;)    # 浏览器最大化    driver.maximize_window()    url &#x3D; &#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;    driver.get(url)    # 显式等待    wait &#x3D; WebDriverWait(driver, 20, 1)    # 在主页输入框搜索requests，并点击搜索    input_ &#x3D; wait.until(EC.presence_of_element_located((By.ID, &#39;id-search-field&#39;)))    input_.send_keys(&#39;requests&#39;)    time.sleep(1)    btn &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@title&#x3D;&quot;Submit this Search&quot;]&#39;)    btn.click()    time.sleep(10)    driver.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h2><h4 id="查找单个元素"><a href="#查找单个元素" class="headerlink" title="查找单个元素"></a>查找单个元素</h4><p>最常用的定位元素的两个方法是通过Xpath和id来定位。</p><ul><li>find_element_by_id</li><li>find_element_by_xpath</li></ul><h4 id="查找多个元素"><a href="#查找多个元素" class="headerlink" title="查找多个元素"></a>查找多个元素</h4><ul><li>find_elements_by_xpath</li><li>find_elements_by_name</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过xpath查找元素driver.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@title&#x3D;&quot;Submit this Search&quot;]&#39;)# 通过id查找元素driver.find_element_by_id(&#39;id-search-field&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取元素内部内容"><a href="#获取元素内部内容" class="headerlink" title="获取元素内部内容"></a>获取元素内部内容</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">text &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;ISDCaptcha&quot;]&#x2F;div[2]&#x2F;div&#39;).get_attribute(&#39;innerHTML&#39;)if &#39;请绘制图中手势&#39; in text:    print(&#39;出现行为认证&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取元素指定属性的属性值"><a href="#获取元素指定属性的属性值" class="headerlink" title="获取元素指定属性的属性值"></a>获取元素指定属性的属性值</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;find-step3-phone&quot;]&#39;).get_attribute(&#39;style&#39;)driver.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;imgVerifyCodeP&quot;]&#39;).get_attribute(&#39;src&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="切换到指定iframe"><a href="#切换到指定iframe" class="headerlink" title="切换到指定iframe"></a>切换到指定iframe</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过id或者名称driver.switch_to.frame(&quot;iframeLoginIfm&quot;)driver.switch_to.frame(0)frame &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;loginDiv&quot;]&#x2F;iframe&#39;)driver.switch_to.frame(frame)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="切换到指定窗口"><a href="#切换到指定窗口" class="headerlink" title="切换到指定窗口"></a>切换到指定窗口</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver.switch_to.window(browser.window_handles[1])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="切换到alert弹窗"><a href="#切换到alert弹窗" class="headerlink" title="切换到alert弹窗"></a>切换到alert弹窗</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">text &#x3D; driver.switch_to.alert.textif &#39;图片验证码输入错误&#39; in text:    print(&#39;图片验证码识别错误&#39;)    driver.switch_to.alert.accept()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-元素交互"><a href="#3-元素交互" class="headerlink" title="3.元素交互"></a>3.元素交互</h2><h4 id="按钮点击"><a href="#按钮点击" class="headerlink" title="按钮点击"></a>按钮点击</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">btn &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div[@role&#x3D;&quot;button&quot;]&#x2F;div&#x2F;span&#x2F;span&#39;)btn.click()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="执行js代码"><a href="#执行js代码" class="headerlink" title="执行js代码"></a>执行js代码</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">style_ &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;passport-login-pop&quot;]&#39;).get_attribute(&#39;style&#39;)style_ &#x3D; style_.replace(&#39;display: none;&#39;, &#39;&#39;)if not style_:    style_ &#x3D; &#39;left: 259px; top: 212px; z-index: 60001;&#39;js &#x3D; &#39;document.getElementById(&quot;passport-login-pop&quot;).setAttribute(&quot;style&quot;,&quot;&#123;&#125;&quot;);&#39;.format(style_)driver.execute_script(js)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="表单输入"><a href="#表单输入" class="headerlink" title="表单输入"></a>表单输入</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">input_ &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;session[password]&quot; and @dir&#x3D;&quot;auto&quot;]&#39;)input_.send_keys(&#39;123qwe&#39;)from selenium.webdriver.common.keys import Keysinput_.send_keys(Keys.BACK_SPACE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver.execute_script(&quot;&quot;&quot;                (function () &#123;                    var y &#x3D; document.body.scrollTop;                    var step &#x3D; 100;                    window.scroll(0, y);                    function f() &#123;                        if (y &lt; document.body.scrollHeight) &#123;                            y +&#x3D; step;                            window.scroll(0, y);                            setTimeout(f, 50);                        &#125;                        else &#123;                            window.scroll(0, y);                            document.title +&#x3D; &quot;scroll-done&quot;;                        &#125;                    &#125;                    setTimeout(f, 1000);                &#125;)();                &quot;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模拟拖动"><a href="#模拟拖动" class="headerlink" title="模拟拖动"></a>模拟拖动</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium.webdriver.common.action_chains import ActionChainsdef get_track(self, distance):    track &#x3D; []    current &#x3D; 0    mid &#x3D; distance * 3 &#x2F; 4    t &#x3D; 0.2    v &#x3D; 0    while current &lt; distance:        if current &lt; mid:            a &#x3D; 2        else:            a &#x3D; -3        v0 &#x3D; v        v &#x3D; v0 + a * t        move &#x3D; v0 * t + 1 &#x2F; 2 * a * t * t        current +&#x3D; move        track.append(round(move))    return track# 模拟拖动btn &#x3D; wait.until(EC.presence_of_element_located((By.XPATH, xpath_)))track &#x3D; get_track(500)action &#x3D; ActionChains(browser)action.click_and_hold(btn).perform()action.reset_actions()for i in track:    action.move_by_offset(xoffset&#x3D;i, yoffset&#x3D;0).perform()    action.reset_actions()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-等待"><a href="#4-等待" class="headerlink" title="4.等待"></a>4.等待</h2><h4 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 显式等待wait &#x3D; WebDriverWait(driver, 20, 1)input_ &#x3D; wait.until(EC.presence_of_element_located((By.ID, &#39;id-search-field&#39;)))input_.send_keys(&#39;requests&#39;)time.sleep(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium import webdriverdriver &#x3D; webdriver.Chrome()# 隐式等待driver.implicitly_wait(10)driver.get(&#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;)logo &#x3D; driver.find_element_by_id(&#39;zh-top-link-logo&#39;)print(logo)driver.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-其他操作"><a href="#5-其他操作" class="headerlink" title="5.其他操作"></a>5.其他操作</h2><h4 id="解决页面加载时间过长问题"><a href="#解决页面加载时间过长问题" class="headerlink" title="解决页面加载时间过长问题"></a>解决页面加载时间过长问题</h4><p>有时候页面有些静态文件加载比较耗时，selenium可以不需要等待页面全部加载完全在去查找元素<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">options &#x3D; webdriver.ChromeOptions()# 解决页面加载阻塞问题options.set_capability(&#39;pageLoadStrategy&#39;, &#39;none&#39;)driver &#x3D; webdriver.Chrome(executable_path&#x3D;self.chromedriver_path, options&#x3D;options)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">options.add_argument(&quot;user-agent&#x3D;&#123;&#125;&quot;.format(&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.100 Safari&#x2F;537.36&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">socks5 &#x3D; &quot;socks5:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&quot;.format(socks5_proxy_ip, socks5_proxy_port)options.add_argument(&quot;--proxy-server&#x3D;&#123;&#125;&quot;.format(socks5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="捕捉F12控制台中所有请求记录"><a href="#捕捉F12控制台中所有请求记录" class="headerlink" title="捕捉F12控制台中所有请求记录"></a>捕捉F12控制台中所有请求记录</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesd &#x3D; DesiredCapabilities.CHROMEd[&#39;loggingPrefs&#39;] &#x3D; &#123;&#39;performance&#39;: &#39;ALL&#39;&#125;d[&#39;goog:chromeOptions&#39;] &#x3D; &#123;    &#39;perfLoggingPrefs&#39;: &#123;        &#39;enableNetwork&#39;: True,    &#125;,    &#39;w3c&#39;: False,&#125;options.add_experimental_option(&#39;perfLoggingPrefs&#39;, &#123;&#39;enableNetwork&#39;: True&#125;)options.add_experimental_option(&#39;w3c&#39;, False)driver &#x3D; webdriver.Chrome(executable_path&#x3D;self.chromedriver_path, options&#x3D;options, desired_capabilities&#x3D;d)# 保存loglog_list &#x3D; []for entry in driver.get_log(&#39;performance&#39;):    log_list.append(entry)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="屏幕截图-可以截取图片验证码加以识别"><a href="#屏幕截图-可以截取图片验证码加以识别" class="headerlink" title="屏幕截图,可以截取图片验证码加以识别"></a>屏幕截图,可以截取图片验证码加以识别</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import win32conimport win32guiimport win32printfrom win32api import GetSystemMetricsfrom PIL import Imagedef get_real_resolution():    &quot;&quot;&quot;获取真实的分辨率&quot;&quot;&quot;    hDC &#x3D; win32gui.GetDC(0)    # 横向分辨率    w &#x3D; win32print.GetDeviceCaps(hDC, win32con.DESKTOPHORZRES)    # 纵向分辨率    h &#x3D; win32print.GetDeviceCaps(hDC, win32con.DESKTOPVERTRES)    return w, hdef get_screen_size():    &quot;&quot;&quot;获取缩放后的分辨率&quot;&quot;&quot;    w &#x3D; GetSystemMetrics(0)    h &#x3D; GetSystemMetrics(1)    return w, hreal_resolution &#x3D; get_real_resolution()screen_size &#x3D; get_screen_size()screen_scale_rate &#x3D; round(real_resolution[0] &#x2F; screen_size[0], 2)pic_name &#x3D; &#39;***.png&#39;driver.save_screenshot(pic_name)# 找到图片验证码元素element &#x3D; driver.find_element_by_xpath(xpath_)left &#x3D; element.location[&#39;x&#39;] * screen_scale_ratetop &#x3D; element.location[&#39;y&#39;] * screen_scale_rateright &#x3D; (element.location[&#39;x&#39;] + element.size[&#39;width&#39;]) * screen_scale_ratebottom &#x3D; (element.location[&#39;y&#39;] + element.size[&#39;height&#39;]) * screen_scale_rateim &#x3D; Image.open(pic_name)# 裁剪图片im &#x3D; im.crop((left, top, right, bottom))im.save(pic_name)# 把图片转成base64,利用打码平台接口识别with open(pic_name, &#39;rb&#39;) as f:    code_img_base64 &#x3D; base64.b64encode(f.read()).decode()os.remove(pic_name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="xpath解析"><a href="#xpath解析" class="headerlink" title="xpath解析"></a>xpath解析</h1><ul><li>// :从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</li><li>/ : 匹配当前目录下的直接子节点。</li><li>.. : 匹配当前节点的父节点。</li><li>@：选取属性。</li><li>//* : 选取文档中所有元素</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">text &#x3D; &quot;&quot;&quot;            &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;            &lt;bookstore&gt;            &lt;book&gt;              &lt;title lang&#x3D;&quot;eng&quot;&gt;Harry Potter&lt;&#x2F;title&gt;              &lt;price&gt;29.99&lt;&#x2F;price&gt;            &lt;&#x2F;book&gt;            &lt;book&gt;              &lt;title lang&#x3D;&quot;cn&quot;&gt;Learning XML&lt;&#x2F;title&gt;              &lt;price&gt;39.95&lt;&#x2F;price&gt;              &lt;aa lang&#x3D;&quot;cn eng aa bb&quot; name&#x3D;&quot;cc&quot;&gt;Learning XML&lt;&#x2F;aa&gt;            &lt;&#x2F;book&gt;            &lt;&#x2F;bookstore&gt;&quot;&quot;&quot;from lxml import etreehtml &#x3D; etree.HTML(text)# print(etree.tostring(html).decode(&#39;utf-8&#39;))# 选取所有指定的节点res &#x3D; html.xpath(&#39;&#x2F;&#x2F;book&#39;)# 获取指定节点的所有直接子节点res &#x3D; html.xpath(&#39;&#x2F;&#x2F;book&#x2F;aa&#39;)# 获取指定节点的父节点res &#x3D; html.xpath(&quot;&#x2F;&#x2F;aa&#x2F;..&quot;)# 通过属性匹配选择节点res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title[@lang&#x3D;&quot;cn&quot;]&#39;)# 获取文本值res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title[@lang&#x3D;&quot;cn&quot;]&#x2F;text()&#39;)res &#x3D; html.xpath(&#39;&#x2F;&#x2F;price&#x2F;text()&#39;)# 获取属性值 [&#39;eng&#39;, &#39;cn&#39;]res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title&#x2F;@lang&#39;)# 属性多值匹配res &#x3D; html.xpath(&#39;&#x2F;&#x2F;aa[contains(@lang,&quot;aa&quot;)]&#39;)# 对于属性值有多个的节点，不用contains函数的话，匹配到的是空[]res &#x3D; html.xpath(&#39;&#x2F;&#x2F;aa[@lang&#x3D;&quot;aa&quot;]&#39;)# 文本匹配res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title[contains(text(), &quot;XML&quot;)]&#39;)# 运算符res &#x3D; html.xpath(&#39;&#x2F;&#x2F;aa[contains(@lang,&quot;aa&quot;) and @name&#x3D;&quot;cc&quot;]&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python爬虫—代理池维护"><a href="#Python爬虫—代理池维护" class="headerlink" title="Python爬虫—代理池维护"></a>Python爬虫—代理池维护</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><ol><li>去代理网站上爬取大量代理IP，并将其存储在redis数据库。</li><li>定时获取redis中的所有代理IP，检测每一个代理IP是否可用。</li><li>通过flask，对外提供获取代理IP的接口，如果想要使用代理池中的代理IP，只需要访问我们提供的接口即可。<br><strong>现在网上免费代理IP网站越来越少，而且免费的代理质量非常不稳定，本文只是提供构建代理IP池的一种思路，实战的话还是要想办法获取优质的代理。</strong></li></ol><h2 id="代理池系统具体实现思路"><a href="#代理池系统具体实现思路" class="headerlink" title="代理池系统具体实现思路"></a>代理池系统具体实现思路</h2><p><img src="../pic/spiders/proxypool.png" alt=""></p><h2 id="代理池完整代码"><a href="#代理池完整代码" class="headerlink" title="代理池完整代码"></a><a href="agent_pool">代理池完整代码</a></h2><h4 id="agent-pool-py-整体流程"><a href="#agent-pool-py-整体流程" class="headerlink" title="agent_pool.py 整体流程"></a>agent_pool.py 整体流程</h4><p>存储模块：主要实现的功能是，去一些免费代理网站爬取大量的代理IP，并存储至redis数据库中。redis的Sorted Set结构是一个有序集合，我们会对每一个爬取到的代理IP<br>设置一个初始化的优先级10，Sorted Set也是通过这个优先级来进行排序的。&lt;/br&gt;</p><ul><li>Getter:爬取代理网站的免费代理IP，存入redis</li><li>Tester:从redis中取出代理，测试代理是否可用，并调整代理IP的优先级</li><li>Controller:启动Getter()与Tester()</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Crawler import Crawlerfrom RedisClient import RedisClientimport tracebackimport timeimport requestsimport multiprocessingfrom concurrent import futuresFULL_COUNT &#x3D; 2000class Getter(object):    # 爬取代理网站的免费代理IP，存入redis    def __init__(self):        self.redis_client &#x3D; RedisClient()        self.crawler &#x3D; Crawler()    def is_full(self):        # 判断代理池是否满了        return self.redis_client.get_proxy_count() &gt;&#x3D; FULL_COUNT    def run(self):        # 将爬取到的代理存入redis        if not self.is_full():            proxys &#x3D; self.crawler.get_crawler_proxy()            for proxy in proxys:                self.redis_client.add(proxy)class Tester(object):    # 从redis中取出代理，测试代理是否可用，并调整代理IP的优先级    def __init__(self, test_url):        self.redisdb &#x3D; RedisClient()        # 用来测试代理是否可用的地址        self.test_url &#x3D; test_url    def test_proxy(self, proxy):        try:            if isinstance(proxy, bytes):                proxy &#x3D; proxy.decode(&#39;utf-8&#39;)            proxies &#x3D; &#123;                &#39;http&#39;: &#39;http:&#x2F;&#x2F;&#39; + proxy,                &#39;https&#39;: &#39;https:&#x2F;&#x2F;&#39; + proxy            &#125;            print(&#39;正在检测:&#123;&#125;&#39;.format(proxy))            res &#x3D; requests.get(self.test_url, proxies&#x3D;proxies, timeout&#x3D;10)            if res.status_code &#x3D;&#x3D; 200:                return True, proxy            else:                return False, proxy                # 代理不可用，就降低其优先级        except Exception as e:            return False, proxy            # print(&#39;代理检测异常:&#123;&#125;  &#123;&#125;&#39;.format(proxy, e))            self.redisdb.decrease(proxy)            print(&#39;代理不可用:&#123;&#125;&#39;.format(proxy))    def run(self):        print(&#39;启动检测模块......&#39;)        try:            # 获取redis中所有爬取到的代理            proxies &#x3D; self.redisdb.get_all_proxy()            for i in range(0, len(proxies), 50):                test_proxies &#x3D; proxies[i:i+50]                workers &#x3D; len(test_proxies)                with futures.ThreadPoolExecutor(workers) as executor:                    tasks_res &#x3D; executor.map(self.test_proxy, test_proxies)                    for res, proxy in tasks_res:                        if not res:                            # 代理不可用，就降低其优先级                            self.redisdb.decrease(proxy)                            print(&#39;代理不可用:&#123;&#125;&#39;.format(proxy))                        else:                            # 代理可用,将其优先级置为最大                            self.redisdb.max(proxy)                            print(&#39;代理可用:&#123;&#125;&#39;.format(proxy))        except Exception as e:            print(traceback.format_exc())            print(&#39;检测模块出错！！！&#39;)class Controller(object):    def control_get(self):        # 获取功能：爬取代理网站，将代理存储到redis        getter &#x3D; Getter()        while True:            try:                getter.run()            except:                print(traceback.format_exc())            time.sleep(30)    def control_test(self):        # 检测功能，检测redis中的代理是否可用        tester &#x3D; Tester(test_url&#x3D;&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)        while True:            try:                tester.run()            except:                print(traceback.format_exc())            time.sleep(30)    def run(self):        print(&#39;代理池开始运行了......&#39;)        # 两个进程        get &#x3D; multiprocessing.Process(target&#x3D;self.control_get)        get.start()        test &#x3D; multiprocessing.Process(target&#x3D;self.control_test)        test.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    control &#x3D; Controller()    control.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="WebAPI-to-get-proxy-py-通过flask向外提供获取代理IP的接口"><a href="#WebAPI-to-get-proxy-py-通过flask向外提供获取代理IP的接口" class="headerlink" title="WebAPI_to_get_proxy.py 通过flask向外提供获取代理IP的接口"></a>WebAPI_to_get_proxy.py 通过flask向外提供获取代理IP的接口</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, gimport RedisClient&quot;&quot;&quot;    对外提供web接口，通过提供的web接口，来获取redis中的代理    g是上下文对象，处理请求时，用于临时存储的对象，每次请求都会重设这个变量。比如：我们可以获取一些临时请求的用户信息。&quot;&quot;&quot;app &#x3D; Flask(__name__)@app.route(&#39;&#x2F;&#39;)def index():    return &#39;&lt;h2&gt;欢迎来到daacheng代理池系统&lt;&#x2F;h2&gt;&#39;def get():    if not hasattr(g, &#39;redis&#39;):        g.redis &#x3D; RedisClient.RedisClient()    return g.redis@app.route(&#39;&#x2F;random&#39;)def get_random_proxy():    # 从代理池中返回一个代理    redisdb &#x3D; get()    return redisdb.get_proxy()@app.route(&#39;&#x2F;count&#39;)def count():    # 查询代理池中代理的个数    redisdb &#x3D; get()    return str(redisdb.get_proxy_count())@app.route(&#39;&#x2F;all&#39;)def get_all():    # 查询代理池中代理的个数    redisdb &#x3D; get()    return str(redisdb.get_all_proxy())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;5000)    app.debug &#x3D; True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">爬虫概念，requests库,BeautifulSoup库，selenium自动化，xpath解析，代理池维护</summary>
    
    
    
    <category term="爬虫" scheme="https://changqingaas.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>jupyter_notebook常用插件介绍</title>
    <link href="https://changqingaas.github.io/others/jupyter-notebook/jupyter-notebook%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://changqingaas.github.io/others/jupyter-notebook/jupyter-notebook%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-08-12T11:08:12.000Z</published>
    <updated>2021-08-12T11:24:49.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jupyter-NbExtensions-Configurator"><a href="#Jupyter-NbExtensions-Configurator" class="headerlink" title="Jupyter NbExtensions Configurator"></a>Jupyter NbExtensions Configurator</h2><p>Jupyter NbExtensions Configurator 是Jupyter Notebook的一个扩展工具，它提供了一系列标签，只需勾选相应插件就能自动载入。里面的插件能帮助减少工作量，书写更优雅的代码和更好的展示结构。</p><h3 id="安装Jupyter-NbExtensions-Configurator"><a href="#安装Jupyter-NbExtensions-Configurator" class="headerlink" title="安装Jupyter NbExtensions Configurator"></a>安装Jupyter NbExtensions Configurator</h3><p>用pip安装（conda应该同理）</p><p>Note:最好在关了jupyter的时候安装，不过问题不大</p><pre class="line-numbers language-none"><code class="language-none">pip install jupyter_nbextensions_configurator --userpip install jupyter_contrib_nbextensions --userjupyter contrib nbextension install --userjupyter nbextensions_configurator enable --user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装完毕，进入Jupyter Notebook，在主界面会多出一个NbExtensions的标签，里面有很多插件可供选择，示意图如下：</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925203501494-1338913967.png" alt="img"></p><p> 下面会重点介绍几个插件的用法，其余的不详细介绍，有兴趣的可以到官网（<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html）自行了解。">https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html）自行了解。</a></p><h3 id="Hinterland"><a href="#Hinterland" class="headerlink" title="Hinterland"></a>Hinterland</h3><p>勾选此插件为代码单元格中的每次按键启用“代码自动补全”菜单，而不是仅用Tab键时启用。</p><h3 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h3><p>这个插件会根据Markdown的标题层次形成一个目录，可以通过点击目录，直接定位到对应代码位置，在长代码文件中能起到导航的作用。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925205908910-259935432.png" alt="img"></p><p> 开启插件后，会在工具栏多出一个按钮，可通过点击按钮选择是否开启（如上图），官方示例如下</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925205346881-634502374.gif" alt="img"></p><h3 id="Snippets-Menu"><a href="#Snippets-Menu" class="headerlink" title="Snippets Menu"></a>Snippets Menu</h3><p>向Jupyter笔记本添加可定制的菜单项，以插入代码片段、样板文件和示例。</p><p>勾选此插件后，会多出一个Snippets的菜单项，菜单里包含多个模块的示例，通过简单的点击就能生成示例代码，可根据自己的需求稍作修改即可运行，减少代码工作量。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925210916560-990218179.png" alt="img"></p><h3 id="Codefolding"><a href="#Codefolding" class="headerlink" title="Codefolding"></a>Codefolding</h3><p>这个扩展将代码折叠功能从CodeMirror添加到codecell。</p><p>在编辑模式下，单击边距中的三角形(codecell的左边缘)或键入代码折叠热键(默认为Alt+F)，折叠代码。在命令模式下，折叠热键与编解码器的第一行有关。</p><p>折叠前：</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925211705294-581239589.png" alt="img"></p><p>折叠后是这样：</p><p> <img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925211802722-968013526.png" alt="img"></p><p>或者是这样：</p><p> <img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925211812161-1047071957.png" alt="img"></p><h3 id="Scratchpad-没添加"><a href="#Scratchpad-没添加" class="headerlink" title="Scratchpad(没添加)"></a>Scratchpad(没添加)</h3><p>为Jupyter Notebook提供一个草稿cell，方便随时测试输出。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925213326635-1759656941.gif" alt="img"></p><h3 id="Notify（没添加"><a href="#Notify（没添加" class="headerlink" title="Notify（没添加"></a>Notify（没添加</h3><p>在内核繁忙一段时间后再次空闲时显示一个浏览器通知——繁忙0、5、10或30秒后可配置。</p><p>这个插件功能在你需要长时间跑一个代码时可启用，无需在页面等待，程序运行完成后，会弹出通知。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925214041517-1148926022.png" alt="img"></p><h3 id="Collapsible-Headings"><a href="#Collapsible-Headings" class="headerlink" title="Collapsible Headings"></a>Collapsible Headings</h3><p>允许notebook有可折叠的部分，以标题分开。</p><p>任何标记标题单元格(即以1-6 #字符开头的单元格)在呈现后都是可折叠的。</p><p>标题的折叠/扩展状态存储在单元格元数据中，并在笔记本加载时重新加载。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925214559004-2102669271.png" alt="img"></p><h3 id="Variableinspector（没添加"><a href="#Variableinspector（没添加" class="headerlink" title="Variableinspector（没添加"></a>Variableinspector（没添加</h3><p>Variableinspector（变量检查器）显示我们在Notebook中创建的所有变量的名称，以及它们的类型、大小、形状和值。如下图所示：</p><p><img src="https://pic3.zhimg.com/v2-afebf774b1d9e9869b78c218c57e319e_r.jpg" alt="img"></p><p>这个工具对于从RStudio迁移来的项目来说是非常宝贵的。或是当我们不想继续打印df.shape、无法回忆x的类型时，Variableinspector将变得非常有用。</p><p>如果有其他用到的插件会继续添加</p>]]></content>
    
    
    <summary type="html">记录一下自己用的插件，以免忘记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于marp-theme-for-tju的探索</title>
    <link href="https://changqingaas.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/marp/%E5%85%B3%E4%BA%8Emarp-theme-for-tju%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://changqingaas.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/marp/%E5%85%B3%E4%BA%8Emarp-theme-for-tju%E7%9A%84%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-08-10T12:45:02.000Z</published>
    <updated>2022-01-17T01:24:00.589Z</updated>
    
    <content type="html"><![CDATA[<p>事情的起因是，我无意间了解到marp，然后在github看到这样一个主题：<a href="https://github.com/chenyang1999/Marp_theme_for_THUslides">Marp_theme_for_THUslides</a>，于是我就想给本校做一个类似的主题，方便开组会时使用</p><p>但是经过很多尝试，我发现我的一些想法并不能实现，于是我暂时搁置，在解决这个需求的过程中，总结了一些marp的主题，主要是自用。</p><p>为了不让自己的时间白白浪费，我把自己有价值的一部分work，放到网络上，希望为后面探索的人节省时间。</p><p>放弃做marp-theme-tjuslides的主要原因就是：图片不能透明插入，会自动补白，这是我向rgb背景图插入透明校徽图的情况：</p><p><img src="https://raw.githubusercontent.com/ChangQingAAS/for_picgo/main/img/20210810203724.png" alt="image-20210810202422699" style="zoom: 67%;" /></p><p>这意味着，我使用的theme的颜色是受到限制的，一旦我使用别人的主题时，如果要加入相关元素就要自己改颜色。</p><p>或者我可以直接来几张背景图（不过这种情况下，由于一些遮拦，直接引用别人的样式文件可能会出问题，就需要花费时间调整一些样式语句了，）。虽然我觉得这样不够meaningful，但是我还是做了，毕竟也是用的上的，我用一些天大ppt,在<a href="https://github.com/ChangQingAAS/marp-themes/tree/main/tju-images">这里</a>整理了一些天大PPT背景图。</p><h2 id="我常用的样式："><a href="#我常用的样式：" class="headerlink" title="我常用的样式："></a>我常用的样式：</h2><hr><pre class="line-numbers language-none"><code class="language-none">---marp: true# 主题theme: default# 标题title: TCP协议设计# 页码，出现在右下角paginate: True # 版本version: 1.0.0 # 页脚# footer: # 页眉header: # 大小，也可以写16:9size: 4K---&lt;style&gt;    section&#123;       background-image:url(&#39;.&#x2F;tju-images&#x2F;tju0.png&#39;);        background-size:cover;        position: absolute;      &#125;    section h1 &#123;font-size:40px;color:black;margin-top:px;&#125;    section h2 &#123;font-size:30px;color:black;margin-top:px;&#125;    section p &#123;font-size: 25px;color:black;&#125;    section table &#123;text-align: center;font-size: 32px;color:black;&#125;    section a &#123;font-size: 25px;color:black;&#125;    li &#123;font-size: 30px;text-align: left;&#125;    img &#123;        margin-left: auto;         margin-right:auto;         display:block;        margin:0 auto;        width:25cm;      &#125;&lt;&#x2F;style&gt;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正式使用了一次，ppt做出来是图片，啥都不能动，真的难顶。</p><p>感觉不适合多人协作</p>]]></content>
    
    
    <summary type="html">关于探索marp-theme-for-tju的经历</summary>
    
    
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="marp" scheme="https://changqingaas.github.io/tags/marp/"/>
    
    <category term="折腾" scheme="https://changqingaas.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>用Markdown制作幻灯片:Marp</title>
    <link href="https://changqingaas.github.io/%E6%95%99%E7%A8%8B/marp/%E7%94%A8Markdown%E5%88%B6%E4%BD%9C%E5%B9%BB%E7%81%AF%E7%89%87-Marp/"/>
    <id>https://changqingaas.github.io/%E6%95%99%E7%A8%8B/marp/%E7%94%A8Markdown%E5%88%B6%E4%BD%9C%E5%B9%BB%E7%81%AF%E7%89%87-Marp/</id>
    <published>2021-08-10T01:07:07.000Z</published>
    <updated>2021-08-18T09:02:26.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>本文对以下链接进行了整理：</p><ul><li><a href="https://www.lianxh.cn/news/97fccdca2d7a5.html">用Markdown制作幻灯片-五分钟学会Marp（上篇）-M110a| 连享会主页 (lianxh.cn)</a></li><li><a href="https://www.lianxh.cn/news/521900220dd33.html">用Markdown制作幻灯片-五分钟学会Marp（下篇）-M110b| 连享会主页 (lianxh.cn)</a></li><li><a href="https://www.mina.moe/archives/11046">【教程】你在用 Marp 时可能会用的语法 ——litble – MiNa!</a></li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>​    在 Microsoft PowerPoint 里面，我们需要调整幻灯片的格式，操作起来些许麻烦。幻灯片通常是辅助演讲者的一个工具，这也是说，幻灯片不需要制作太复杂，简洁美观即可 </p><p>​    Markdown 文字排版高效，且风格简洁美观，是许多写作者的不二之选。而多数场景中， Markdown 的这种特点对幻灯片的制作也很合适。</p><p>​    那么，我们是否可以使用 Markdown 高效地制作一个漂亮的幻灯片？</p><p>​    答案就是：makedown + marp（based on vscode)</p><p>注：</p><ul><li><p>基于Markdown语法,复制黏贴笔记—-&gt;ppt/pdf/html/png</p></li><li><p>PPT 里面需要的各种文字效果可以用html,css,js等解决</p></li><li><p>可以用 latex直接写数学公式</p></li><li><p>可以画表格等(markdown 语法)  </p></li><li><p>可以直接插入 Emoji</p></li><li><p>在弹出保存页面时，可以自己选保存的格式</p></li></ul><h2 id="2-下载与安装"><a href="#2-下载与安装" class="headerlink" title="2.下载与安装"></a>2.下载与安装</h2><h3 id="vscode的安装方式"><a href="#vscode的安装方式" class="headerlink" title="vscode的安装方式"></a>vscode的安装方式</h3><p>在VS Code下载插件：marp for VS code 和 markdown  all in one</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig6_%20Marp%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><h3 id="其他安装方式"><a href="#其他安装方式" class="headerlink" title="其他安装方式"></a>其他安装方式</h3><p>还可以通过npm 安装 marp,读者可以自行探索</p><p>（不过在生成相关文件时，需要做一些命令行，vscode版的基本通过图形界面就可以解决）</p><h2 id="3-操作流程"><a href="#3-操作流程" class="headerlink" title="3.操作流程"></a>3.操作流程</h2><h3 id="3-1-新建文件"><a href="#3-1-新建文件" class="headerlink" title="3.1 新建文件"></a>3.1 新建文件</h3><p>打开 VS Code ，点击<code>文件-&gt;新建文件</code>，将其存为 <code>.md</code> 文件。此时，我们就创建好一个 Markdown 文档。</p><h3 id="3-2-幻灯片分页"><a href="#3-2-幻灯片分页" class="headerlink" title="3.2 幻灯片分页"></a>3.2 幻灯片分页</h3><p>首先，我们需要在 Markdown 文档开头标记 <code>marp: true</code>，以启用 Marp 功能。也就是告诉编辑器，你要制作的是幻灯片（Slide）。</p><p><strong>需要说明的有两点：</strong></p><ul><li>其一，<code>marp: true</code> 语句中的冒号为半角模式下录入的；上下的 <code>---</code> 不可省略；</li><li>其二，新建的 Markdown 文档也可以不做上述标记，通过点击菜单条中的 Marp 图标即可自动添加。具体步骤为：依次点击 <code>Marp 图标</code> → <code>Toggle Marp feature for current Markdown ( markdown.marp.toggleMarpFeature )</code>，软件会自动在文档开头添加 <code>marp: true</code>。如下图所示：</li></ul><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20210602233115.png" alt="img"></p><p>文字信息如下：</p><pre class="line-numbers language-none"><code class="language-none">---marp: true---# Your slide deckStart writing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>幻灯片通常有多个页面，那么该如何分页？</strong></p><p>Markdown 通常用<code>---</code>作为水平分割线，而 Marp 则用 <code>---</code> 表示「分页符」，即用以「分割幻灯片」（Slide）。</p><p><em>演示效果如下：</em></p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig9_%20%E5%88%86%E9%9A%94%E7%AC%A6_%E5%AE%8B%E6%A3%AE%E5%AE%89.gif" alt="img"></p><h3 id="3-3-幻灯片预览"><a href="#3-3-幻灯片预览" class="headerlink" title="3.3 幻灯片预览"></a>3.3 幻灯片预览</h3><p>点击 Marp 图标的右侧，我们就可以在 VS Code 编辑器的右侧实时预览幻灯片。</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig10_%20%E9%A2%84%E8%A7%88_%E5%AE%8B%E6%A3%AE%E5%AE%89.gif" alt="img"></p><h3 id="3-4-导出幻灯片"><a href="#3-4-导出幻灯片" class="headerlink" title="3.4 导出幻灯片"></a>3.4 导出幻灯片</h3><p>点击 <code>Marp 图标-&gt; Export slide deck ....( markdown.marp.export )</code>即可导出文件。</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig10_%20Marp%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p>目前，<strong>Marp</strong> 可导出四种格式的文件：</p><ul><li><strong>HTML</strong></li><li><strong>PDF</strong></li><li><strong>PPTX</strong> (幻灯片)</li><li><strong>PNG</strong> (仅限于幻灯片的第一页)</li><li><strong>JPEG</strong> (仅限于幻灯片的第一页)</li></ul><p>需要注意的是：</p><ul><li><p>导出 <strong>HTML</strong> 格式的文档不需要安装任何插件，也可以很方便地转换为 PDF 格式。</p><ul><li>HTML 格式的幻灯片双击即可用默认浏览器打开，亦可右击文件，选择特定的浏览器打开 (建议用 Google 浏览器打开)。</li><li>展示时建议采用全屏播放模式：按快捷键 <strong>F11</strong> 即可；再次按下 <strong>F11</strong> 即可退出全屏。</li><li>用 Google 浏览器打开后，按快捷键 <strong>Ctrl+P</strong>，并选择「另存为 PDF」，即可把 HTML 格式的幻灯片转换为 PDF 格式。</li></ul></li><li><p>若需导出 PDF 和 PPTX 格式，可能需要安装 <code>pandoc</code></p></li></ul><h2 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h2><p>仅靠 Markdown 制作出的幻灯片格式可能会比较单调。为了制作出更加漂亮的幻灯片，我们还需要学习一种被称之为 <strong>指令（Directives）</strong> 的扩展语法。例如，指令 <code>theme</code> 可改变幻灯片的主题，<code>paginate</code> 可显示出幻灯片的页码，<code>footer</code> 用于设置幻灯片的页脚内容， <code>size</code> 可调整幻灯片的大小， <code>backgroundColor</code> 用于变换幻灯片的背景颜色等。</p><h3 id="4-1-指令的使用方法"><a href="#4-1-指令的使用方法" class="headerlink" title="4.1 指令的使用方法"></a>4.1 指令的使用方法</h3><p><strong>那么，如何使用这些指令呢？</strong></p><p>Marp 提供两种使用方法：</p><ul><li><p><strong>HTML comment</strong></p><p>这种需要在 <code>theme</code> 等指令前后添加<code>&lt;!-- --&gt;</code>。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--theme: defaultpaginate: true--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Front-matter</strong></p><p>第二种则是直接写在 Markdown 文档的开头（就是将指令和 <code>marp: ture</code> 写一块），此时无须再添加<code>&lt;!-- --&gt;</code>。</p><pre class="line-numbers language-none"><code class="language-none">---marp: turetheme: defaultpaginate: true---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p> </p><h3 id="4-2-指令类型"><a href="#4-2-指令类型" class="headerlink" title="4.2 指令类型"></a>4.2 指令类型</h3><p>指令类型（ Type of directives ）可分为全局指令（ Global directives ）和局部指令（ Local directives ），有点类似于 Stata 中的宏。</p><p>其中，全局指令是整个幻灯片设定值，例如 <code>theme</code>、<code>headingDivider</code>、<code>style</code>。在全局指令前面添加前缀 <code>$</code>，就可以实现对整个幻灯片的设定。</p><p>而<strong>局部指令用以设置当前幻灯片页面以及后续页面</strong>。例如，我们用<code>&lt;!-- backgroundColor: aqua --&gt;</code> 设置幻灯片的背景颜色。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- backgroundColor: aqua --&gt;This page has aqua background.---The second page also has same color.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>幻灯片演示效果如下：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig17_%20%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p>当然，如果您只想将局部指令应用于当前页面，则需要指令前添加前缀 <code>_</code> 。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- _backgroundColor: aqua --&gt;Add underscore prefix &#96;_&#96; to the name of local directives.---The second page would not apply setting of directives.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比上下两图，可以明显地看出两者之间的差异。</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig18_%20%E5%B1%80%E9%83%A8%E6%8C%87%E4%BB%A4_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><h3 id="4-3-标题分隔符"><a href="#4-3-标题分隔符" class="headerlink" title="4.3 标题分隔符"></a>4.3 标题分隔符</h3><p>除了页面分割符<code>---</code>，如果文章结构比较清晰，我们还可以使用全局指令 <code>headingDivider</code> 分隔幻灯片页面。换句话说，就是 <code>headingDivider</code> 通过识别 Markdown 文档的标题来实现幻灯片分页。</p><p>例如，下面两个 Markdown 文档具有相同的输出。</p><p>一般语法如下：</p><pre class="line-numbers language-none"><code class="language-none"># 1st pageThe content of 1st page---## 2nd page### The content of 2nd pageHello, world!---# 3rd pageThanks <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Heading Divider 如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- headingDivider: 2 --&gt;# 1st pageThe content of 1st page## 2nd page### The content of 2nd pageHello, world!# 3rd pageThanks <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>个人认为用处不大</p><h3 id="4-4-页码"><a href="#4-4-页码" class="headerlink" title="4.4 页码"></a>4.4 页码</h3><p>局部命令 <code>paginate</code> 用于显示幻灯片的页码。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- paginate: true --&gt;You would be able to see a page number of slide in the lower right.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，如果我们不想在标题页面出现页码，只需将指令 <code>paginate</code> 移到第二页即可。</p><pre class="line-numbers language-none"><code class="language-none"># Title slideThis page will not paginate by lack of &#96;paginate&#96; local directive.---&lt;!-- paginate: true --&gt;It will paginate slide from a this page.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加页码：<code>&lt;!-- page_number: true --&gt;</code>，取消页码：<code>&lt;!-- page_number:false --&gt;</code>，这个也是，加<code>*</code>表示只对某一页操作</p><h3 id="4-5-页眉和页脚"><a href="#4-5-页眉和页脚" class="headerlink" title="4.5 页眉和页脚"></a>4.5 页眉和页脚</h3><p>当需要在多张幻灯片中显示相同的页眉或页脚时，可将局部指令 <code>header</code>或 <code>footer</code> 写在 Markdown 文档的最前面。</p><pre class="line-numbers language-none"><code class="language-none">---marp: trueheader: &#39;Stata连享会&#39;footer: 连享会 · [直播间](http:&#x2F;&#x2F;lianxh.duanshu.com) &amp;emsp;  | &amp;emsp;  lianxh.cn &amp;emsp; | &amp;emsp;  [课程主页](https:&#x2F;&#x2F;lianxh.duanshu.com&#x2F;#&#x2F;brief&#x2F;course&#x2F;c3f79a0395a84d2f868d3502c348eafc) &amp;emsp; | &amp;emsp;  [课程展示](https:&#x2F;&#x2F;gitee.com&#x2F;arlionn&#x2F;p101)---# VS Code + Marp : 用 Markdown 制作幻灯片##### 作者:宋森安 (西南财经大学)；张家豪(西北大学)##### 邮箱: songsean@88.com--- ### 文章目录- #### 一、前言- #### 二、下载与安装- #### 三、操作教程- #### 四、讨论- #### 五、参考资料- #### 六、相关推文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述 Markdown 文档改动自 <strong><a href="https://gitee.com/arlionn/md/wikis/Marp - 用 Markdown 写幻灯片.md?sort_id=1987882">连玉君老师的幻灯片</a></strong>，其演示效果如下图：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig27_%20%E9%A1%B5%E8%84%9A_%E5%AE%8B%E6%A3%AE%E5%AE%89.gif" alt="img"></p><p>添加页脚：<code>&lt;!-- footer: 页脚内容 --&gt;</code>，如果写为<code>&lt;!-- *footer: 页脚内容 --&gt;</code>，就是仅本页添加页脚。<code>&lt;!-- footer: --&gt;</code> 就相当于取消页脚</p><h3 id="4-6页面大小"><a href="#4-6页面大小" class="headerlink" title="4.6页面大小"></a>4.6页面大小</h3><p>写上类似这种：<code>&lt;!-- $size: 16:9 --&gt;</code>，可以调节 PPT 尺寸。</p><h3 id="4-7-summary"><a href="#4-7-summary" class="headerlink" title="4.7 summary"></a>4.7 summary</h3><p>下面是我的日常使用</p><pre class="line-numbers language-none"><code class="language-none">---marp: true# 主题theme: nord# 标题title: 我是标题# 页码，出现在右下角paginate: True # 版本version: 1.0.0 # 页脚footer: 我是页脚# 页眉header: 我是页眉# 大小，也可以写16:9size: 4K# 类别,原理应该就是样式的叠加，这部分我不太清楚，读者可以自行探索class:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-主题风格"><a href="#5-主题风格" class="headerlink" title="5. 主题风格"></a>5. 主题风格</h2><h3 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h3><p>目前，Marp 提供 <strong>Default (书页黄)、Gaia(海蓝) 和 uncover</strong> 三种主题风格。</p><p>下面笔者简单演示这三种主题风格：</p><pre class="line-numbers language-none"><code class="language-none">---marp: true---&lt;!-- theme: Default--&gt;## &lt;!-- fit --&gt; VS Code + Marp: 用 Markdown 制作幻灯片### 来源：Stata 连享会### 作者：宋森安(西南财经大学); 张家豪(西北大学)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注释：<code>&lt;!-- fit --&gt;</code> 用于自动调整标题（一级标题）大小，以适应幻灯片大小。</p></blockquote><p>Default 主题风格的演示效果如下：</p><p><img src="https://www.mina.moe/wp-content/uploads/2019/01/TIM%E5%9B%BE%E7%89%8720190118110508.png" alt="default"></p><p>将<code>&lt;!-- theme: Default--&gt;</code>更换为<code>&lt;!-- theme: Gaia--&gt;</code>，幻灯片演示风格就变成下图：</p><p><img src="https://www.mina.moe/wp-content/uploads/2019/01/TIM%E5%9B%BE%E7%89%8720190118110629.png" alt="gaia"></p><p>可以发现，在 Gaia 主题背景下，幻灯片的内容会对齐到左上方。但是我们可以使用 <code>class: lead</code> 来改变。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--theme: gaiaclass: lead--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>添加 <code>class: lead</code> 后，幻灯片的演示效果如下：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig13_%20%E9%A3%8E%E6%A0%BC3_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p>Uncover 主题风格演示效果如下：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig16_%20%E9%A3%8E%E6%A0%BC4_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><h3 id="添加新的主题"><a href="#添加新的主题" class="headerlink" title="添加新的主题"></a>添加新的主题</h3><p>在./vscode/settings.json中，把css主题样式文件加入路径：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;markdown.marp.themes&quot;: [    &quot;https:&#x2F;&#x2F;tapioca24.github.io&#x2F;marp-themes&#x2F;tapioca24.css&quot;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路径可以是网络地址，也可以是本地地址（最好是你的marp项目所在地址</p><h3 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h3><ul><li><p>引用一种主题：<code>&lt;!-- $theme: gaia --&gt;</code></p></li><li><p>在使用了 gaia 主题后，写上：<code>&lt;!-- template: invert --&gt;</code> 后，所有 PPT 默认使用 invert 背景色。</p></li><li><p>在某一页写上<code>&lt;!-- *template: invert --&gt;</code> 后，仅这一页 PPT 用 invert（<code>*</code>就是仅这一页使用的意思）。</p></li><li><p>或者直接在header，使用指令直接指定全局主题。（可通过指定某一页的主题来屏蔽全局主题）</p><pre class="line-numbers language-none"><code class="language-none">---marp: truetheme: tapioca24---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="6-图片语法"><a href="#6-图片语法" class="headerlink" title="6. 图片语法"></a>6. 图片语法</h2><p>图片语法句式为 <code>![](image.jpg)</code>。其中，<code>[keywords]</code> 用于设置幻灯片的尺寸、颜色等参数，<code>(image.jpg)</code>是图片地址。</p><p>插入图片的语法：<code>![](图片路径)</code> 路径可以是本机路径也可以是http路径</p><h3 id="6-1-调整图片大小"><a href="#6-1-调整图片大小" class="headerlink" title="6.1 调整图片大小"></a>6.1 调整图片大小</h3><p>在<code>[keywords]</code>中添加 <code>width</code> 、 <code>height</code> 等关键词调整图片的大小。</p><pre class="line-numbers language-none"><code class="language-none">![width:200px](image.jpg) &lt;!-- Setting width to 200px --&gt;![height:30cm](image.jpg) &lt;!-- Setting height to 300px --&gt;![width:200px height:30cm](image.jpg) &lt;!-- Setting both lengths --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里也可以使用关键词的缩写 <code>w</code> 和 <code>h</code> ：</p><pre class="line-numbers language-none"><code class="language-none">![w:32 h:32](image.jpg) &lt;!-- Setting size to 32x32 px --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <code>![缩放比例（如 200%)](图片路径)</code>：图片缩放后插入 PPT 中</p><h3 id="6-2-图片滤镜"><a href="#6-2-图片滤镜" class="headerlink" title="6.2 图片滤镜"></a>6.2 图片滤镜</h3><p>Marp 还支持将 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter">CSS filters</a> 应用于图片语法，替换<code>[keywords]</code>中的内容，可对图片进行渲染。例如，<code>![blur:10px]()</code>、<code>![brightness:1.5]()</code> 、 <code>![contrast:200%]()</code>、<code>![saturate:2.0]()</code>、<code>![sepia:1.0]()</code>等指令。当省略括号内的参数时，软件会直接使用默认参数。</p><p>当然，我们可以将多个滤镜应用于图片。</p><pre class="line-numbers language-none"><code class="language-none">![brightness:.8 sepia:50%](https:&#x2F;&#x2F;fig-lianxh.oss-cn-shenzhen.aliyuncs.com&#x2F;Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig20_%20%E8%A5%BF%E5%8D%97%E8%B4%A2%E7%BB%8F%E5%A4%A7%E5%AD%A6_%E5%AE%8B%E6%A3%AE%E5%AE%89.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，笔者使用 <code>![brightness:.8 sepia:50%](https://example.com/image.jpg)</code>，原图就被渲染成深褐色。</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig21_%20%E8%A5%BF%E5%8D%97%E8%B4%A2%E7%BB%8F%E5%A4%A7%E5%AD%A6_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p> </p><h3 id="6-3-幻灯片背景"><a href="#6-3-幻灯片背景" class="headerlink" title="6.3 幻灯片背景"></a>6.3 幻灯片背景</h3><p>关键词 <code>bg</code> 可设置幻灯片的背景，具体句式为：<code>![bg](https://example.com/background.jpg)</code>。</p><p>此外，我们可在 <code>bg</code> 后添加关键词选项，用于调整背景图片的尺寸。</p><p>例如，<code>![bg cover](image.jpg)</code>（缩放图像以填充幻灯片，这也是默认图片设置） 、 <code>![bg contain](image.jpg)</code> （缩放图像以适应幻灯片） 、 <code>![bg auto](image.jpg)</code>（不缩放图像，并使用原始大小） 、 <code>![bg 150%](image.jpg)</code>（按照指定百分比缩放）。</p><p> 若一页 PPT 内插入多张背景图片，它们会并列分布</p><p>也可使用这样的语法定义幻灯片背景</p><pre class="line-numbers language-none"><code class="language-none">&lt;style scoped&gt;section&#123;  background-image:url(&#39;.&#x2F;tju-images&#x2F;tju1.png&#39;);  background-size:cover;  position: absolute;  &#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-高级背景"><a href="#6-4-高级背景" class="headerlink" title="6.4 高级背景"></a>6.4 高级背景</h3><p>我们还可以通过高级背景来实现多重背景、背景拆分，甚至通过图片滤镜来设置幻灯片背景。</p><pre class="line-numbers language-none"><code class="language-none">![bg](https:&#x2F;&#x2F;fakeimg.pl&#x2F;800x600&#x2F;0288d1&#x2F;fff&#x2F;?text&#x3D;A)![bg](https:&#x2F;&#x2F;fakeimg.pl&#x2F;800x600&#x2F;02669d&#x2F;fff&#x2F;?text&#x3D;B)![bg](https:&#x2F;&#x2F;fakeimg.pl&#x2F;800x600&#x2F;67b8e3&#x2F;fff&#x2F;?text&#x3D;C)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注释：背景图片由网站 <a href="https://fakeimg.pl/">fakeimg.pl</a> 自动生成的<strong>假图片</strong>，改变 <code>text=</code> 后的内容，图片文字随之改变。</p></blockquote><p>多重背景图的演示效果如下：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig14_%20%E8%83%8C%E6%99%AF1_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">![bg vertical](https:&#x2F;&#x2F;fakeimg.pl&#x2F;800x600&#x2F;0288d1&#x2F;fff&#x2F;?text&#x3D;A)![bg](https:&#x2F;&#x2F;fakeimg.pl&#x2F;800x600&#x2F;02669d&#x2F;fff&#x2F;?text&#x3D;B)![bg](https:&#x2F;&#x2F;fakeimg.pl&#x2F;800x600&#x2F;67b8e3&#x2F;fff&#x2F;?text&#x3D;C)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 <code>bg</code> 后加入 <code>vertical</code> 后，背景图片就会垂直排列，幻灯片演示效果如下图：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig15_%20%E8%83%8C%E6%99%AF2_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p>在 <code>bg</code> 右侧添加 <code>left</code> 或 <code>right</code> 可设置背景图的位置。添加 <code>left</code> 或 <code>right</code> 后，幻灯片内容所占的空间也会减小一半。</p><pre class="line-numbers language-none"><code class="language-none">---marp: true---![bg left](https:&#x2F;&#x2F;fig-lianxh.oss-cn-shenzhen.aliyuncs.com&#x2F;Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig20_%20%E8%A5%BF%E5%8D%97%E8%B4%A2%E7%BB%8F%E5%A4%A7%E5%AD%A6_%E5%AE%8B%E6%A3%AE%E5%AE%89.jpg)&lt;!-- color: black--&gt;# 欢迎报考 西北大学<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拆分背景的演示效果如下图：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig22_%20%E5%88%86%E6%8B%86%E8%83%8C%E6%99%AF1_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p>我们也可以将多张图片固定在一侧。</p><p>文本信息如下：</p><pre class="line-numbers language-none"><code class="language-none">---marp: true---![bg right](https:&#x2F;&#x2F;fig-lianxh.oss-cn-shenzhen.aliyuncs.com&#x2F;Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig20_%20%E8%A5%BF%E5%8D%97%E8%B4%A2%E7%BB%8F%E5%A4%A7%E5%AD%A6_%E5%AE%8B%E6%A3%AE%E5%AE%89.jpg)![bg](https:&#x2F;&#x2F;fig-lianxh.oss-cn-shenzhen.aliyuncs.com&#x2F;Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig20_%20%E8%A5%BF%E5%8D%97%E8%B4%A2%E7%BB%8F%E5%A4%A7%E5%AD%A6_%E5%AE%8B%E6%A3%AE%E5%AE%89.jpg)&lt;!-- color: black--&gt;# 欢迎报考 ##  西北大学、西南财经大学<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>幻灯片演示效果如下图：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig23_%20%E5%88%86%E6%8B%86%E8%83%8C%E6%99%AF2_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><p>除了通过图片设置背景外，Marp 也支持设定颜色参数来改变幻灯片背景。背景颜色的基本句式为 <code>![bg](颜色参数)</code> ，文字颜色的基本句式为 <code>![](颜色参数)</code>。如下图所示：</p><p><img src="https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Marp%E5%88%9B%E5%BB%BA%E5%B9%BB%E7%81%AF%E7%89%87_Fig24_%20%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE_%E5%AE%8B%E6%A3%AE%E5%AE%89.png" alt="img"></p><h2 id="7-一些技巧"><a href="#7-一些技巧" class="headerlink" title="7.一些技巧"></a>7.一些技巧</h2><h3 id="from-tapioca24"><a href="#from-tapioca24" class="headerlink" title="from tapioca24"></a>from <a href="https://github.com/tapioca24">tapioca24</a></h3><p>There are several utility classes that can be used to enrich the presentation of slides.</p><div class="table-container"><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td><code>text-center</code></td><td>Align all content to the center.</td></tr><tr><td><code>text-&lt;size&gt;</code></td><td>Increase the font size. The <code>size</code> can be specified in intervals of 25 from 125 to 1000.</td></tr></tbody></table></div><p>Give the class to only the desired page by writing the following in the slide.</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- _class: text-center text-125 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://sspai.com/post/55718">Marp：用 Markdown「写」PPT 的新选择 - 少数派 (sspai.com)</a></li><li><a href="https://marpit.marp.app/"><strong>Marpit</strong>: Markdown slide deck framework</a></li><li><a href="https://marp.app/"><strong>Marp</strong>: Markdown Presentation Ecosystem</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=marp-team.marp-vscode"><strong>Marp for VS Code</strong> - Visual Studio Marketplace</a></li><li><a href="https://github.com/marp-team/marp-vscode"><strong>GitHub - Marp for VS Code</strong>: Create slide deck written in Marp Markdown on VS Code</a></li><li><a href="https://fakeimg.pl/"><strong>fakeimg.pl</strong></a></li><li><strong><a href="https://gitee.com/arlionn/md">连享会 Markdown 仓库</a></strong></li></ul><p> </p><h2 id="相关推文"><a href="#相关推文" class="headerlink" title="相关推文"></a>相关推文</h2><ul><li>专题：<a href="https://www.lianxh.cn/blogs/30.html">Markdown</a><ul><li><a href="https://www.lianxh.cn/news/03ff18d8a9957.html">Markdown：五分钟Markdown教程</a></li><li><a href="https://www.lianxh.cn/news/845d7f5a2d977.html">Markdown教程之LaTeX数学公式简介</a></li><li><a href="https://www.lianxh.cn/news/6dfbbaefbb2d5.html">Markdown：一键将-Word-转换为-Markdown</a></li><li><a href="https://www.lianxh.cn/news/e3116b7e22ff8.html">Markdown-图床</a></li><li><a href="https://www.lianxh.cn/news/554f3e9c9f08d.html">Markdown常用LaTex数学公式</a></li><li><a href="https://www.lianxh.cn/news/dbbd90d8b96ac.html">连玉君Markdown笔记</a></li><li><a href="https://www.lianxh.cn/news/c061d6b77c6aa.html">Markdown中书写LaTeX数学公式简介</a></li><li><a href="https://www.lianxh.cn/news/61836b4326f32.html">在 Markdown 中使用表情符号</a></li><li><a href="https://www.lianxh.cn/news/1be9d1ba1a023.html">在 Markdown 中使用表情符号</a></li><li><a href="https://www.lianxh.cn/news/054fd41922063.html">mdnice.cn——Markdown、知乎、公众号排版神器</a></li><li><a href="https://www.lianxh.cn/news/b37f5fac84457.html">两种网页转Markdown的简便方法</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">用Markdown制作幻灯片-marp</summary>
    
    
    
    <category term="教程" scheme="https://changqingaas.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="折腾" scheme="https://changqingaas.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="markdown" scheme="https://changqingaas.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
