<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>常青的小屋</title>
  
  <subtitle>劫回落山的太阳</subtitle>
  <link href="https://changqingaas.github.io/atom.xml" rel="self"/>
  
  <link href="https://changqingaas.github.io/"/>
  <updated>2022-02-05T10:21:11.390Z</updated>
  <id>https://changqingaas.github.io/</id>
  
  <author>
    <name>常青</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《把时间当做朋友》阅读笔记</title>
    <link href="https://changqingaas.github.io/%E4%B9%A6%E6%91%98/others/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/%E4%B9%A6%E6%91%98/others/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-05T14:00:33.000Z</published>
    <updated>2022-02-05T10:21:11.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="本书不是时间管理书籍"><a href="#本书不是时间管理书籍" class="headerlink" title="本书不是时间管理书籍"></a>本书不是时间管理书籍</h3><p>尽管本书的内容也包括任务管理等与常见“时间管理技巧”相关的内容，但是，本书主张时间不可管理、一切都靠积累。</p><p>更进一步地说，本书主张一个人必须在开启心智、提高思考能力之后，才能够用正确的方法做正确的事情。也只有这样，时间才是朋友，否则，它就是敌人。很多“时间管理技巧”并非无用，但往往由于使用者心智能力低下甚至尚未开启心智，致使那些技巧只能治标，不能治本，甚至既不治标，也不治本。</p><h3 id="这本书不是成功学书籍"><a href="#这本书不是成功学书籍" class="headerlink" title="这本书不是成功学书籍"></a>这本书不是成功学书籍</h3><p>成功从来都不是人人都可以做到的事情，过去不是，现在不是，将来依然不是。基于比较的成功观，是伤人的、害人的。事实上，对年轻人来说，成长比成功更重要，而且，这才是人人都可以做到的事情，才是人人都值得追求的事情。而成长其实只有一条路——积累。</p><h3 id="这本书不是心灵鸡汤式的书籍"><a href="#这本书不是心灵鸡汤式的书籍" class="headerlink" title="这本书不是心灵鸡汤式的书籍"></a>这本书不是心灵鸡汤式的书籍</h3><p>这本书里没有安慰，因为这本书不是写给脆弱的人的——只有脆弱的人才不断需要安慰。现实是残酷的，生活是艰难的，无论什么样的时代，无论对哪一个层次的人，都是如此，对大多数年轻人来说，更是如此。人的理性建立在接受现实的基础上，不能接受现实，一切成长都是虚妄。只有坚强的人才能接受现实，只有接受现实，才有可能开始运用心智作出理性的决定，进而才有可能做时间的朋友</p><h3 id="这不是一本讲大道理的书"><a href="#这不是一本讲大道理的书" class="headerlink" title="这不是一本讲大道理的书"></a>这不是一本讲大道理的书</h3><p>这本书所传递的信息，原本只不过属于常识，可由于种种原因，并没有被真正普及、理解，实在可惜。</p><h3 id="第2版前言"><a href="#第2版前言" class="headerlink" title="第2版前言"></a>第2版前言</h3><p>这本书在一个读者群中反应更为热烈——在职场上打拼过一两年的新人。当然，现在我已经可以理解个中原因：因为这本书所讲述的一些道理是需要一定的经验和挫折才能真正理解的。对尚未做过什么实事，尚未遇到什么挫折的人来说，这些道理看起来是那么简单、那么明显，乃至于和废话差不多——而所谓“越早醒悟越好”这样的言词，对他们来说是相当地苍白；所谓“苦口婆心”的态度，对他们来说是相当地腻歪。</p><p>有些道理就是很难传播——因为人们只传递自己认同的东西。有些道理就是不大可能被多数人认同，于是，即便它再合乎逻辑，再怎么有用，也不是很容易传播。</p><h3 id="第1版前言"><a href="#第1版前言" class="headerlink" title="第1版前言"></a>第1版前言</h3><p>无论是谁，都最终在某一刻意识到时间的珍贵，并且几乎注定会因懂事太晚而多少有些后悔。病了要投医，病急了就很可能乱投医。可是书店里各种各样的关于“时间管理”的书籍多半于事无补——至少这是我自己的经验。一方面是束手无策，另一方面是时间无情地流逝，恶性循环早已经形成——要做的事情越来越多，可用的时间越来越少；而因此时间越来越珍贵，时间越来越紧迫；时间越珍贵就越紧迫，时间越紧迫就越珍贵……压力越来越大，生活成了一团乱麻。</p><p>时间是个问题，可是“管理”它却不是正确有效的方法，因为那是几乎做不到的事情。之所以后来换成这个名字，在于“把时间当作朋友”更能体现本书的实质。我自己也是在写作的过程中才清楚地意识到“管理时间”的说法有多么荒谬。<strong>人是没办法管理时间的，时间也不听从任何人的管理</strong></p><p>终于有一天，我对自己说：<strong>“承认了吧，你对时间的流逝无能为力。”</strong>那一刻的醒悟，感觉就像凤凰涅槃一样浴火重生——这个说法多少有些矫情，但又确实过于准确而无可替代。那一瞬间，我已经30多岁——还好，并不算太晚。</p><p>要管理的不是时间，而是自己。人们生活在同一个世界，却又各自生活在自己的那个版本之中。改变自己，就意味着属于自己的那个版本的世界将会随之而变，其中也包括时间的属性。开启自己的心智，让自己能够用最可能准确的方式思考、观察、记录、总结、分享和行动，那么自己的时间就会拥有不同的质量，进而整个生活都必然因此焕然一新。</p><p>人生的幸运在于能够“用正确的方式做正确的事情”。而什么是正确的或者更好的方式，什么事情真的值得去做，需要运用良好的心智才能作出尽可能准确的判断。若真的做到“用正确的方式做正确的事情”，那一瞬间，时间无须管理（当然就算想管其实也没人能做到），它是你的朋友，陪你亦步亦趋走到最后的朋友。</p><h2 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>完成任何任务都需要一定的时间。同时，任何任务都最好或必须在某个特定的时间点之前完成，即，任务都有一个最后期限。而且，只要是必须完成的任务，不管是否已经开始执行，ddl就在不断迫近，因为时间永不停歇。</p><p>问题好像很简单，看起来无非有以下几种情况。</p><ul><li>没有按时开始执行任务。</li><li>错误估算完成任务所需时间。</li><li>在任务的执行过程中出现了差错。</li></ul><p>果真如此的话，那么解决方案好像也很简单。</p><ul><li>按时开始执行任务。</li><li>正确估算完成任务所需时间。</li><li>在执行任务的过程中不要出差错。</li></ul><p>可事实上问题并非如此简单，否则也不会让那么多人一 生都束手无策。</p><h3 id="慌乱"><a href="#慌乱" class="headerlink" title="慌乱"></a>慌乱</h3><p>大多数人都一样，压力刻在额头，匆忙写在脸上。他们身上充满了矛盾——他们“<strong>既勤奋又懒惰</strong>”。</p><p>经过反复询问，认真观察，我终于明白了——很多学生“既勤奋又懒惰”的怪异现象来自他们对“时间压力”的感受。“没时间了”或者“时间不够了”的恐慌，使他们超乎寻常地勤奋。哪怕只是虚假的“勤奋”，一样能让他们恨不得废寝忘食。而同样的感受，也使他们终日不忘寻找捷径，美其名曰“提高效率”，而实际上却想着“最好不费吹灰之力”。无论哪一种行为，都肯定是不现实的，因为已经“没时间了”——这才是冷冰冰的事实。</p><p>“没时间了”，是“时间恐慌症”患者脑子里唯一反复闪现的一句话。巨大的压力，极度的恐慌，使“患者”身上综合了一切矛盾：他们既勤奋又懒惰，既聪明又愚蠢，既勇敢又懦弱，既满怀希望又分分秒秒面临绝望，既充满自信又随时随地体会自卑……</p><p>但是，生活中明显有另外一些人——尽管数量上并不占优——在用另外一种状态生活。他们从容，他们优雅，他们善于化解各种压力，安静地去做他们认为应该做的事情，并总能有所成就。他们甚至可以达到常人无法想象的境界——不以物喜，不以己悲。面对同样的困境，这另外的一些人究竟是如何保持从容的呢？</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>你想打开一扇门，可那门上有个锁，把门锁住了。“如果能找到钥匙就好了”，你想。可是钥匙在哪里呢？反正不在那把锁上。既然门被锁上了，钥匙就一定不会插在锁孔里。</p><p>“没时间了！”这种尴尬就像是一把我们想要打开的锁。</p><p>同样，要想摆脱这种尴尬，死盯着这把锁是没有用的。</p><p>很少有人会注意，所谓“管理时间”抑或“时间管理”是虚假的概念，是不可能完成的任务。时间不会服从任何人的管理，它只会自顾自地流逝。你不可能冲它大喊：“时间，你给我慢一点！”它只是自顾自地流逝。你也不可能向它大叫：“时间，你给我快一点！”它还是自顾自地流逝。时间不理任何人，它用自己特有的速度流逝，不受任何外界因素影响。</p><p>钥匙在其他地方，反正不在锁上。尝试着从“管理时间”开始解决问题，注定徒劳。尽管我们面临的尴尬是“没时间了”，可从本质上来看，这尴尬与时间的关系不是很大。没错，<strong>问题出在我们自己身上。</strong></p><p>看起来似乎很有道理，而实际的操作效果怎么样呢？并不好。为什么？因为你发现（或最终证明）自己没有足够的能力去区分一项任务是否重要、是否紧急。所以，到头来，尽管别人告诉你的方法是对的，可是你操作起来却得不到期望的结果。</p><p>没错，问题出在我们自己身上。</p><p>我们无法管理时间。<strong>我们真正能够管理的，是我们自己</strong>。只有接受这个简单的事实，才有解决问题的希望。“时间不可管理”，尽管听上去很简单，但是理解它，进而接受它，可不见得那么容易。因为，它未必是（甚至几乎肯定不是）你以往已经认同的观念。</p><p>其实，这本书的主旨非常简单：时间是不可能被管理的。必须开启心智，看清楚，想明白：问题出在我们自 己身上。而我们所面临的问题，与时间、管理或时间管理都没有多大的关系。解决方案只有一个，那就是“一切都靠积累”。深信积累的力量，时间就是你的朋友，否则，它就是你的敌人。</p><h2 id="醒悟"><a href="#醒悟" class="headerlink" title="醒悟"></a>醒悟</h2><h3 id="孰主孰仆"><a href="#孰主孰仆" class="headerlink" title="孰主孰仆"></a>孰主孰仆</h3><p><strong>你的大脑并不是你，你的大脑是（属于）“你的”大脑。</strong></p><p>尽管你用它思考，好像它也在指导你的行为，但是你要明白，你不应该隶属于你的大脑，而应该是它隶属于你，你“可以控制你的大脑”——分清主仆很重要。</p><p>“<strong>运用心智获得解放</strong>”。不要再让自己“跟着感觉走”，成为大脑的奴隶，而是翻身做大脑的主人。</p><h3 id="何谓心智"><a href="#何谓心智" class="headerlink" title="何谓心智"></a>何谓心智</h3><p>一个人的心智就是其过往获得的一切知识及经验的总和（包括基于这些知识和经验造就的思考方法、思考模式）。心智与智商不同。大多数人都拥有正常的智商，但并非每个拥有正常智商的人都拥有正常的心智。许多人的心智仍处于未开启的状态。我们常看到所谓的“聪明人办傻事”，其原因基本上都是他们的心智尚未开启。他们即使做出了错误的判断也会振振有词——绝非强词夺理，而是义正词严、双目炯炯、真诚满怀。</p><p>无论是正向还是反向，心智一旦开启，就会不断自我积累，自我过滤，直至根深蒂固。人与人之间心智力量的差异，就是这样一点点地积累，最终天差地别。既然一个人的心智是他的知识和经验的总和，当然也会包括他的思考方法和思考模式。因为无论是吸收知识还是总结经验，都需要经过思考才能得出结论。在此过程中，他的思考方法和思考模式都会多多少少产生变化，根据新的知识和经验，或巩固、或调整、或否定、或重建……</p><p>所以说，心智这东西“上不封顶、下无保底”。心智一旦开启，就可能因为学习而像病毒一样疯狂发展，与此同时，“学习能力”也会相应地大幅增长。于是，心智可以发展，可以培养，可以重建，甚至可以反复重建——怎么可能封顶？然而，反过来，如若这一过程中出现一些差错，那么心智的发展就有可能停滞，甚至倒退，弄不好还会“痴心不得反癫狂”——怎么可能保底？这就好比有些人一辈子都是“原始人”；有一些人“开窍”了，演化成了“现代人”，甚至<a href="http://goo.gl/Z7bo2">尼采</a>所说的“超人”；同时还有一些人也“开窍”了，退化成了“猴子”。</p><p>有些认识，哪怕是简单的常识，也需要亲身经历后才能真正体会”。只有拥有无与伦比的打字速度，才能体会打字速度快的好处。</p><blockquote><p>心智真正成熟的人在一些情况下能够做到无须亲自经历，仅凭思考就得到深刻的体会。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>人们可能会基于一模一样的原因做出截然相反的决定。</p><p>当有机会学习一项技能的时候，人们常常会问：“学这东西有什么用呢？”其实，在尚未学习之前，对提问者来说，答案只能是“不知道”——尽管很多书籍中都已经花费大量的篇幅去论述“为什么要学习（某项技能）”。而“不知道那东西（对自己）有什么用”，恰恰是一部分人（更多一些）决定不学的原因，同时，它也是另一部分人（更少一些）决定去学的原因。</p><p>为了表述方便，让我们把“因为不知道那东西有什么用而决定学习的人”称为“甲”，把“因为不知道那东西有什么用而拒绝学习的人”称为“乙”。</p><p>在更多的时候，甲很可能想都没有想过“学这东西有什么用”。他从来都不问用途，只是自顾自学去了。许多年后，他自然而然地找到了这项技能的用处，享受了其已有技能所带来的种种好处。于是，这个既有经验成为他心智的一部分。当遇到新的学习机会时，他会自然而然地采取同样的策略——管它有什么用呢，学呗，学了总有用处。他也会自然而然地理解并相信“技不压身”的道理。</p><p>说完甲我们来说乙。乙当然永远不会知道这东西对他究竟有什么用，因为他从未拥有过这项技能，更不可能有机会亲身体会。随着时间推移，他凭自己的经验能够得到的结论只能是：“我没学也没什么。”也许有一天，当他因为没有学习这项技能而遇到一点尴尬的时候，可能会慨叹：“当初不懂事，要是学过就好了……”然而，这对他来说，仅限于慨叹。再次遇到学习机会的时候，他依然会选择放弃，只不过除了“不知道学它有什么用”之外还多了一个理由：“现在学也来不及了。”这种拒绝学习的判断，渐渐融入他的心智，难以更易，最终，当他再次面临同样的机会时，他还会与过去一样，做出同样的选择。</p><p>问题的关键在于，做出截然相反决定的理由竟然是一模一样的！人们通常认为，恰当的逻辑训练能够提高一个人做出正确选择决定的几率。可在上述情况下，大多数逻辑都无能为力。这种情况在生活中并不罕见，相反，比比皆是。父母教育孩子的时候被孩子驳得哑口无言就是这类情况——并不是孩子不讲逻辑，也不是孩子的观点正确，只是他就是无法理解父母所要传递的经验或者道理。他们不相信的理由和父母相信的理由很可能是一模一样的！</p><h2 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h2><h3 id="速成绝无可能"><a href="#速成绝无可能" class="headerlink" title="速成绝无可能"></a>速成绝无可能</h3><p>期望速成，从微观层面上看，有两个主要原因。</p><p>第一个原因是人希望自己的欲望马上得到满足的天性。一个确定的事实是，几乎每个人都有无穷无尽的欲望。虽然每个人都知道，不是所有欲望都能被满足，但人们仍然不会放弃追逐尽可能多的欲望。于是，不劳而获成了每个人心中的诸多愿望之一，甚至可能是其中最大的愿望。如果达不到不劳而获，少劳多获也可以接受，而且最好是“劳”尽量少，“获”尽量多，多多益善。从这个角度更进一步地说，大多数人都抱着类似这样的想法：如果收获的可能性很大，最好马上看到成果；如果收获的可能性很小，最好马上知道结果。</p><p>每个人都有这种欲望，差别仅在程度或者表现上。</p><p>第二个原因，也是浮躁的根源，就是很多人不懂“有些阶段就是无法跨越”这个道理。因此，他们才那么不现实地希望找到一个方法，靠其迅速达成目标，完结任务，获得解脱。可是，无论做什么事都需要时间，而且可能需要很多时间。 </p><p>除了上面这两个微观上的原因外，还有一个宏观上的原因也使人们常常不由自主地奢望速成——哪怕之前已经“醒悟”过。这个宏观上的原因即所谓的“现状使然”。根据达特茅斯学院经济学教授<a href="http://goo.gl/vLrz8">布兰奇弗劳尔</a>的调查结论，通常情况下，一个人一生各个阶段的满意程度和其年龄分布可以连成一个U型曲线。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220205095242.png" alt="img"></p><p>从这张图中可以看出，大多数人对其自身的满意程度从15岁左右开始持续下降，这大抵是不再无知无畏造成的。从那时起，一个人慢慢意识到自己在这个世界上其实微不足道，进而开始在所谓的理想和扭曲的现实中拼斗、挣扎，直到45岁左右才渐出苦海，曲线开始上扬。这就是以一个普通人的心智，观察、感受、思索、理解、实践、回顾，直至恍然大悟或者误入歧途的时间——30年。</p><p>在这漫长的 30 年里，由自我满意度持续下降所造成的浮躁形成了巨大的心理压力。越是浮躁，就越是对自己的现状不满；越是对自己的现状不满，就越是浮躁。</p><p>更大的问题在于，大多数人并不知道几乎所有的人都是这样。相反，现实好像总是提醒我们：有些人过得比我们好多了。这就是统计学的优势。它可以排除感情因素，用冷冰冰的数字展示现实。如果它所展示的现实与我们原本以为的并不相同甚至相反，这一优势就变得更为明显。掌握统计学常识的人，心智力量显然要比那些对此毫无了解的人强大——他们可以理解统计学结论的意义，即便那结论并非来自亲身经历，而他们也因此离现实更近一些。</p><p>总的来说，<strong>一方面是自己的无限欲望，一方面是要完成的事情太多，一方面是自我满意度的不断下降——这就是人们总是不由自主地期望速成的根源</strong>。出路肯定存在，但这出路只有一个起点——接受现实。<strong>告诉自己：我有不足，我需要时间，我没办法一蹴而就。</strong></p><h3 id="交换才是硬道理"><a href="#交换才是硬道理" class="headerlink" title="交换才是硬道理"></a>交换才是硬道理</h3><p>“我要”的欲望从来不会消减，只会不断增加。大多数人之所以会浮躁，是因为他们一无积累（或者积累太少，几乎无法换取任何东西），二无方法和经验（所以求而不得）。与此同时，“我要”的欲望恰恰因为无法获得而熊熊燃烧。情况更恶劣的时候，那欲望之火甚至可以烧掉他们所有的时间和精力，以至占用原本可以用于努力（或者投机）的时间，陷入死循环，无法挣脱。</p><p>积累多的人之所以稳健，是因为对他来说，“我要”的欲望可以用“我有”的东西来满足。即便“我有”的暂时不够，他也能借助已经拥有的足够的努力和勤奋（抑或投机取巧的方法和经验），只需假以时日，定能如愿以偿。一旦得偿所愿，<strong>不仅“我有”的更多，“我要”的也更容易获得，如此形成良性循环。</strong></p><p>生活的本质就是这样，你想要什么，它偏不给你什么。摆脱这个死循环的方法只有一个——给我什么我就用好什么，积累到一定程度再去换能换的东西。要不断想办法运用心智的力量去识别那些死循环和恶性循环，然后在好像不可能的情况下跳出去。</p><p>要想跳出去倒也简单。拿出一张纸，将其划分为左右两半，然后做两个列表，左边是“我有的”，右边是“我要的”，逐一罗列。完成后要尽量客观地判断：先划掉“我要的”当中那些无法用“我有的”换取的；再仔细判断在剩下的能用“我有的”换取的那些“我要的”之中，哪些是必须的、必要的、重要的、不可或缺的，并在其上做重点标记。偶尔会有一些“我要的”无法用现在“我有的”换来，却又是必须、必要，甚至不可或缺的，这需要我们认真考虑用什么样的手段再积累一些“我有的”，从而有足够资本换取那些“暂且换不到但极其想要的”——或努力勤奋，或投机取巧。投机的方式并非不能用，尽管它的成功概率实际上并没有看起来那么高，而它的失败概率甚至和它看起来的成功概率一样高。</p><p>还有一个辅助手段，就是在想到“我要什么”的时候马上提醒自己，接下来要花一些时间去思考“我有什么”。后者会在转瞬间让你“脚踏实地”。</p><p>最坏的情况是，拿出纸和笔认真面对自己，结果发现“自己什么都没有”。这也许令人气馁，但其实对任何一个正常人来说，“还有时间”、“还有精力”、“还有正常的智商”就已经足够了。只要努力，只要勤奋，机会总是存在的——我们必须要相信这一点，最好相信到毫不怀疑。</p><h3 id="完美永不存在"><a href="#完美永不存在" class="headerlink" title="完美永不存在"></a>完美永不存在</h3><p>越是能力差的人，越有那种非常不现实又极其脆弱的完美主义倾向。他们不现实，是因为他们不懂。因为他们不懂，所以他们不现实；因为他们不现实，所以他们脆弱。他们很容易受伤，因为他们的要求太高，也因此总是做不到。</p><p>有时，有些人会故意这样做，尽管他们自己不愿意承认。把自己标榜成完美主义者，是他们抬高自己的手段，是他们不去做一些事情的借口。他们把这个借口说出来的时候真个掷地有声：“做不好的事情我不做！”然而，这可能是装出来的。人就是这样，装得久了，就装得像了；装得太像、太久，不管事实怎样，自己倒是先信了。而这当然会影响之后的决定和行为。</p><p>这些人所说的“做不好”，其实是“不能一下子做好”，但问题在于，没有什么事情是一下子就能做好的。所以，他们这个也不做，那个也不做，到最后，已经不是“不做一些事情”了，而是“什么都没做”、“什么都不做”，结果“一事无成”。好笑的是，</p><h3 id="未知永远存在"><a href="#未知永远存在" class="headerlink" title="未知永远存在"></a>未知永远存在</h3><p>在进入任何一个新领域时，这种压力都能使新手窒息。而已经在那个领域里“浸泡”过一段时间的人，往往早已忘记了曾经面对的恐惧和压力，懒得（抑或不屑）开导新手、帮助新手。其实，更多的时候，一些老手实际上并不是“懒得”或者“不屑”，而是“没想到竟然连这个也需要解释”。</p><p>然而，为了进步，<strong>我们必须忍受一定的未知。</strong></p><p>首先，我们要承认自己不可能全知全晓。有些时候，有些问题没有答案，就好像“先有鸡还是先有蛋”一样。而有些时候，即便有了答案，其原因也不见得是我们能够搞懂的。</p><p>其次，我们要了解未知分为两种：一种是永远不能解决的，另一种是在可预见的未来也许能够解决的。对一个人来说，超过100年就可以算“永远”了，所以，第一种未知对个人来说意义不大；第二种未知却是我们必须面对的，学习的难度也在于此。“第一章的内容需要在掌握后面某一章的知识之后才能深入了解”，这几乎是所有高难知识体系的普遍特征。也就是说，在第一章，我们会有无数疑问，可这些疑问以当时的知识是无法全部解决的，需要我们继续学习，用接下来获得的知识解释今天的疑问。这就是那些爱钻牛角尖的人最终常常吃亏的重要原因——他们总是想“马上解决当时不可能解决的问题”。</p><p>再强调一次，我们必须接受这个现实——未知永远存在。而后，我们只能不断地尝试着去适应“在未知中不断前行”。</p><p>如果不能接受这个现实，就无法忍受未知的存在，也会平添无数的焦虑。焦虑是导致时间浪费、效率低下的根源之一。当人处于焦虑的时候，甚至可能出现一切理智都被清空的情况。另外，焦虑的情绪会让人觉得“必须要做点什么”，但是，在缺乏理智的状态下做出的任何决定和行为都可能带来灾难性的后果。一个相对有效的策略是：当有问题解决不了时，可以先把它记下来，然后继续前行。注意，一定要把它们记下来。</p><p>很多人没有记录的习惯，以至出现曾经因为思考（疑问就是思考的起点）后“忘了”而失去获得答案机会的情况。继续前行，并不意味着忽略这些问题，因为它们已被记下来了。而又因为它们被记了下来，所以可以在以后拿出来重新审视，不一定当什么时候、在什么地方、因为什么由头，它们之中的一部分就突然有了清楚的解决方案。当然，可能性最大的原因只有一个——你一直在前行，你一直在积累，你一直在成长。所以，到有了答案的那一刻，你不再是当初无能为力的你，你已经重生。</p><h3 id="现状无法马上摆脱"><a href="#现状无法马上摆脱" class="headerlink" title="现状无法马上摆脱"></a>现状无法马上摆脱</h3><p>与外界的无谓比较，让每个人凭空多出了一个根本不属于自己的目标，动辄被自己的理想绑架。很多人（应该是绝大多数人）的工作态度本质上是“骑驴找马”。基于种种原因（主要是概率问题），人们往往对自己正在从事的职业并不满意。很多人都心怀梦想，有一个“无论如何早晚都要从事的梦想职业”，而不幸的是，很多人正因如此最终沦为平庸之辈</p><p>尽管天分确实很重要，但一个人的能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间起，只要足够认真、努力，他的能力就会不停地积累。如果这个人实际上向往的是另一个职业，那么他的所谓“梦想”几乎必然使他在当前这份职业上心不在焉、无甚积累。其实，世界上80%以上的职业并不过分依赖天分，更可能甚至几乎只依赖积累。天长日久，这个人在当前的职业中将逐渐落后于那些认真做事的人。但此时他不会因为自己的落后而奋起直追，反过来，更可能的是把“反正我的梦想不是这个”当作借口。</p><p>无论是谁，进入自己梦想职业的成本都很高昂——极少数运气好的人除外——有些相对依赖天分和运气的行业更是如此 。当初未能从事一个职业就已经能说明问题了——除了运气不好，更可能的是因为积累不够。几年过去，这个人在他的所谓“梦想职业”中的经验积累依然是零，仍旧只是空有梦想。还有一个他更可能宁愿视而不见的事实是，那些在他所谓“梦想职业”中拼搏努力的人在这段时间里已经积累了无数经验，磨炼出了他在“圈外”无法想象的各种能力。就算有一天，这个人有足够运气，进入了那个他梦寐以求的领域，结果可能还是发现自己一无所有、毫无竞争力，最后不过是一切清零、从头再来。</p><p>心怀“梦想”的时间越长，它的沉没成本就越高。很多人都在无意之间被自己的“梦想”所绑架，所以，很多时候，对很多人来说，所谓“梦想”也许只是陷阱。许多年来，我曾见过身边不少的人一点一点被他们珍爱的“梦想”毁掉。</p><p>越是不满现状，摆脱现状的欲望就越强烈，而这种欲望会让一个人最终迷失方向，因为无论是谁，从本质上看都无法摆脱现状——每一时刻的现状都是过去某一或者某些时刻的结果，而每一时刻的现状都是未来某一或者某些时刻的原因。没有人能够逃脱现实的束缚。</p><p>从某种意义上理解，“逆境造就成功、磨难令人成熟”之类的话纯属胡说八道。显然，在顺境中更容易成功，而且很多磨难根本没有必要——这更可能是失败者对他们自己一生都未曾有机会体验的成功以及成功者“意淫”式的猜想而已。失败者永远没有机会了解成功的真相，因为人最容易受自身经验的限制，而不曾有哪怕一点点成功经验的人更无从摆脱自身的局限。</p><p>对现状不满、急于摆脱现状，是人们常常不知不觉落入的陷阱（尽管偶尔这也是少数人真正的动力）。接受现状才是最优策略——有什么做什么，有什么用什么；做什么都做好，用什么都用好。不要常常觉得苦（这会让人忍不住顾影自怜，浪费精力与时间），而要想办法在任何情况下找到情趣——快乐是一种本事。这些年我遇到的几乎所有优秀的年轻人都有这样的特征：他们很少对现状不满（可能是他们的优秀使他们难以觉得不满吧），他们热爱自己的生活，他们相对更不在意外界的影响，他们更专注于做事而心无旁骛，他们身处良性循环之中，当然，他们也因此每时每刻都在进步。</p><h3 id="与时间做朋友"><a href="#与时间做朋友" class="headerlink" title="与时间做朋友"></a>与时间做朋友</h3><p>与时间做朋友的方法很简单：用正确的方法做正确的事情。</p><p>正确的方法究竟是什么稍后再说，这里先说说什么是正确的事情。最可怕的不是效率不高，而是干脆做错了事。如果做的事情是错误的，效率越高，结果越糟。如果做的事情是正确的，效率低一点也没关系，因为做一点是一点，多收获一点，多进步一点，动力就会更强一点，进而更容易持续地做下去。怎样判断所做的事情是否正确？核心的判断只有一个：看它是否现实。</p><p>几乎一切愚蠢的行为都来自否定现实、逃避现实。只有接受现实，才可能脚踏实地，避免心浮气躁、好高骛远。如果我们把成功朴素地定义为“用正确的方法做正确的事情，并在最后期限之前漂亮地完成”的话，那么，大多数所谓的“时间管理技巧”实际上发挥不了多大的作用，只不过是花拳绣腿。真正有用的往往是简单而又朴素的道理，例如“现实只能接受”。 </p><p>大量的实践结果与理论分析表明，大多数随机变量均服从或近似服从正态分布，如测量的误差、学生的成绩、人类的身高和体重、产品的质量数据、投资的收益率等。</p><p>这种资源分布上自然的“不均匀”，看上去简单易懂，但古今中外都有很多人拒绝理解和接受它。他们甚至拒绝使用“不均匀”这个词，而是用“不公平”取而代之。历史上有无数次战争、无数次掠夺，但从本质上看，不过是因为把“均匀”理解成“公平”造成的。把“不均匀”理解成“不公平”，就可以理直气壮地打着“公平正义”的旗号为所欲为。</p><p>平静并理性地接受“资源稀缺”这个现实，其困难程度超乎想象，</p><p>尽管现实总是如此难于接受，坚强的你却应该坦然。以上提到的种种现实，包括“速成绝无可能”、“只有付出才有收获”、“完美永不存在”、“未知永远存在”、“现状无法马上摆脱”，都既清楚又简单，你必须要接受——不仅要接受，还要牢记；不仅要牢记，还要坚信，不容半点动摇。最好时常把自己的一些念头记下来，然后与这几条现实对照，看看它们是否与这些现实相符。之后，你会和所有人一样，发现自己常常在不知不觉之间被一些实际上完全不现实的念头所左右。这是正常的。但是，通过不时地记录、思考与反省，你会越来越善于甄别那些不现实的念头，进而摆脱他们的影响。这就是差别。很多人一生都不知道自己究竟有多么不现实。之前提到的“既勤奋又懒惰”的人群，基本上都是把这些现实当作老生常谈的道理——视而不见、听而不闻、从不记录、从不反省，才常常做出荒唐的决定，最终堕落到那分田地。</p><p>时间是现实的人的朋友，是不现实的人的敌人。时间不是故意要这样做，只不过事实如此。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="估算时间"><a href="#估算时间" class="headerlink" title="估算时间"></a>估算时间</h3><p>错误估算任务所需时间，是最常见，也是最致命的错误。在时间领域有一个貌似悖论的<code>侯世达法则</code> 值得牢记：</p><blockquote><p>完成一个任务实际花费的时间总会超过计划花费的时间，就算制定计划的时候考虑到本法则，也不能避免这种情况的发生。</p></blockquote><p>一旦开始做事，就会发现<code>意外</code>继踵而至。原本做的准备根本不能解决问题，因为“经过准备的就不再是问题”，而真正遇到的问题个个都是之前不曾想象抑或无法想象的，解决一个问题的同时往往会产生新的问题……因此，所谓“渐入佳境”最终只能是少数人的感受，大多数人在此之前早已溃败。</p><p>为什么人们总是错误估计完成任务所需要的时间</p><ul><li>执行任务前，没有分辨任务的属性：它是熟悉的还是陌生的<ul><li>熟悉的：由于已经做过一次（或多次），所以，你清楚地了解该任务的每一个环节，知道应该如何拆解任务、应该怎样分配拆解出来的子任务、每一个子任务有多少个步骤、每一个步骤需要耗费多长时间、哪些步骤需要格外小心……在这种情况下，正确估算完成任务需要的时间是很容易的。</li><li>陌生的：在执行过程中必然会遭遇各种所谓的“意外”。其实它们根本不是意外，只不过是因为你对任务不熟悉，它们才成为了“意外”。实际上，这些“意外”是任何完成该任务的人都必然会经历的事情。 只有完整地执行一次任务，该任务的属性由“陌生”变为“熟悉”之后，才有可能顺利解决这些“意外”。</li></ul></li></ul><p>对学习来说，任务“陌生”的可能性更大，因为学习本身是一个探索未知的过程。完成学习任务常常需要花费比我们想象中多得多的时间。对工作来说，任务“熟悉”的可能性更大。因为工作本身是一个应用已知的过程。当然，不同的工作，情况还是有所不同。例如，有些工作需要更多创新，有些工作可能前所未有……所以，在现实生活中，我们需要完成的任务的真实属性往往是“一部分熟悉，一部分陌生”。这就从根本上解释了为什么前文描述的那个貌似悖论的法则总是应验——我们必须处理未知，而从陌生到熟悉，就需要花费时间去学习，这个过程无法逾越。</p><p>要想提高估算时间的能力，就要从现在开始养成习惯：做任何事情之前先判断其熟悉程度（或陌生程度），再据此判断估算完成任务所需要的时间。通常情况下，“反正比一般人想得长多了”倒是一个屡试不爽的假设。</p><h3 id="及时行动"><a href="#及时行动" class="headerlink" title="及时行动"></a>及时行动</h3><p>比“越早开始越好”更切实的答案是“现在就开始”。所谓做事拖延，不是拖延着做事，而是拖延着不开始做事。明知自己拖延的人很痛苦，因为他们不是不知道该做什么，而是不知道为什么“无法进入状态”</p><p>一个常见的原因是前文所述的“错误估算任务所需时间”， 总以为可以在最后期限之前完成，心里想着“时间还多的是 嘛！”可这并不是本质原因。本质原因在于恐惧——无论是来自内部的，还是来自外部的。</p><p>来自内部的恐惧在于：只要开始做事，一个人就要面临做错、做不好的风险。这原本是任何人都逃不掉的事情，但最终患上“拖延症”的人犯了一个简单的认知性错误，即认为那些能够做对、做好的人都是直接做对、做好的。从表面上看也好像确是如此。那些能够做对、做好的人，总是显得从容不迫、轻车熟路。面对这样的人，那些犯了错、做不好的人根本没办法不自卑、不怀疑自己……</p><p>所以，很多人做事拖延的原因不过是“不求有功，但求无过”的想法。没有哪一个拖延的人愿意承认自己是这样想的，但当他们扪心自问的时候，他们都知道这描述一针见血。</p><p>只要做事，就一定会出问题。这是现实。无论何人，无论何事。如果在做事的过程中没有出现任何问题，那肯定不是在做事，而是在做梦。</p><p>认清并接受这个现实很重要。只有这样，才能心平气和地去做事。说一个人不怕困难，那是假话。谁不想一帆风顺、马到成功？可现实就是如此。做事情的时候，肯定会遇到困难，事情越有价值，困难就越具规模。遇到困难的时候，心平气和地面对就好，因为这只不过是生活常态。有时我们花费了很多时间和精力依然没能解决问题，却眼见别人轻松过关，这确实令人气馁。不过，这也是生活常态——在任何一个特定领域，总有一些人比另一些人表现更好、费力更少。然而，在大多数情况下，有4个字颇具道理并且值得相信——勤能补拙。不过，真正相信这4个字的前提是“接受现实”，否则，这4个字发挥不了任何实际作用。</p><p>来自外部的恐惧在于过分在意外界的评价。人是一种很有趣的动物，在自己做对、做好之前，通常已经了解做对、做好是什么样子。于是，无论能否做对、做好，人都觉得自己有能力判断别人是否做对、做好。所以，尽管自己不怎么样，却可以振振有词、理直气壮地评价别人做得对不对、好不好。所以，一个人一旦开始认真做事，被嘲弄、被耻笑的几率将远远高于被夸奖、被鼓励的几率——这几乎是肯定的。也正是由于这个原因，使很多人怀有前文提到的“不求有功，但求无过”的微妙心态。 事实上，那些真正能够做对、做好的人，绝不会随意嘲弄、打击别人，因为他们是做对过、做好过的人，他们一路走过来，心里非常清楚做对、做好有多么不易，所以，他们会不吝一切机会去鼓励那些尝试做事情的人。这甚至可以当作一种测试方法：如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会像那些极少数已经做对、做好的人一样，给予别人真诚的鼓励而非嘲弄。尽管那些能真正做对、做好的人有时也会给出负面评价，但这些评价通常是“建设性的负面评价”，并不是为了获得优越感而发出的嘲弄。</p><p>所以，我们没有必要在意来自他人的、非建设性的负面 评价。没有谁从一开始就能做对、做好。所有做对、做好的 人都是一路磕磕绊绊走过来的，这就是生活常态。而动辄给 出非建设性负面评价的人，往往不是正经做事的人，他们和 那些正经做事的人身处不一样的世界，这也是生活常态。</p><p>还有一个微妙的现象需要注意。尽管在一般的环境中，时间的运动是匀速的，但实际上，就人的主观感受来说，时间的运动肯定是加速前进的。对“为什么随着年龄的增长每个人都会觉得时间过得越来越快”这个问题，心理学家有一个简单明了的解释：</p><p>对一个5岁的孩子来讲，未来的1年相当于他已经度过的人生的¹⁄₅，即20%；而对一个50岁的成年人来讲，未来的1年只相当于他已经度过的人生的¹⁄₅₀，即2%。所以，随着年龄的增加，人们会觉得时间运动得越来越快。</p><p>更重要的是，人在小时候没什么事情可做，就愈发感觉时间过得慢；随着年龄增加，要做的事情越来越多，当然就愈发感觉时间过得飞快，稍纵即逝。由此看来，小孩子的感觉自然是“那时候天总是很蓝，日子总过得太慢”，而“人生犹如白驹过隙，瞬间而已”大都是老年人的慨叹，也是他们的切身感受。</p><p>如果能将这种认识纳入自己的心智，你就不会再对“最后期限”有那么荒谬的幻觉了。只要接受了必须完成的任务，你就会有真切的紧迫感，因为你知道，时间必然越走越快。而且，你现在就已经明白：“最后期限”不是固定在将来的某一点，而是朝着你加速扑来。有的时候，也许还没开始就发现自己已经晚了。在这样的情况下，唯一的策略依然是“现在就开始”。否则更待何时？在起步晚了的情况下，问题不是“到时候能不能做好”，而是“<strong>到时候能做多好就做多好</strong>，总好过什么都不做”。明白了这个道理，不管遇到什么任务，永远不要再问“什么时候开始才好”，因为答案只有一个：“现在”！</p><h3 id="直面困难"><a href="#直面困难" class="headerlink" title="直面困难"></a>直面困难</h3><p>就算没有低估完成任务所需要的时间，就算已经按时开始执行任务，很多人还是没有按时完成任务。为什么有的人好像一直在忙，却总是拿不出成绩、做不出成效？</p><p>无疑，他们的效率低下。而效率低下的根本原因是什么？答案是：回避困难。</p><p>稍微思考一下就能明白，合理的时间安排应该是这样的：迅速做完简单的部分，把节约出来的时间放在困难部分的处理上。然而，很多人会下意识地回避困难，于是乎，他们的时间安排是这样的：用几乎全部时间处理简单的部分，至于困难的部分，干脆“掩耳盗铃”，视而不见，暗地里希望困难自动消失……</p><p>这样的行为与做事的动机有关。人做事的动机往往来自两个截然相反的原因：奖励与惩罚。人都喜欢被奖励，讨厌被惩罚。从最浅的层面上看，尽力做能够获得奖励的事情显然是划算的，回避做可能招致惩罚的事情显然是合理的。然而，从另一个层面上看，接受惩罚往往是积累经验的起点，甚至是唯一的起点。这就是俗话所说的“吃一堑，长一智”。很多时候，为了能够“长一智”，必须先“吃一堑”，西方称之为“挫折教育”。</p><p>很多事情并不是一过性的，总会阶段性地有奖有罚。受到奖励之后，原本有两个选项：“再次来过”和“见好就收”。有意思的是，绝大多数人会自动忽视第二个选项 。受到惩罚之后，同样有两个选项：“从此碰都不碰那件事情”和“挣扎着找一个出路”。同样有意思的是，绝大多数人还是会自动忽视第二个选项。</p><p>所以，<strong>很多人实际上根本不知道自己所谓的“喜欢做某件事情”很可能只是因为那件事情相对简单、容易获得奖励而已</strong>。拖延的人并非不做事，他们做事，甚至做很多事。拖延的人也并非不努力，他们会花很长时间去做事，但做的只是很多简单的事。他们每次回避困难的时候，都不是故意的，并且往往已经给自己找了恰当的借口。这借口太强大、太有力，以至他们真诚地相信：“我喜欢做有创意的事情，而现在手上的这些事情太枯燥，我确实提不起兴趣……”</p><p>如果不能控制这种逃避的倾向，再多、再好的任务管理技巧都是无效的，因为任务中相当重要的一部分（通常因为重要而困难，也因为困难而重要）永远无法完成。所谓效率，是在任务完成之后才能够衡量的。这样看来，对逃避困难的人来讲，因为没有完整地完成任务，所以无论他们花了多长时间，也都没有效率（相当于分子为零）。</p><p>现实中，这种现象无处不在。比如学习上，准备托福考试时只做阅读和听力但不练习口语和写作；比如工作上，做项目计划时只讨论做什么却从不提及怎么做；比如生活上，总是把“我爱你”挂在嘴边却从来不花时间想想恋人真正需要的是什么……这些问题都源自同一个习惯：专做简单的，回避困难的。</p><p>所有真正踏实做事的人都知道，任何任务的绝大部分都是枯燥而又无趣的，所谓有创意的部分，可能连1%都不到。 </p><h3 id="关注步骤"><a href="#关注步骤" class="headerlink" title="关注步骤"></a>关注步骤</h3><p>任何任务都起码具备3个属性：何事（What）、何因（Why）、何法（How）。清楚了解一个任务的这些属性，对最终能否完成该任务起着决定性的作用，所以应该多花一点时间去“三思”。</p><p>在大多数情况下，这3个方面中最为关键的实际上不是内容，也不是原因，而是方法。因为任务的内容与原因常常不言自明，而方法却并非唾手可得。</p><p>思考方法需要从领悟内容入手，不停地细分、拆解任务，而且越具体越好，直至每个小任务都可以由一个人独立完成。</p><p>对任务的每一次“具体化”与“细分拆解”都要反复询问“原因”。</p><p>做任何事情，学会思考方式最为重要。</p><p>要学着像一个项目管理者那样思考——他们更多地关注“方法”，他们会花费比别人更多（多出许多倍）的时间去落实每一个步骤，在确认无误之后，他们才会有效地分配任务，团队才能够切实可靠地完成任务。 只有学会像项目管理者一样思考，他才能给自己分配具体的任务、制定切实可行的计划，最终高效地完成任务。</p><p>在做任何事情之前，通过关注“方法”去反复拆分任务，最终确认每个子任务都是可完成的，这是一个人不可或缺的功课。这样的习惯，会使一个人变得现实、踏实。这是一种习惯，也是一种后天习得的技能。这种技能无比重要，却常常被忽视，因为掌握这种技能的人总是默默地应用它，而忽视这种技能的人从未看到过它的具体实施过程和巨大好处。</p><h3 id="并行串行"><a href="#并行串行" class="headerlink" title="并行串行"></a>并行串行</h3><p>在任务管理的过程中，可以运用类似的方式去思考任务与任务之间的关系：这两个任务之间究竟应该是串行关系，还是并行关系？</p><blockquote><blockquote><p>无论学到了什么东西，都可以接着问自己：“那……这个道理还可以运用在什么地方？”反复问自己这种简单问题，能够锻炼自己融会贯通、举一反三的能力。 为什么呢？上过中学的人都应该明白“省功不省力、省力不省功”的物理原理啊！其实，这些人缺乏的就是这种思考能力或者说思考习惯。</p></blockquote></blockquote><p>这个问题非常重要，因为在一般情况下，“提高效率”指的就是“本只能串行完成的两个任务现在可以并行完成”。</p><p>最直接的办法是尽量将两个任务并行。比如，在跑步的时候听英语，在写文章的时候听音乐，在等班车的时候看书等。</p><p>养成一个习惯——把要做的事情用纸笔写出来，把任务落到纸面上，就可以比较容易地分辨出哪些任务是简单而又机械的，哪些任务是相对复杂而又灵活的（对我个人来讲，需要思考的就是“非机械”的），然后，尝试把一个非机械的任务和一个机械的任务搭配起来完成。</p><p>并行两个任务的一个重要前提是执行者足够了解这两个任务，且对自己有足够清楚的认识，即，对执行者来说，这两个任务是“主动并行”的。被动发生的并行任务往往只能使效率变得更为低下。（我在生活中生生剔除的一个被动并行任务就是“接电话”。从好多年前开始，我就把自己的手机设定为“静音”状态，从不主动接电话——而是每隔一两个小时查看一下电话，有必要的就打回去。当我有条件给自己安排一间不受人打搅的“工作室”后，终于再一次大幅消减了“被动并行”造成的时间和精力的浪费。）</p><p>当一个任务比较庞大，需要划分为多个步骤或者多个子任务的时候，对这些子任务之间的关系需要仔细甄别。甄别后，可能会因此产生若干个行动方案，而针对这些方案可能还需要反复衡量才能找到最佳方案。</p><p>优化的前提是“大任务被划分成足够多又不太多的小任务”。有了这样的前提，你才有能力分辨哪些任务可以并行——所谓的“优化”，其实是很简单的。</p><p>让自己拥有“多任务操作系统”的另一个方法就是切分自己的时间。（多任务操作系统把一个长时间段划分成很多短小的时间片，每个时间片只让处理器执行一个进程。循环反复的过程中，有些任务完成了，另一些任务处于尚未完成的状态，如果有新的任务进来，只需要加入循环队列即可。看上去好像是操作系统同时运行着很多进程，而实际上，它靠的是类似视觉暂留现象的机制）</p><p>把自己的时间切分成“时间片”是一种很难习得的能力，不过这种能力在大多数时候用不上，只有在任务太多、时间太紧的情况下，我才使用这种能力。应用这种能力时，要先坐下来制定一个工作列表，把任务罗列出来，然后把自己的时间“切片”。我通常把“20分钟工作+5分钟休息”作为一个时间片，然后就开始像处理器一样处理任务。这样做可以<strong>保持相对长时间的高效率工作</strong>。</p><p>尽管说起来很简单，但其实需要反复应用才能把这种简单的思考模式变成习惯。一旦养成精细拆分任务的习惯，效率就会在不知不觉间提高了。</p><h3 id="感知时间"><a href="#感知时间" class="headerlink" title="感知时间"></a>感知时间</h3><p>李敖每天的“事件日志”：除了自己经历的事件之外，一概不记，而且尽量不记感想，不记感受，只记录事件本身。 </p><p> 做这件事其实每天只需要花10分钟左右。后来为了进一步节省时间，我干脆在这个本子上穿了根绳，挂在家里洗手间马桶面对的那面墙上，每天晚上睡觉前坐在马桶上，顺手就写完了。这样简单的日志是有巨大好处的——每年下来，我都知道自己去年都做了些什么，仅仅这一点，就非常宝贵了。到了30岁之后，我才觉得自己做的真正有意义的事情慢慢多了起来。 </p><p>柳比歇夫的日志，是“事件―时间日志”（Event-time Log）。他的方法要比李敖的方法更高级。李敖的事件日志，往往只能记录事件的名称，是一种基于结果的记录；而柳比歇夫的“事件―时间日志”是一种基于过程的记录。它们的细微差别在于，基于过程的记录要比基于结果的记录更为详尽。</p><p>权摘抄《奇特的一生》中柳比歇夫的日志为例。</p><blockquote><p>乌里扬诺夫斯克。一九六四年四月七日。分类昆虫学（画两张无名袋蛾的图）——三小时十五分。鉴定袋蛾——二十分（1.0）。</p><p>附加工作：给斯拉瓦写信——二小时四十五分（0.5）。</p><p>社会工作：植物保护小组开会——二小时二十五分。休息：给伊戈尔写信——十分；《乌里扬诺夫斯克真理报》——十分；列夫·托尔斯泰的《塞瓦斯托波尔纪事》——一小时二十五分。</p><hr><p>基本工作合计——六小时二十分。</p></blockquote><p>基于过程的记录，不仅更详尽，还有另外一个巨大的好处——结果不好的时候更容易找到缘由。想明白“基于过程的”与“基于结果的”两种记录之间的区别之后，我开始尝试着在自己记录的每个事件后面加上时间：它会使你对时间的感觉越来越精确。</p><p> 通过实践，我发觉这种基于过程的“事件―时间日志”记录可以调整我对时间的感觉，在估算任何任务的工作量的时候，都更容易确定“真正现实可行的目标”。此外，相对准确的估算又使得目标基本上都可以达成，由此可以算是“战胜了焦虑”。</p><p>网易的“Mr.Time”——一个用来记录时间开销的应用。Mr.Time用起来很简单：做任何事情之前，拿出手机，打开应用，摇一下，事情做完之后，再摇一下。如此这般确定了时间起点和终点之后，再抽空将具体事务分类、编辑、细化。Mr.Time解决了两个问题：一方面简化记录时间开销的过程，另一方面自动完成记录后的整理、分析、统计工作。有了这个应用，记录时间开销应该不算麻烦了。</p><p>既然管理时间是不可能的，那么解决方法就只能是：想尽一切办法真正了解自己、真正了解时间、精确感知时间，而后再想尽一切办法使自己以及自己的行为与时间“合拍”。按我的话说就是——“与时间做朋友”。</p><h3 id="制定预算"><a href="#制定预算" class="headerlink" title="制定预算"></a>制定预算</h3><p>除了每天记录时间开销之外，还要养成一个习惯：每天制作时间预算</p><p>在开始一天的活动之前，花费15至30分钟仔细制订当天的时间预算绝对是特别值得的，恰如另一段“陈词滥调”——磨刀不误砍柴工。</p><p>最直接的方法就是制作一个列表，把今天要做的事情列出来。为了表述方便，后文把这些列表中的事情称为“任务”。</p><p>当然，在罗列这些任务的时候，你的大脑就要自动开始估算完成每项任务究竟要花费多少时间了。很快，你就会遇到第一个问题：任务太多，无法全部完成。于是，你只好进行选择。</p><p>事实上，生活就是选择。</p><p>解决这个问题的方法倒也简单，就是给列表中的每项任务标上权重，例如可以用1～5分进行标注。但是请注意，不要像某些书籍建议的那样使用1～10进行标注，因为大多数情况下，人们很难那样精确地分辨事情的重要程度。实际上，我认为对大多数人来讲，用“1、2、3”已经足够，因为这种设计基本上可以代表：</p><blockquote><p>▷ 不重要</p><p>▷ 一般</p><p>▷ 重要</p></blockquote><p>当然，根据个人喜好，你也可以用“1、0、−1”进行标注。<strong>同样的事情可以通过很多种方法完成，选择自己喜欢的方法往往就是最优策略</strong></p><p>一旦开始尝试去给要做的事情标注权重，你会发现，这件事并没有那么容易，即便只用最简单的方法——只用“重要”和“不重要”进行标注，因为我们必须分辨“真的重要”和“显得重要”，以及“真的不重要”和“显得不重要”，可对照下图来看。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220205152814.png" alt="img" style="zoom:50%;" /></p><p>判断一项任务是否“真的重要”其实只需要一个标准：这项任务的完成是否确实对目标达成有益。可是，作为一个正常的、健全的、拥有七情六欲的普通人来讲，不挣扎一下，就很难完全专注于这个最关键、最根本的决策标准。</p><p>每个人都喜欢做有趣的事情，做的时候往往并不关心这件事到底有没有用。可是，有趣的事不见得有用啊！</p><p>如果我们能甩甩头，强迫自己理智一些，就会知道：无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，都应该去做。 </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220205153005.png" alt="img"></p><p>审视一下自己的生活，你就可能痛苦地发现自己经常仅仅因为非常有趣就去做的那些事其实没什么用。</p><p>目标不用向任何人学习，每个人都或多或少、或清楚明了或含混模糊地有自己的目标——不管是什么所谓的“理想”或者“痴心妄想”。现在就开始把自己的那些哪怕不切实际的目标作为标准来判断吧——判断每项任务的真实属性，然后选择“真的重要的”或者“显得不重要的”。</p><p>相信我，养成任何一个哪怕很小的习惯都需要挣扎。然而，貌似痛苦的挣扎过程，在将来的某个时刻终将变得其乐无穷。</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>很多时候，我们面临的抉择就是“计划还是率性，是个问题”。在大多数情况下，计划总是必要的。在与计划相关的格言中，我最喜欢的是：“我们不是计划着失败，而是失败地计划</p><h4 id="计划成功的前提：目标现实可行"><a href="#计划成功的前提：目标现实可行" class="headerlink" title="计划成功的前提：目标现实可行"></a>计划成功的前提：目标现实可行</h4><p>对像我这样的普通人来说，证明我的目标现实可行的方法比较简单：</p><ol><li>已经有人做到了。</li><li>我与那个人没有太大的差距。</li></ol><p>“已经有人做到了”，并不代表我也能做到。他用多长时间做到的？他通过什么方式做到的？我和他的区别究竟在什么地方？哪些是我确实无法超越的？我的相对优势在哪里？我有没有可能通过一些方式弥补我的相对缺陷？也许还要问更多的问题，才能够确定我们的目标确实是现实并且可行的。</p><p>事情往往并不像想象中那么简单。我们更常面临的尴尬是：<strong>如果不开始行动，根本就无从判断目标是不是确实可行</strong>，或者反过来，目标是不是确实不可行。于是，往往只有开始行动之后，才能做出正确的判断。在行动过程中，<strong>如果发现既定的目标确实是不现实、不可行的，那么“半途而废”不仅不意味着失败，反而意味着决策者的无比理智。</strong></p><h4 id="长期计划是需要通过实践才能习得的能力"><a href="#长期计划是需要通过实践才能习得的能力" class="headerlink" title="长期计划是需要通过实践才能习得的能力"></a>长期计划是需要通过实践才能习得的能力</h4><p>有人说“计划总是没有变化快”。这话听上去挺现实，却没说到点子上。计划总是被变化打乱的深层次的原因在于：计划过于长远。事实上，无论变化多快，计划总应该是有的，只是在制定计划的时候，应该考虑到变化，应该以自身的情况分析自己究竟适合制定多久的计划。</p><p>通过实践发现：如果一个计划的期限只有一个星期，我是很容易坚持下来，并且往往可以出色完成的。这个发现令我非常开心，因为我发现自己还是可以做一些事情的。而随着时间的推移，我发现自己竟然可以慢慢把计划期限延长，两个星期、一个月，后来甚至可以制定一个季度的计划！</p><p>在目标现实可行、方向确定的情况下，辅以计划，才能成功。一般来讲，期限越短、内容越清晰，目标就越容易实现。长期目标、人生理想固然要有，但理想这东西往往太遥远，以至我们总是看不清楚。不过，看不清楚也没关系，“千里之行始于足下”，我们实际要做的事情只是一步一步地走，把每一步都走好，走得足够踏实。至于“千里”之外的终点，既然连看都看不清，就不用花时间去想了，因为想了也没用。</p><h3 id="有些时候没必要做计划"><a href="#有些时候没必要做计划" class="headerlink" title="有些时候没必要做计划"></a>有些时候没必要做计划</h3><p><strong>计划固然重要，行动更为重要。</strong></p><p>计划无论简单还是复杂，缺乏切实的行动就注定会失败或者失效。我的经验是：有些时候故意不做计划反倒是有益的。</p><p>综上所述，没必要做计划的原因主要有两个，除了前面提到过的“任务其实非常简单”之外，另一个原因是“初始状态下，我们往往并没有能力去制定合理有效的计划”。做任何事情，都可能经历相同的过程：逐步熟悉，小心摸索，失败、失败、再失败，认真反思，卷土重来，直至成功。而最初，在我们对任务连基本的认知都没有的时候，制定出来的计划十有八九只不过是空谈。</p><blockquote><p>基于经验： 所有的大额消费活动，乃至其他一切涉及金钱的活动，诸如投资之类，“马上行动”的建议肯定不适用。相反，这种情况下，一定要拖延，拖得越久越好 </p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>制作一个列表，往往会使自己做事井井有条，并保证自己不会白白浪费时间。 </p><h4 id="最方便的列表工具是纸和笔"><a href="#最方便的列表工具是纸和笔" class="headerlink" title="最方便的列表工具是纸和笔"></a>最方便的列表工具是纸和笔</h4><p>我建议，尽量不要使用安装在台式或便携式计算机上的列表管理软件——尽管那些程序都设计得非常好，但它们却远不如纸和笔来得方便、有效。台式计算机不大可能随身携带，便携式计算机倒是可以随身携带，但远比纸和笔笨重，而且从待机状态恢复到工作状态往往需要等待</p><p>纸和笔很难被完全替代的另一个重要原因是：除了它们之外，我们很难再找到可以用来随手写写画画的工具了。很多时候，画比写重要，哪怕可能仅仅是画一个圈或者几个箭头而已。</p><h4 id="列表没必要工整"><a href="#列表没必要工整" class="headerlink" title="列表没必要工整"></a>列表没必要工整</h4><p>列表的读者往往只有我们自己，所以列表只要自己能看懂就够了。用最简便的方式制作列表才最合理：大量的缩写、箭头、线条以及各种各样的符号和圈圈框框……</p><p>曾经突然发现自己着迷于把各种列表做得工工整整，但这对实现列表的价值而言毫无意义，纯粹是在浪费时间。想明白这一点后，我就开始有意识地控制自己，<strong>让自己不要去做那些没有实际意义的事情</strong></p><h4 id="列表一定要随手可及"><a href="#列表一定要随手可及" class="headerlink" title="列表一定要随手可及"></a>列表一定要随手可及</h4><h4 id="最重要的任务永远只有一个"><a href="#最重要的任务永远只有一个" class="headerlink" title="最重要的任务永远只有一个"></a>最重要的任务永远只有一个</h4><p>我见过很多专家讲解任务的重要和紧急与否之间的关系，以及如何分配任务的优先级。道理是很清楚的：先做既重要又紧急的；不重要又不紧急的当然不用理会；紧急却不重要的，亦可不必理会；可若是重要却不紧急的，反倒得优先处理</p><p>然而，我通过观察发现，大多数人面临的真正问题并不是弄不清楚这个道理，而是无从分辨“真的重要”和“显得重要”以及“真的紧急”和“显得紧急”。判断一件事情是否真的重要，标准只有一个：<strong>是否对目标（无论是长期还是短期）的实现有益</strong></p><p>然而，判断一项任务是否真的紧急，标准却并不好找，因为人总会觉得每一件事都很紧急。事实上，真正紧急的事少之又少，“十万火急”几乎只出现在故事里。</p><p>以，评价任务只需要一个判断标准，那就是：它是否真的重要。再往后的道理一目了然：最重要的任务永远只有一个——那个真正对目标的实现有帮助的任务。</p><h4 id="制作专门的下一阶段任务列表"><a href="#制作专门的下一阶段任务列表" class="headerlink" title="制作专门的下一阶段任务列表"></a>制作专门的下一阶段任务列表</h4><p>除非万不得已，否则千万不要在整个任务完成之前中途更改列表中的项目。一旦这么做了，那随之而来的就是发现自己“有必要”不停地更改这个列表中的某个或多个项目，最终甚至会导致整个任务永远无法完成。</p><p>所以，如果有了什么新鲜的主意，启用另一个列表，标题是“下一阶段务列表”，把它们记下来就好。然后，马上回到当前的任务列表，专注在现在应该完成的任务上。如果你又有了新鲜的主意，如法炮制即可。这样做的好处在于：一方面，不会影响当前任务的进度；另一方面，在当前任务完成之后，那个“下一阶段任务列表”上已经有相当数量、非常具体的待处理项目了</p><h3 id="给每个任务制定一个核对列表"><a href="#给每个任务制定一个核对列表" class="headerlink" title="给每个任务制定一个核对列表"></a>给每个任务制定一个核对列表</h3><p>为了万无一失，我们需要提前制作一个可以勾画的核对列表，逐一核对，避免缺漏。</p><p>列表一旦开始运作，就一定要执行到底。</p><p>事无成的最根本原因就是放弃。放弃的方法有很多种， 最常见的是“换一个更好的方向”。如果确实是一个更好的 方向倒也罢了，但事实上更好的方向并不存在，因为照此下去， “更好的方向”会不断出现。千万不要觉得认为自己能够不停地找到“更好的方向”的人不多，其实大家都会不停地“找到更好的方向”。</p><p>走向成功的过程就好比项目的起点是南极，而终点在北极——无论最初往哪走，只要中途不改变方向，早晚会到达终点。但是，如果中途改变过方向，更极端的——经常改变方向，就怎样都无法到达终点，甚至可能返回起点。所以，开始行动之前要先判断列表所代表的任务是否现实。如果确实觉得自己能够也应该完成这个任务，那就着手去做，而且一定要执行到底。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>无论是学习、工作还是生活，我们面临的任务大都是重复性的。要想加快执行重复性任务的速度，只需在遇到重复性任务时先将其做完一次，然后马上总结、整理，搞清流程，再靠进一步的实践把它变成“闭着眼睛也能做好”的事。这是提高效率、减少失误的根本手段。</p><p>为常见任务制定流程是一个必须养成的习惯。一个人在梳理流程的过程中，会不由自主地思考个中细节。有些人做事仔细，其实只不过是因为他们很早就养成了这个简单的习惯而已。而另一些人，总感觉自己够聪明，却在实际工作中频繁出错，也只不过是因为他们尚未养成这个简单的习惯而已。这个简单的习惯，日久天长，会让人与人之间产生巨大差异。</p><h3 id="预演"><a href="#预演" class="headerlink" title="预演"></a>预演</h3><p>需要执行的任务越重要，这种预演就越关键。只有经过大量的预演或者练习，我们才能够在实际执行任务的过程中有出色的表现。这也是良性循环和恶性循环之间的选择和差异。准备充分的人，常常会有出色的表现，最终能够顺利地完成任务，而这样的经验会使他更加坚信提前准备的重要。准备不充分的人，执行任务时必然表现欠佳，但不管表现多差，他也提前做了一点准备（或者自认为做了一点准备），但这样的经验却会让他觉得准备是没什么用的，至少是没什么大用的，于是下一次他还会采取同样的行动，还会面临相同甚至更为严重的尴尬……</p><p>我认为，万事皆可提前准备，万事皆需提前准备。只有前期准备充分，才能在实际执行任务的时候有出色的表现。</p><h3 id="验收"><a href="#验收" class="headerlink" title="验收"></a>验收</h3><p>很多人做事半途而废、不了了之的根本原因在于从未想过要给自己执行任务时的表现设计一个验收机制。最基本的验收机制是针对最终结果的，部分有经验的人因为在做事之前总是更关注步骤，并会按照需求将任务拆分成若干个子任务，所以，他们甚至会为每一个步骤设计相应的验收机制。</p><p>由此可见，验收机制相当重要。从这个角度讲，我们不管遇到什么任务，都应该对其认真审视，同时向自己提出一个问题并要想办法回答清楚：“怎样才算‘做好’？”如果能把任务拆分成若干个子任务，那么确定“做好”的标准可能更容易一些，因为每个子任务的验收标准可能已经自然存在，起码有这么一条：“如果这个做不好，那么下一个就没法开始……”</p><p>为了能将验收机制落到实处，我们应该在做一件事情之前，拿出纸和笔写下每一个预定的验收标准。</p><p>从更高的层面上说，<strong>设计验收机制也是任何一个领导者必须拥有的基本能力</strong>。哪怕你领导的只是一个很小的团队，你也都必然要向团队成员指派各种各样的任务。在这种情况下，如果你没有设计验收机制，最终的结果肯定会让你非常失望，因为缺少验收机制会使团队成员对自己的工作质量毫不介意，长此以往，团队的执行力将等于零，作为团队领导者的你也必须承担失败的责任。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="效率本质"><a href="#效率本质" class="headerlink" title="效率本质"></a>效率本质</h3><p>学习”最关键的一点是：任何知识的获取，都是不可逆的。在知道它的那一瞬间，它就已经改变了一切，生活因它而变，却无法还原。我们再也不可能对它视而不见、听而不闻、置之不理，它瞬间就能根深蒂固，无法铲除。</p><h3 id="摒弃经验-主义-局限"><a href="#摒弃经验-主义-局限" class="headerlink" title="摒弃经验(主义)局限"></a>摒弃经验(主义)局限</h3><p>所有的人获取知识最为基础的手段就是“体验”。“经验”在一定的层面上是适用的，不能否定它的重要价值，但与此同时，必须认清“经验主义”的局限。</p><p>在知识正确传播的过程中，语言、文字以及逻辑思维很重要。</p><h3 id="自学能力"><a href="#自学能力" class="headerlink" title="自学能力"></a>自学能力</h3><p>本科教育之“本”在于培养学生的自学能力。从理论上讲，一个人本科毕业之后，应该有能力自学他所需要的任何知识。</p><h4 id="检索能力建立在相当熟练的阅读理解能力的基础之上"><a href="#检索能力建立在相当熟练的阅读理解能力的基础之上" class="headerlink" title="检索能力建立在相当熟练的阅读理解能力的基础之上"></a>检索能力建立在相当熟练的阅读理解能力的基础之上</h4><h4 id="实践能力是自学能力最终转化为真正价值的根本"><a href="#实践能力是自学能力最终转化为真正价值的根本" class="headerlink" title="实践能力是自学能力最终转化为真正价值的根本"></a>实践能力是自学能力最终转化为真正价值的根本</h4><p>我看到过一句令人非常震撼的话：很多人正是因为没有目标才不停地“学习”。许多人都曾慨叹：工作之后才知道什么真正有用</p><p>道自己需要的是什么之后，真正的学习才算开始。比如学英语：很多人天天在学却从来不用。背单词坚决不造句，却去练习什么词根词缀记忆法或联想记忆法；背了那么多单词，却从不读英文文档，从不写英文文章。 其实，掌握2000个基础词汇、了解基本语法规则之后，就应该去“用”英语了。</p><h3 id="永远保持开放的心态"><a href="#永远保持开放的心态" class="headerlink" title="永远保持开放的心态"></a>永远保持开放的心态</h3><p>我们的大脑有一个运行机制叫“选择性输入”，其具体表征在很多人身上都有体现：他们只能听到自己喜欢听的，只能看到自己想要看的。</p><p>对抗“选择性输入”的最好办法就是借助我们最好的记录工具——纸和笔——有条件的话，最好固定一段时间来把那些目前暂时无法理解的、支持的、反对的、无所谓的论点和观点记录下来。对无法理解的，写下自己当时的疑惑何在；对支持的，记录几个理由或者实例；对反对的，同样记录几个理由或者实例；甚至对那些无所谓的，也记录其原因。一个有着这样良好记录习惯的人会获得他人无法拥有的处理信息和知识的能力——“反刍”。这种“反刍”能力是我们避免成为“选择性输入”受害者的重要保障。</p><h3 id="了解学习的进程"><a href="#了解学习的进程" class="headerlink" title="了解学习的进程"></a>了解学习的进程</h3><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="勤于思考"><a href="#勤于思考" class="headerlink" title="勤于思考"></a>勤于思考</h3><p>一旦开始尝试独立思考，我们就会发现，陷阱无处不在。这些陷阱直接导致无数人放弃思考——因为在很多时候，思考虽然不费力气，但实在是太麻烦了。为了避免麻烦而把思考推给别人是一种常见的解脱手段，由此，大多数人身上出现了大量“迷信权威”的现象，只不过是程度不同。“迷信权威”本身就是一个典型的陷阱：权威的意见可能更加准确，可是，权威也好、专家也罢，滥竽充数的实在不少。为此我们不得不常常采取“求人不如求己”策略。这也展现了一个无奈的事实——我们生活在一个信任成本极高的社会。</p><p>独立思考的一把钥匙是这样的——</p><p>首先要了解：权威不一定等于正确。进一步要明白：就算权威正确，也只是权威表达了正确，而非正确属于权威。最后要清楚：准确地说，权威只是权威、正确就是正确，它们俩什么时候都不是一回事。</p><p>从另一个角度看，拒绝独立思考、把思考的工作交给别人，不仅不省时间，恰恰相反，非常浪费时间——甚至浪费一生的时间。</p><h3 id="思维陷阱"><a href="#思维陷阱" class="headerlink" title="思维陷阱"></a>思维陷阱</h3><h4 id="概念不清"><a href="#概念不清" class="headerlink" title="概念不清"></a>概念不清</h4><p>学习任何知识最重要的一点，就是搞清楚它所有的基础概念。不夸张地讲，任何一个学科的所有知识，都是由这些概念一点一点搭建起来的。</p><h3 id="感悟与道理"><a href="#感悟与道理" class="headerlink" title="感悟与道理"></a>感悟与道理</h3><p>“道理”应该是普适的，而“感悟”只来自个体经验。 很多的“感悟”是有局限的，甚至可能是有很大误导性的。</p><p>——成功者其实没有必要、没有义务，也往往没有足够的时间去讲述所有的细节。相信我，如果仅仅用财富、权力、地位来衡量成功（即世俗意义上的成功），那么所有的成功背后都有数不尽的磨难，同时，也往往充斥着大量不可告人的细节。比如，国内某大企业的老板肯定不会对所有人说他在受到各个方面的巨大压力后才做出某些决定。追求巨大财富的人是如此，追求巨大权力和至高无上地位的人更是如此。</p><p>如果某个人把他们说的当作全部，把他们没说的当作没有，那么这就是掩耳盗铃了。</p><p>一定要了解这样一个事实：有些时候，“成功者”的经验没什么用，因为那些经验根本就是错误的，关键在于“成功者”自己可能也并不了解。比如，他们遇到了一个经济飞速增长的时代，无论做什么都赚钱，并且赚得很多，所以从宏观上来看，根本就不是他们自己所认为的宝贵经验在起作用，而是宏观经济给了他们这样的机会。但是，有谁愿意承认自己的成功跟自己的经验没有关系呢？人类普遍拥有的一个认知偏差就是：把成功揽到自己身上，把失败归咎于别人或者坏运气。</p><p>最后，要知道有些“宝贵经验”就算正确，放到别人身上也可能并不那么灵验。最可能让一个人误入歧途的，就是他对自己的了解。</p><p>比如，成功者们常说，他们并不在意钱，他们知道人格的可贵。但是，大部分听众和他们不一样。大部分听众现在没有足够的钱！相信我，绝大多数人，在没有钱的时候，对“人格可贵”的理解很难非常深刻。人活着是要吃饭的，一个人的家眷是不应该被饿着的，在基本条件都不能保障的时候，“人格有个屁用”就成了很多人的选择。</p><p>与其关注成功者，不妨反其道而行之——努力从失败者身上汲取经验。因为失败者的失败往往是显然的、确定的，失败的真正原因也往往很容易查实（尽管失败者会找各种各样的借口）。并且，我们身边失败者的数量，显然要多于成功者的数量。如此，我们也就有了更多的观察机会。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><h3 id="说与不说"><a href="#说与不说" class="headerlink" title="说与不说"></a>说与不说</h3><p>在我年纪很小的时候，父亲就告诉我：一定要想办法不时做出令人敬佩的事情，这样就会有人主动找你做朋友。我当时并不懂得其中的道理，直到自己过了30岁才意识到一直按他说的去做所带来的巨大好处。“赢得尊重”是最不能急于求成的，也绝对不可能靠临时抱佛脚实现。</p><p>“话说出来之后有没有人听”是一个极为有效的自我评估标准。有人听，就说明自己所处的状态；话说了，别人却“听而不闻”，甚至有（对自己来说意外的）异常反应，就说明自己积累得还不够。积累得不够就接着攒罢。我一直觉得“攒人品”的说法不仅是有趣的，还是相当精巧的。</p><p>对很多人来说，“知无不言，言无不尽”在大部分情况下是最浪费时间和精力的做法。 </p><p>我个人认为，在分享知识的时候，“知无不言，言无不尽”是正确的；而在日常交流中，这个原则的适用性非常差。</p><h3 id="共生状态"><a href="#共生状态" class="headerlink" title="共生状态"></a>共生状态</h3><p> 如果我们在任何讨论中发现参与者里面有“自以为是”者存在，那么最好的选择只有一个：退出讨论。因为，只要他们存在，讨论就不再是讨论，也不会得出任何有意义的结果，继续下去只会浪费自己的时间。而我们千万不要自以为是到认为自己有能力、有时间、有责任、有义务教会他们“想明白”的本领，甚至带他们跨越那道难倒大多数人的障碍，这任务几近不可能完成。</p><h3 id="正确复述"><a href="#正确复述" class="headerlink" title="正确复述"></a>正确复述</h3><p>如果甲与乙两个人需要沟通，过程是：甲将他的想法用他的语言表达出来（即“编码”），乙用自己的方式去理解甲的语言（即“解码”），然后反过来再次进行。此过程可能重复数次。</p><p>但是，不同人的“编码/解码”机制常常也不相同。每个人的“编码/解码”机制都是依靠长期积累获得的，而且深受环境的影响。</p><p>况且，发送者生成他的想法——所谓“想明白”——本身就不见得是一件容易的事情，“编码/传递/解码”这3个过程也不一定能够协调无误地实现。再加上即便接收者“解码”正确，他还要把结果与自己的现有知识体系融合，而这也不一定能顺利完成。正确、顺利、有效的沟通到底有多难？ </p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h3><p>其实并不是对自己正在做的事情没有兴趣，而是没有能力把目前正在做的事情做好。几乎没有人会喜欢做自己做不好的事情，每个人都会不自觉地尽量回避自己的短处</p><p>但不管整体怎样，对一个人来说，一定要问自己这个问题：我不喜欢做某件事情，是不是仅仅因为这件事我没有做好？若是因为自己没有做好而不喜欢，就要考虑另一个问题：做好这件事情究竟对自己有没有意义？如果有，那就要努力做，直到做好为止，没有其他选择。反过来，自己做得挺好，但就是不喜欢，纯粹因为那件事对自己确实没有什么吸引力——事实上这种情况少之又少——那就直接换一件事情做吧。谁能逼你去做一件你确实不喜欢做的事情呢？退一步说，如果你被逼着去做自己能做好的事情，应该也会有些兴趣的。</p><p>其次，人们总说他们真正感兴趣的是其他事情。可事实上，出现这种感觉应该仅仅是因为他们还没有开始做那件事，也还没有在那件事上遭受挫折而已。其实，很多人真的放弃原来做的事情，转去做新的“真正感兴趣的”事情的时候，往往会发现，这件事想要做好同样困难重重，挫折不断。没过多久，这些人又会因为做不好这件事情而对其失去兴趣，然后开始幻想做另外的事情，并且将这一行为“合理化”：“我（才知道）自己真正感兴趣的并不是这个……”</p><p>综上所述，我觉得兴趣并不是很重要，至少没有我们想象得那么重要。对一个人来说，某件事情只要能做好，并且做到比大多数人好，他就不会对那件事情没兴趣。</p><p>说来说去，<strong>是顺序出了问题：往往并不是有兴趣才能做好，而是做好了才有兴趣。</strong></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>所有学习上的成功，都只依靠两件事——策略和坚持，而坚持本身就是最重要的策略。</p><p>很多时候，哪怕说“方法不重要到几乎可以忽略不计的地步”，其实也不是特别过分。更何况，所谓的“好方法”实际上是因人而异的。适合这个人的方法，放到那个人身上，很可能适得其反。换言之，适合所有人的方法很可能根本不存在。所以，有那么多的人将宝贵的时光虚掷在不停地寻找方法上，是一件非常可笑却又不得不令人扼腕叹息的事情。</p><p>与其不停地寻找“更好的方法”，还不如马上开始行动。</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>没有任何机器可以一直用100%的功率运转，人也一样。</p><p>记住，任何人都不可能100%地有效率，至少不可能总是100%地有效率。</p><p>有些时候，我们会非常有效率，但是，这种情况不可能永远维持。如果一个人强迫自己一定要如此，他必会像那些始终用100%的功率运转的机器一样，由于损耗太大而提前报废。</p><blockquote><p>纯时间要比毛时间少得多。所谓毛时间，就是你花在这项工作上的时间。</p><p>常常有人说，他们一天工作十四五个小时。这样的人可能是有的。可是拿纯时间来说，我一天干不了　那么多。我做学术工作的时间，最高纪录是11小时30分。一般，我能有七八个小时的纯工作时间，我就心满意足了。我最高纪录的一个月是1937年7月，我一个月工作了316小时，每日平均纯工作时间是7小时。如果把纯时间折算成毛时间，应该增加25%到30%；我逐渐改进我的统计，最后形成了我现在使用的方法……</p><p>当然，每个人每天都要睡觉，都要吃饭。换句话说，每个人都有一定的时间用在标准活动上。工作经验表明，约有12至13小时毛时间可以用于非标准活动，诸如上班办公、学术工作、社会工作、娱乐，等等。</p></blockquote><p>从这里就可以看出，在做时间预算的时候，一定要留有空间。一方面，我们必须清楚肯定会有意外事件发生，所以要留出时间处理这些意外事件；另一方面，我们必须使用适当的方法休息、放松，以便恢复精力，在良好的状态下做更多的事情。一个人除了工作、学习之外，一定要保证自己有足够的其他活动。</p><h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><p>我们应该记住的是：凡是值得做的事情，都值得慢慢去做，做很久很久。</p><h3 id="自我证明"><a href="#自我证明" class="headerlink" title="自我证明"></a>自我证明</h3><p>证明自己是大多数人自然的愿望。“证明自己”本身没有任何错误，但是，很多人实际上是挣扎着想“证明自己给别人看”。殊不知，“证明自己给别人看”恰恰是最浪费生命的一种行为。如果某个人本身是出色的，那么不需要他去证明自己是出色的，别人自然会看到。如果某个人本身是平庸的，那么也不需要他去证明自己是平庸的，别人同样会看到。如果某个人出色，却仍然要刻意证明，可能招致不必要的麻烦</p><p>实际上，尽管我们总是说“人贵自知”，但是，很多时候，对很多人来讲，“自知”可能是非常残忍的。</p><p>如果你想不开，一定要让别人承认自己比他们强，那就听我的劝告，记住一件事：你比别人强一点根本没用，真正有用的是你比别人强很多很多。</p>]]></content>
    
    
    <summary type="html">《把时间当做朋友》阅读笔记，根据自己的喜好，做了一点删减</summary>
    
    
    
    <category term="书摘" scheme="https://changqingaas.github.io/categories/%E4%B9%A6%E6%91%98/"/>
    
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>matlab学习笔记</title>
    <link href="https://changqingaas.github.io/%E5%BB%BA%E6%A8%A1/math/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/%E5%BB%BA%E6%A8%A1/math/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-03T14:00:33.000Z</published>
    <updated>2022-02-04T04:55:19.194Z</updated>
    
    <content type="html"><![CDATA[<p>注： </p><ul><li>虽然文档很全面，但是这篇文章主要是为了在一天内速成，所以不足之处请多包涵。</li><li>代码基于vscode/py 3.6调用的matlab terminal</li></ul><h1 id="基本的数学运算与矩阵运算"><a href="#基本的数学运算与矩阵运算" class="headerlink" title="基本的数学运算与矩阵运算"></a>基本的数学运算与矩阵运算</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>不需声明</li><li>用 = 给变量赋值</li></ul><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><ul><li>变量名大小写敏感（不知道是不是因为在windows的原因</li><li>变量名只能由[<code>0~9</code>,<code>a~z</code>,<code>A~z</code>,<code>_</code>]组成,且变量名不能以数字开头.</li><li>保留变量不适合做变量名<ul><li>使用<code>iskeyword</code>命令可以查看程序关键字,这些关键字不允许被用作变量名.</li></ul></li></ul><div class="table-container"><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>ans</td><td>上一句运算的结果</td></tr><tr><td><strong>i,j</strong></td><td>复数算子，（这里需要留意）</td></tr><tr><td>Inf</td><td>无穷</td></tr><tr><td>eps</td><td>浮点相对精度,即1.0到下一个浮点数之间的距离(值为2.2204e-16)</td></tr><tr><td>NaN</td><td>非数字</td></tr><tr><td>pi</td><td>圆周率</td></tr></tbody></table></div><ul><li><p>变量名不应当覆盖内置函数名</p><ul><li><p>在MATLAB中,变量的调用优先级(calling priority)高于函数,因此变量名不应该覆盖内置函数.</p><p><img src='https://img-blog.csdnimg.cn/20191112184241114.png'></p></li><li><p>例如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">cos &#x3D; &#39;changqingaas&#39;;cos(8)% disp([&#39;ans is &#39;, num2str(ans)])clear; % 若某函数被变量名所覆盖,则调用clear &lt;变量名&gt;可以取消绑定在该函数名上的变量名cos(8)% disp([&#39;ans is &#39;, num2str(ans)])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：<code>clear</code>是一个比较危险的命令,因为该命令后若不加参数,则表示清除当前工作区内的所有变量.</p></li></ul></li></ul><pre><code>输出：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ans &#x3D;    &#39;n&#39;ans &#x3D;   -0.1455<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p><code>logical</code>,<code>char</code>,<code>numeric</code>,<code>cell</code>,<code>struct</code>以及由他们组成的数组或矩阵.</p><p><img src="https://img-blog.csdnimg.cn/20191112184307618.png" alt="MATLAB中的变量类型"></p><h5 id="数字型变量的显示格式"><a href="#数字型变量的显示格式" class="headerlink" title="数字型变量的显示格式"></a>数字型变量的显示格式</h5><p>数字型变量,默认以<code>double</code>形式存储的.</p><p>可以通过<code>format &lt;显示格式&gt;</code>改变数字型变量的显示格式.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203182051.png" alt="image-20220203182051494"></p><h3 id="MATLAB命令行"><a href="#MATLAB命令行" class="headerlink" title="MATLAB命令行"></a>MATLAB命令行</h3><ul><li><p>使用行尾<code>;</code>抑制输出: </p><ul><li>在一行命令后使用<code>;</code>抑制输出,否则运算结果将被显示在终端上.</li></ul></li><li><p>| 命令    | 作用                                                         | 运行结果                                                     |<br>| ———- | —————————————————————————————— | —————————————————————————————— |<br>| <code>clc</code>   | 清除终端的输出                                               |                                                              |<br>| <code>clear</code> | 默认清除当前工作区内所有变量                                 |                                                              |<br>| <code>who</code>   | 以简略格式显示工作区内所有变量                               | 您的变量为:<br>ans                                           |<br>| <code>whos</code>  | 以复杂格式显示工作区内所有变量                               | Name      Size            Bytes  Class     Attributes<br/>  ans       1x1                 8  double |<br>| which   | 查看内置函数源代码文件的位置,与<code>edit</code>命令结合可以查看内置函数的源代码. |                                                              |</p></li></ul><h2 id="使用MATLAB进行数字运算"><a href="#使用MATLAB进行数字运算" class="headerlink" title="使用MATLAB进行数字运算"></a>使用MATLAB进行数字运算</h2><h3 id="使用MATLAB计算数学表达式"><a href="#使用MATLAB计算数学表达式" class="headerlink" title="使用MATLAB计算数学表达式"></a>使用MATLAB计算数学表达式</h3><ul><li>数学表达式被计算后，其值被存入变量ans</li><li>log 表示 ln</li><li>exp(x) 表示 e^x</li></ul><h3 id="MATLAB内置的数学函数"><a href="#MATLAB内置的数学函数" class="headerlink" title="MATLAB内置的数学函数"></a>MATLAB内置的数学函数</h3><ul><li><p><a href="https://www.mathworks.com/help/matlab/arithmetic.html">MATLAB内置的算数运算函数</a></p><ul><li><p>基本运算:</p><ul><li>加: <code>+</code>,<code>sum</code>,<code>cumsum</code>,<code>movsum</code></li><li>减: <code>-</code>,<code>diff</code></li><li>乘: <code>.*</code>,<code>*</code>,<code>prod</code>,<code>cumprod</code></li><li>除: <code>./</code>,<code>.\</code>,<code>/</code>,<code>\</code></li><li>乘方: <code>.^</code>,<code>^</code></li></ul></li><li><p>取模运算: <code>mod</code>,<code>rem</code>,<code>idivide</code>,<code>ceil</code>,<code>fix</code>,<code>floor</code>,<code>round</code></p></li></ul></li><li><p><a href="http://www.mathworks.com/help/matlab/trigonometry.html">MATLAB内置的三角运算函数</a></p><ul><li>正弦: sin,sind,sinpi,asin,asind,sinh,asinh</li><li>余弦: cos,cosd,cospi,acos,acosd,cosh,acosh</li><li>正切: tan,tand,atan,atand,atan2,atan2d,tanh,atanh</li><li>余割: csc,cscd,acsc,acscd,csch,acsch</li><li>正割: sec,secd,asec,asecd,sech,asech</li><li>余切: cot,cotd,acot,acotd,coth,acoth</li><li>斜边: hypot</li><li>转换: deg2rad,rad2deg,cart2pol,cart2sph,pol2cart,sph2cart</li></ul></li><li><p><a href="https://ww2.mathworks.cn/help/matlab/exponents-and-logarithms.html">MATLAB内置的指数对数函数: </a></p><ul><li>exp,expm1,log,log10,log1p,log2,nextpow2,nthroot,pow2,reallog,realpow,realsqrt,sqr</li></ul></li><li><p><a href="https://www.mathworks.com/help/matlab/complex-numbers.html">MATLAB内置的复函数: </a></p><ul><li>abs,angle,complex,conj,cplxpair,i,imag,isreal,j,real,sign,unwrap</li></ul></li></ul><h2 id="使用MATLAB进行矩阵运算"><a href="#使用MATLAB进行矩阵运算" class="headerlink" title="使用MATLAB进行矩阵运算"></a>使用MATLAB进行矩阵运算</h2><h3 id="定义矩阵"><a href="#定义矩阵" class="headerlink" title="定义矩阵"></a>定义矩阵</h3><h4 id="向终端输入矩阵"><a href="#向终端输入矩阵" class="headerlink" title="向终端输入矩阵"></a>向终端输入矩阵</h4><p>在MATLAB中,使用[]将待输入的矩阵内容括起来,使用空格或逗号,分隔行内变量,使用;分隔每一行.</p><div class="table-container"><table><thead><tr><th><strong>MATLAB命令</strong></th><th><strong>得到的矩阵</strong></th></tr></thead><tbody><tr><td>[1 2 3 4]</td><td>[1 2 3 4]</td></tr><tr><td>[1; 2; 3; 4]</td><td>$\begin{bmatrix}1 \\ 2 \\ 3 \\ 4\end{bmatrix}$</td></tr><tr><td>[1 21 6; 5 17 9; 31 2 7]</td><td>$\begin{bmatrix} 1 &amp; 21 &amp; 6 \\ 5 &amp; 17 &amp; 9 \\ 31 &amp; 2 &amp; 7 \end{bmatrix}$</td></tr></tbody></table></div><h4 id="使用冒号运算符创建向量"><a href="#使用冒号运算符创建向量" class="headerlink" title="使用冒号运算符创建向量"></a>使用冒号运算符创建向量</h4><p>使用冒号运算符:可以创建一个长向量,其语法如下:</p><div class="table-container"><table><thead><tr><th><strong>冒号表达式</strong></th><th><strong>得到的结果</strong></th></tr></thead><tbody><tr><td>j:k</td><td>[j,j+1,j+2,…,k]</td></tr><tr><td>j:i:k</td><td>[j,j+i,j+2*i,…,j+m∗i]</td></tr></tbody></table></div><p> 例如：</p><div class="table-container"><table><thead><tr><th><strong>MATLAB语句</strong></th><th><strong>得到的结果</strong></th></tr></thead><tbody><tr><td>1:5</td><td>[1 2 3 4 5]</td></tr><tr><td>1:3:5</td><td>[1 4]</td></tr><tr><td>[1:3; 2:3:10]</td><td>$\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 2 &amp; 5 &amp; 8 \end{bmatrix}$</td></tr><tr><td>‘a’:2:’z’</td><td>‘acegikmoqsuwy’</td></tr></tbody></table></div><h4 id="定义特殊矩阵"><a href="#定义特殊矩阵" class="headerlink" title="定义特殊矩阵"></a>定义特殊矩阵</h4><div class="table-container"><table><thead><tr><th><strong>命令</strong></th><th><strong>得到的结果</strong></th></tr></thead><tbody><tr><td>eye(n)</td><td>得到一个n × n 的单位矩阵</td></tr><tr><td>zeros(n1, n2)</td><td>得到一个n1 × n2  的全0矩阵</td></tr><tr><td>ones(n1, n2)</td><td>得到一个n1 × n2  的全1矩阵</td></tr><tr><td>diag(vector)</td><td>得到一个以向量<code>vector</code>中内容为对角线的对角矩阵</td></tr></tbody></table></div><h3 id="矩阵的索引"><a href="#矩阵的索引" class="headerlink" title="矩阵的索引"></a>矩阵的索引</h3><ul><li><p>MATLAB中的矩阵是以<strong>列</strong>序存储的.且索引下标从1开始.</p></li><li><p>矩阵有两种索引方式: 按一维索引和按二维索引.对于一个一般的矩阵,其索引顺序如下:</p><ul><li>$\begin{bmatrix} 1或(1,1) &amp; 4或(1,2) &amp; 7或(1,3) \\ 2或(2,1) &amp; 5或(2,2) &amp; 8或(2,3) \\ 3或(3,1) &amp; 6或(3,2) &amp;9或(3,3)  \end{bmatrix}$</li></ul></li><li><p>矩阵的索引可以使用冒号<code>:</code>,表示选取所有行或所有列.</p></li><li><p>矩阵的索引可以是一个或两个向量,表示选中向量内的所有行或所有列.</p><p>| <strong>原矩阵</strong>                                                   | <strong>索引</strong>        | <strong>得到的结果</strong>                                          |<br>| —————————————————————————————— | ———————- | ———————————————————————————- |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A(8)            | 6                                                       |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1 3 5])      | [1 7 5]                                                 |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1 2; 3 4])   | $\begin{bmatrix} 1 &amp; 4 \\ 7 &amp; 2\end{bmatrix}$           |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A(3,2)          | 8                                                       |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1,2], :)     | $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp;  5 &amp; 6 \end{bmatrix}$ |<br>| $\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\\ 7 &amp; 8 &amp; 9 \end{bmatrix}$ | A([1 3], [1 2]) | $\begin{bmatrix} 1 &amp; 2 \\ 7 &amp; 8 \end{bmatrix}$          |</p></li></ul><h3 id="矩阵的操作"><a href="#矩阵的操作" class="headerlink" title="矩阵的操作"></a>矩阵的操作</h3><h4 id="操作矩阵的运算符"><a href="#操作矩阵的运算符" class="headerlink" title="操作矩阵的运算符"></a>操作矩阵的运算符</h4><div class="table-container"><table><thead><tr><th>运算符</th><th>操作</th><th>形式</th><th>例子</th></tr></thead><tbody><tr><td><code>+</code></td><td>矩阵与向量相加</td><td><code>A+b</code></td><td><code>[6 3] + 2 = [8 5]</code></td></tr><tr><td><code>-</code></td><td>矩阵与向量相减</td><td><code>A-b</code></td><td><code>[6 3] - 2 = [4 1]</code></td></tr><tr><td><code>+</code></td><td>矩阵与矩阵对应位置相加</td><td><code>A+B</code></td><td><code>[6 3] + [4 8] = [10 11]</code></td></tr><tr><td><code>-</code></td><td>矩阵与矩阵对应位置相减</td><td><code>A-B</code></td><td><code>[6 3] - [4 8] = [2 -5]</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>*</code></td><td>矩阵与矩阵相乘</td><td><code>A*B</code></td><td><code>[6 3] * [4 8]&#39; = 48</code></td></tr><tr><td><code>.*</code></td><td>矩阵与矩阵对应位置相乘</td><td><code>A.*B</code></td><td><code>[6 3] * [4 8] = [24 24]</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>/</code></td><td>矩阵与矩阵右除(等价于<code>A*inv(B)</code>)</td><td><code>A/B</code></td><td><code>[6 3] / [4 8] = 0.6</code></td></tr><tr><td><code>\</code></td><td>矩阵与矩阵左除(等价于<code>inv(A)*B</code>)</td><td><code>A\B</code></td><td><code>[6 3] / [4 8] = [0.06667 1.3333; 0 0]</code></td></tr><tr><td><code>./</code></td><td>矩阵与矩阵对应位置右除</td><td><code>A./B</code></td><td><code>[6 3] ./ [4 8] = [1.5 0.375]</code></td></tr><tr><td><code>.\</code></td><td>矩阵与矩阵对应位置左除</td><td><code>A.\B</code></td><td><code>[6 3] .\ [4 8] = [0.6667 2.6667]</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>^</code></td><td>矩阵与向量乘方</td><td><code>A^b</code></td><td><code>[1 2; 3 4]^3 = [37 54; 81 118]</code></td></tr><tr><td><code>.^</code></td><td>矩阵与矩阵对应位置乘方</td><td><code>A.^B</code></td><td><code>[1 2; 3 4].^[1 2; 3 4] = [1 4; 27 256]</code></td></tr></tbody></table></div><h4 id="操作矩阵的函数"><a href="#操作矩阵的函数" class="headerlink" title="操作矩阵的函数"></a>操作矩阵的函数</h4><p>对下面的矩阵</p><script type="math/tex; mode=display">A=\begin{bmatrix} 1 & 2 & 3 \\ 0 & 5 & 6 \\ 7 & 0 & 9 \end{bmatrix}</script><p>进行操作以演示操作矩阵的常见函数</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td><code>max(A, [], dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的最大值</td><td><code>max(A, [], 1)</code></td><td>$\begin{bmatrix} 7 &amp; 5 &amp; 9 \end{bmatrix}$</td></tr><tr><td><code>min(A, [], dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的最小值</td><td><code>min(A, [], 2)</code></td><td>$\begin{bmatrix} 1 &amp; 0 &amp; 0 \end{bmatrix}$</td></tr><tr><td><code>sum(A, dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的和</td><td><code>sum(A, 1)</code></td><td>$\begin{bmatrix} 8 &amp; 7 &amp; 18 \end{bmatrix}$</td></tr><tr><td><code>mean(A, dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的平均值</td><td><code>mean(A, 1)</code></td><td>[2.66672.33336.0000]</td></tr><tr><td><code>sort(A, dim, direction)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上按<code>direction</code>顺序排序结果</td><td><code>sort(A, 1, &#39;descend&#39;)</code></td><td>$\begin{bmatrix} 7 &amp; 5 &amp; 9 \\\ 1 &amp; 2 &amp; 6 \\ 0 &amp; 0 &amp; 3 \end{bmatrix}$</td></tr><tr><td><code>sortrows(A, column)</code></td><td>获取矩阵<code>A</code>按照每行第<code>column</code>个元素升序排序结果.</td><td><code>sortrows(A, 2)</code></td><td>$\begin{bmatrix}  7 &amp; 0 &amp; 9\\ 1 &amp; 2 &amp; 3\\ 0 &amp; 5 &amp; 6\end{bmatrix}$</td></tr><tr><td><code>size(A, dim)</code></td><td>获取矩阵<code>A</code>的<code>dim</code>维度上的形状.若不指定<code>dim</code>,则返回整个矩阵的形状.</td><td><code>size(A)</code></td><td>[3 3]</td></tr><tr><td><code>find(A, n)</code></td><td>获取矩阵<code>A</code>前<code>n</code>个非零元素的索引</td><td>`find(A,5)</td><td>[1 3 4 5 7]</td></tr></tbody></table></div><p>对于上面这些函数,除第一个参数以外,其它参数都是可选的.</p><h1 id="结构化编程和函数定义"><a href="#结构化编程和函数定义" class="headerlink" title="结构化编程和函数定义"></a>结构化编程和函数定义</h1><h2 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h2><h3 id="流程控制语句和逻辑运算符"><a href="#流程控制语句和逻辑运算符" class="headerlink" title="流程控制语句和逻辑运算符"></a>流程控制语句和逻辑运算符</h3><div class="table-container"><table><thead><tr><th>流程控制语句</th><th>作用</th></tr></thead><tbody><tr><td><code>if, elseif, else</code></td><td>若<code>if</code>语句为真,则执行子句</td></tr><tr><td><code>switch, case, otherwise</code></td><td>根据<code>switch</code>语句内容判断执行哪个子句</td></tr><tr><td><code>while</code></td><td>重复执行子句直到<code>while</code>中的条件为假</td></tr><tr><td><code>for</code></td><td>执行子句固定次数</td></tr><tr><td><code>try, catch</code></td><td>执行子句并捕获执行过程中的异常</td></tr><tr><td><code>break</code></td><td>跳出循环</td></tr><tr><td><code>continue</code></td><td>直接进入下一次循环</td></tr><tr><td><code>end</code></td><td>结束子句</td></tr><tr><td><code>pause</code></td><td>暂停程序</td></tr><tr><td><code>return</code></td><td>返回到调用函数处</td></tr></tbody></table></div><p>上述所有循环和条件语句都要在末尾以<code>end</code>闭合.</p><p>MATLAB还有以下逻辑运算符:</p><div class="table-container"><table><thead><tr><th>运算符</th><th>意义</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td></tr><tr><td><code>~=</code></td><td>不等于</td></tr><tr><td><code>&amp;&amp;</code></td><td>且(支持逻辑短路)</td></tr><tr><td>`</td><td></td><td>`</td><td>或(支持逻辑短路)</td></tr></tbody></table></div><h4 id="流程控制语句示例"><a href="#流程控制语句示例" class="headerlink" title="流程控制语句示例"></a>流程控制语句示例</h4><h5 id="if-语句："><a href="#if-语句：" class="headerlink" title="if 语句："></a>if 语句：</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">if condition1statement1elseif condition2statement2else statement3end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">switch expression    case value1        statement1    case value2        statement2    otherwise         statementend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">while expressionstatementend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">for variable &#x3D; start:increment:endcommandsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 2; k &#x3D; 0; error &#x3D; inf;error_threshold &#x3D; 1e-32;while error &gt; error_threshold    if k &gt; 100        break    end    x &#x3D; x - sin(x) &#x2F; cos(x);    error &#x3D; abs(x - pi);    k &#x3D; k + 1;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用循环语句应尽量预先分配内存空间"><a href="#使用循环语句应尽量预先分配内存空间" class="headerlink" title="使用循环语句应尽量预先分配内存空间"></a>使用循环语句应尽量预先分配内存空间</h4><h3 id="编写脚本时应注意的问题"><a href="#编写脚本时应注意的问题" class="headerlink" title="编写脚本时应注意的问题"></a>编写脚本时应注意的问题</h3><h4 id="在脚本开头应添加语句清空工作区"><a href="#在脚本开头应添加语句清空工作区" class="headerlink" title="在脚本开头应添加语句清空工作区"></a>在脚本开头应添加语句清空工作区</h4><p>在每个脚本的开头,应添加下述语句,清空工作区缓存以及之前程序运行的痕迹:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear all% 清空工作区内存中的变量close all % 关闭之前程序绘制的图像clc% 清空之前程序在终端的输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="在运算和赋值语句后应添加分号-抑制输出"><a href="#在运算和赋值语句后应添加分号-抑制输出" class="headerlink" title="在运算和赋值语句后应添加分号;抑制输出"></a>在运算和赋值语句后应添加分号<code>;</code>抑制输出</h4><p>在所有运算和赋值语句都应该添加分号<code>;</code>抑制输出,若需要向终端输出一个变量,应对其调用<code>disp</code>方法.</p><h4 id="使用省略号-拼接多行语句"><a href="#使用省略号-拼接多行语句" class="headerlink" title="使用省略号...拼接多行语句"></a>使用省略号<code>...</code>拼接多行语句</h4><p>在MATLAB中,省略号<code>...</code>可以将多行语句拼接为一行,灵活使用该语句可以提高代码可读性.</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>与脚本类似,函数可以被存入<code>函数名.m</code>文件中,也可以以函数句柄的形式定义在内存中.</p><h3 id="查看内置函数"><a href="#查看内置函数" class="headerlink" title="查看内置函数"></a>查看内置函数</h3><p>我们可以使用<code>which</code>命令查看内置函数源代码文件的位置,与<code>edit</code>命令结合可以查看内置函数的源代码.</p><p>运行下面语句可以打开MATLAB内置的<code>mean</code>函数的源文件:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">edit(which(&#39;mean.m&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203200209.png" alt="mean函数源代码"></p><h3 id="以函数名-m文件形式定义函数"><a href="#以函数名-m文件形式定义函数" class="headerlink" title="以函数名.m文件形式定义函数"></a>以<code>函数名.m</code>文件形式定义函数</h3><p>在MATLAB文件中定义函数的格式如下:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function [输出变量名] &#x3D; 函数名(输入变量名) % 函数的文档函数代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>function</code>是一个关键字,声明该文件中保存的是一个函数.</li><li><code>输入变量</code>和<code>输出变量</code>是非必须的,函数既可以没有输入变量,也可以没有输出变量.</li><li><code>函数名</code>应与<code>.m</code>文件名相同,且不包含特殊字符(最好不要有中文).</li></ul><h4 id="MATLAB内置的函数参数"><a href="#MATLAB内置的函数参数" class="headerlink" title="MATLAB内置的函数参数"></a>MATLAB内置的函数参数</h4><div class="table-container"><table><thead><tr><th>函数参数</th><th>意义</th></tr></thead><tbody><tr><td><code>imputname</code></td><td>输入变量名列表</td></tr><tr><td><code>mfilename</code></td><td>函数源代码文件名</td></tr><tr><td><code>nargin</code></td><td>输入变量数</td></tr><tr><td><code>nargout</code></td><td>输出变量个数</td></tr><tr><td><code>varargin</code></td><td>可变长输入参数列表</td></tr><tr><td><code>varargout</code></td><td>可变长输出参数列表</td></tr></tbody></table></div><p>MATLAB不提供其他高级语言的指定默认参数值以及函数重载等语法,但灵活使用上述内置的函数参数,可以在一定程度上实现指定默认参数值以及方法重载:</p><h4 id="MATLAB函数定义示例1"><a href="#MATLAB函数定义示例1" class="headerlink" title="MATLAB函数定义示例1"></a>MATLAB函数定义示例1</h4><p>面程序用来计算自由落体运动中位移量:<br>$x = x_{0} + v_{0}t + \frac{1}{2} g t^2 $</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function x &#x3D; freebody(x0,v0,t)% calculation of free falling% x0: initial displacement in m% v0: initial velocity in m&#x2F;sec% t: the elapsed time in sec% x: the depth of falling in mx &#x3D; x0 + v0.*t + 1&#x2F;2*9.8*t.*t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数演示了一个MATLAB编程技巧: 计算乘法时应尽量使用<code>.*</code>而非<code>*</code>,因为前者不仅对参数<code>t</code>为标量的情况可用,也对变量<code>t</code>为向量或矩阵的情况可用.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">freebody(0, 0, 2)% 得到 19.6000freebody(0, 0, [0 1 2 3])% 得到 [0 4.9000 19.6000 44.1000]freebody(0, 0, [0 1; 2 3])% 得到 [0 4.9000; 19.6000 44.1000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="MATLAB函数定义示例2"><a href="#MATLAB函数定义示例2" class="headerlink" title="MATLAB函数定义示例2"></a>MATLAB函数定义示例2</h4><p>下面函数实现了从华氏温度到摄氏温度的转换,该函数可以识别输入的待转换样例的个数,当输入的待转换样例个数为0时,退出函数.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function F2C()while 1    F_degree &#x3D; input(&#39;tempreature in Fahrenheit: &#39;, &#39;s&#39;);    F_degree &#x3D; str2num(F_degree);    if isempty(F_degree)        return    end    C_degree &#x3D; (F_degree-32)*5&#x2F;9;    disp([&#39;tempreature in Celsius: &#39; num2str(C_degree)])end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203201516.png" alt="F2C函数执行结果"></p><h3 id="以函数句柄形式定义函数"><a href="#以函数句柄形式定义函数" class="headerlink" title="以函数句柄形式定义函数"></a>以函数句柄形式定义函数</h3><p>我们也可以使用函数句柄的形式定义函数,这更接近数学上的函数定义,其语法如下:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">函数句柄 &#x3D; @(输入变量) 输出变量 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以直接通过函数句柄调用该方法.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x) exp(-2*x);x &#x3D; 0:0.1:2;plot(x, f(x));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="数据类型与文件读写"><a href="#数据类型与文件读写" class="headerlink" title="数据类型与文件读写"></a>数据类型与文件读写</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MATLAB中主要的数据类型如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203202237.png" alt="MATLAB中的数据类型"></p><h3 id="数值类型-numeric"><a href="#数值类型-numeric" class="headerlink" title="数值类型(numeric)"></a>数值类型(numeric)</h3><p>MATLAB支持的数值类型见下表:</p><div class="table-container"><table><thead><tr><th>数值类型</th><th>描述</th></tr></thead><tbody><tr><td><code>double</code></td><td>双精度浮点数</td></tr><tr><td><code>single</code></td><td>单精度浮点数</td></tr><tr><td><code>int8</code></td><td>8位带符号整数</td></tr><tr><td><code>int16</code></td><td>16位带符号整数</td></tr><tr><td><code>int32</code></td><td>32位带符号整数</td></tr><tr><td><code>int64</code></td><td>64位带符号整数</td></tr><tr><td><code>uint8</code></td><td>8位无符号整数</td></tr><tr><td><code>uint16</code></td><td>16位无符号整数</td></tr><tr><td><code>uint32</code></td><td>32位无符号整数</td></tr><tr><td><code>uint64</code></td><td>64位无符号整数</td></tr></tbody></table></div><p>在MATLAB中,数值类型的变量被默认为<code>double</code>类型的,可以使用类型转换将其转换为其他数值类型.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">n &#x3D; 3;class(n) n &#x3D; int8(3);class(n) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ans &#x3D;    &#39;double&#39;ans &#x3D;    &#39;int8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串类型-char"><a href="#字符串类型-char" class="headerlink" title="字符串类型(char)"></a>字符串类型(char)</h3><ul><li><p>在MATLAB中,字符串类型由一对单引号<code>&#39;</code>包裹一段文字来定义.标准ASCII字符可以被转换为对应的ASCII码.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">s1 &#x3D; &#39;h&#39;;uint16(s1)% 得到 104<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>字符串在内存中是以字符矩阵的形式存储的,可以对其进行矩阵的索引以及赋值操作:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">str1 &#x3D; &#39;hello&#39;;str2 &#x3D; &#39;world&#39;;str3 &#x3D; [str1 str2];size(str3)% 得到 [1 10]str4 &#x3D; [str1; str2];size(str4)% 得到 [2 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">str &#x3D; &#39;aardvark&#39;;&#39;a&#39; &#x3D;&#x3D; str% 得到 [1 1 0 0 0 1 0 0]str(str &#x3D;&#x3D; &#39;a&#39;) &#x3D; &#39;Z&#39;% 得到 &#39;ZZrdvZrk&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="结构体-structure"><a href="#结构体-structure" class="headerlink" title="结构体(structure)"></a>结构体(structure)</h3><p>在MATLAB中,结构体是一个键值对</p><h4 id="结构体的基本使用"><a href="#结构体的基本使用" class="headerlink" title="结构体的基本使用"></a>结构体的基本使用</h4><ul><li>与大多数编程语言类似,MATLAB使用<code>.</code>来访问结构体中的字段:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203202908.png" alt="结构体"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">student.name &#x3D; &#39;John Doe&#39;;student.id &#x3D; &#39;jdo2@sfu.ca&#39;;student.number &#x3D; 301073268;student.grade &#x3D; [100, 75, 73; ...                 95, 91, 85.5; ...                 100, 98, 72];student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对结构体列表使用下标表达式可以扩充或缩减结构体列表.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203203208.png" alt="结构体数组"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">student.name &#x3D; &#39;John Doe&#39;;student.id &#x3D; &#39;jdo2@sfu.ca&#39;;student.number &#x3D; 301073268;student.grade &#x3D; [100, 75, 73; 95, 91, 85.5; 100, 98, 72];studentstudent(2).name &#x3D; &#39;Ann Lane&#39;;student(2).id &#x3D; &#39;aln4@sfu.ca&#39;;student(2).number &#x3D; 301078853;student(2).grade &#x3D; [95 100 90; 95 82 97; 100 85 100];student(1) &#x3D; [] % 删除student列表第一项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体可以级联,即结构体中字段的取值也可以是结构体:</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A &#x3D; struct(&#39;data&#39;, [3 4 7; 8 0 1], ...&#39;nest&#39;, struct(&#39;testnum&#39;, &#39;Test 1&#39;, ...&#39;xdata&#39;, [4 2 8], ...&#39;ydata&#39;, [7 1 6]));A(2).data &#x3D; [9 3 2; 7 6 5];A(2).nest.testnum &#x3D; &#39;Test 2&#39;;A(2).nest.xdata &#x3D; [3 4 2];A(2).nest.ydata &#x3D; [5 0 9];A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="结构体的常用函数"><a href="#结构体的常用函数" class="headerlink" title="结构体的常用函数"></a>结构体的常用函数</h4><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>struct</code></td><td>创建结构体</td></tr><tr><td><code>struct2cell</code></td><td>将结构体转换为元胞数组</td></tr><tr><td><code>cell2struct</code></td><td>将元胞数组转换为结构体</td></tr><tr><td><code>isstruct</code></td><td>判断某变量是否是结构体</td></tr><tr><td><code>structfun</code></td><td>对结构体的每个字段都应用某函数</td></tr><tr><td></td><td></td></tr><tr><td><code>fieldnames</code></td><td>获取结构体的所有字段名</td></tr><tr><td><code>isfield</code></td><td>判断结构体是否包含某字段</td></tr><tr><td><code>getfield</code></td><td>获取结构体某字段的值</td></tr><tr><td><code>setfield</code></td><td>为结构体中的某字段赋值</td></tr><tr><td><code>rmfield</code></td><td>删除结构体中的某字段</td></tr><tr><td><code>orderfields</code></td><td>为结构体字段排序</td></tr></tbody></table></div><h3 id="元胞数组-cell"><a href="#元胞数组-cell" class="headerlink" title="元胞数组(cell)"></a>元胞数组(cell)</h3><p>在MATLAB中,元胞数组是一个可以容纳不同类型元素的数据结构,类似于Python语言中的列表.</p><h4 id="元胞数组的基本使用"><a href="#元胞数组的基本使用" class="headerlink" title="元胞数组的基本使用"></a>元胞数组的基本使用</h4><ul><li><p>使用<code>&#123;&#125;</code>像定义矩阵一样定义元胞数组:</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203205945.png" alt="元胞数组"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A &#x3D; &#123; [1 4 3; 0 5 8; 7 2 9]&#39;Anne Smith&#39; ;...3+7i-pi:pi:pi&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A(1,1)&#x3D;&#123;[1 4 3; 0 5 8; 7 2 9]&#125;;A(1,2)&#x3D;&#123;&#39;Anne Smith&#39;&#125;;A(2,1)&#x3D;&#123;3+7i&#125;;A(2,2)&#x3D;&#123;-pi:pi:pi&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A&#123;1,1&#125;&#x3D;[1 4 3; 0 5 8; 7 2 9];A&#123;1,2&#125;&#x3D;&#39;Anne Smith&#39;;A&#123;2,1&#125;&#x3D;3+7i;A&#123;2,2&#125;&#x3D;-pi:pi:pi;A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面三种方式是等价的,其中第二种方式使用<strong>单元索引</strong>赋值,而第三种方式使用<strong>内容索引</strong>赋值.</p><ul><li><p>有两种方式访问元胞数组中的数据,分别是: <strong>单元索引</strong><code>()</code>和<strong>内容索引</strong><code>&#123;&#125;</code></p><p>因为元胞数组的子集仍为元胞数组,在索引器内容的使用,我们有必要指明我们要访问的的是一个<strong>子元胞数组</strong>还是<strong>元胞数组对应区域中的内容</strong>.</p><ul><li><p>使用<strong>单元索引</strong><code>()</code>,我们得到的是一个<strong>子元胞数组</strong>.</p><ul><li>使用<strong>内容索引</strong><code>&#123;&#125;</code>,我们得到的是<strong>元胞数组对应区域中的内容</strong>.</li></ul></li></ul></li></ul><h4 id="元胞数组的常用函数"><a href="#元胞数组的常用函数" class="headerlink" title="元胞数组的常用函数"></a>元胞数组的常用函数</h4><h3 id="元胞数组的常用函数-1"><a href="#元胞数组的常用函数-1" class="headerlink" title="元胞数组的常用函数"></a>元胞数组的常用函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>cell</code></td><td>创建一个元胞数组</td></tr><tr><td><code>iscell</code></td><td>判断某变量是否为元胞数组</td></tr><tr><td></td><td></td></tr><tr><td><code>cell2mat</code></td><td>将元胞数组转为矩阵</td></tr><tr><td><code>cell2struct</code></td><td>将元胞数组转为结构体</td></tr><tr><td><code>mat2cell</code></td><td>将数组转换为指定大小元胞数组</td></tr><tr><td><code>num2cell</code></td><td>将数组转换为相同大小的元胞数组</td></tr><tr><td><code>struct2cell</code></td><td>将结构体转换为元胞数组</td></tr><tr><td></td><td></td></tr><tr><td><code>celldisp</code></td><td>递归显示元胞数组中的内容</td></tr><tr><td><code>cellplot</code></td><td>以图像形式绘制元胞数组的结构</td></tr><tr><td><code>cellfun</code></td><td>对元胞数组的每个元胞应用某函数</td></tr></tbody></table></div><p>其中<code>mat2cell</code>函数可以在转换的时候指定元胞数组各元胞的尺寸.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; magic(3)b &#x3D; num2cell(a)% 得到% [8] [1] [6]% [3] [5] [7]% [4] [9] [2]c &#x3D; mat2cell(a, [1 2], [2, 1])% 得到% [1x2 double] [6]% [2x2 double] [2x1 double]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高维元胞数组"><a href="#高维元胞数组" class="headerlink" title="高维元胞数组"></a>高维元胞数组</h4><p>一个三维的元胞数组可以有<strong>行</strong>(row),<strong>列</strong>(column),<strong>层</strong>(layer)三个维度.在对元胞数组进行索引时,优先级从高到低的顺序分别是: 行→列→层.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203210656.png" alt="高维元胞数组"></p><p>使用<code>cat</code>函数可以在指定维度上对元胞数组进行拼接.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203210809.png" alt="元胞数组的拼接"></p><h3 id="判断变量数据类型的函数"><a href="#判断变量数据类型的函数" class="headerlink" title="判断变量数据类型的函数"></a>判断变量数据类型的函数</h3><p>下列函数可以对变量类型进行判断:</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>isinteger</code></td><td>判断输入参数是否为整型数数组</td></tr><tr><td><code>islogical</code></td><td>判断输入参数是否为逻辑量数组</td></tr><tr><td><code>isnumeric</code></td><td>判断输入参数是否为数值数组</td></tr><tr><td><code>isreal</code></td><td>判断输入参数是否为实数数组</td></tr><tr><td><code>ischar</code></td><td>判断输入参数是否为字符数组</td></tr><tr><td><code>iscell</code></td><td>判断输入参数是否为元胞数组</td></tr><tr><td><code>isfloat</code></td><td>判断输入数组是否为浮点数组</td></tr><tr><td><code>ishandle</code></td><td>判断输入数组是否有效的图形句柄</td></tr><tr><td><code>isempty</code></td><td>判断输入数组是否为空</td></tr><tr><td><code>isprime</code></td><td>确定哪些数组元素为质数</td></tr><tr><td><code>isnan</code></td><td>确定哪些数组元素为<code>NaN</code></td></tr><tr><td><code>isinf</code></td><td>确定哪些数组元素为<code>Inf</code></td></tr><tr><td><code>isequal</code></td><td>判断数组是否相等</td></tr></tbody></table></div><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>支持的文件类型如下:</p><div class="table-container"><table><thead><tr><th>文件内容</th><th>扩展名</th><th>读取文件的函数</th><th>写入文件的函数</th></tr></thead><tbody><tr><td>MATLAB数据</td><td><code>*.mat</code></td><td><code>load</code></td><td><code>save</code></td></tr><tr><td>Excel表格</td><td><code>*.xls</code>,<code>*.xlsx</code></td><td><code>xlsread</code></td><td><code>xlswrite</code></td></tr><tr><td>空格分隔的数字</td><td><code>*.txt</code></td><td><code>load</code></td><td><code>save</code></td></tr></tbody></table></div><h3 id="读写MATLAB格式的数据"><a href="#读写MATLAB格式的数据" class="headerlink" title="读写MATLAB格式的数据"></a>读写MATLAB格式的数据</h3><p>MATLAB工作区内的数据可以以<code>*.mat</code>格式保存在文件中.使用<code>save</code>函数将数据存入文件,使用<code>load</code>函数从文件中读取数据.</p><ul><li><p><code>save</code></p><p>函数的语法如下:</p><ul><li><code>save(filename,variables)</code>将变量<code>variables</code>以二进制形式存入文件中.</li><li><code>save(filename,variables,&#39;-ascii&#39;)</code>将变量<code>variables</code>以文本形式存入文件中.</li></ul></li><li><p><code>load</code></p><p>函数的语法如下:</p><ul><li><code>load(filename)</code>从二进制形式文件中读取数据.</li><li><code>load(filename,&#39;-ascii&#39;)</code>从文本形式文件中读取数据.</li></ul></li></ul><p>其中参数<code>filename</code>和<code>variables</code>都是字符串格式,若不指定<code>variables</code>参数,则将当前工作区内所有变量存入文件中.</p><blockquote><p>复杂的数据格式,如<code>struct</code>和<code>cell</code>,不支持以二进制格式存储.</p></blockquote><h3 id="读写Excel表格"><a href="#读写Excel表格" class="headerlink" title="读写Excel表格"></a>读写Excel表格</h3><p>使用<code>xlsread</code>和<code>xlswrite</code>函数可以读写Excel数据,语法如下:</p><ul><li><p>读取Excel文件的语法:<code>[num,txt,raw] = xlsread(filename,sheet,xlRange)</code></p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203211325.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">Score &#x3D; xlsread(&#39;04Score.xlsx&#39;)Score &#x3D; xlsread(&#39;04Score.xlsx&#39;, &#39;B2:D4&#39;)[Score Header] &#x3D; xlsread(&#39;04Score.xlsx&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>写入Excel的语法:<code>xlswrite(filename,A,sheet,xlRange)</code></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">M &#x3D; mean(Score);xlswrite(&#39;04Score.xlsx&#39;, M, 1, &#39;E2:E4&#39;);xlswrite(&#39;04Score.xlsx&#39;, &#123;&#39;Mean&#39;&#125;, 1, &#39;E1&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h1><h2 id="图线的绘制与装饰"><a href="#图线的绘制与装饰" class="headerlink" title="图线的绘制与装饰"></a>图线的绘制与装饰</h2><h3 id="使用plot-函数绘制图线"><a href="#使用plot-函数绘制图线" class="headerlink" title="使用plot()函数绘制图线"></a>使用<code>plot()</code>函数绘制图线</h3><p>在MATLAB中,使用<code>plot()</code>函数绘制图线,其语法为:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">plot(x,y,LineSpec)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>LineSpec</code>: 图线的线条设定,三个指定<strong>线型</strong>,<strong>标记符号</strong>和<strong>颜色</strong>的<strong>设定符</strong>组成一个字符串,设定符不区分先后.具体细节请参考<a href="https://www.mathworks.com/help/matlab/ref/linespec.html">官方文档</a>.</p><div class="table-container"><table><thead><tr><th>线型符号</th><th>线型设定符</th><th>标记</th><th>标记设定符</th><th>颜色</th><th>颜色设定符</th></tr></thead><tbody><tr><td><code>-</code></td><td>实线（默认）</td><td><code>o</code></td><td>圆圈</td><td><code>y</code></td><td>黄色</td></tr><tr><td><code>--</code></td><td>虚线</td><td><code>+</code></td><td>加号</td><td><code>m</code></td><td>品红色</td></tr><tr><td><code>:</code></td><td>点线</td><td><code>*</code></td><td>星号</td><td><code>c</code></td><td>青蓝色</td></tr><tr><td><code>-.</code></td><td>点划线</td><td><code>.</code></td><td>点</td><td><code>r</code></td><td>红色</td></tr><tr><td></td><td></td><td><code>x</code></td><td>叉号</td><td><code>g</code></td><td>绿色</td></tr><tr><td></td><td></td><td><code>s</code></td><td>方形</td><td><code>b</code></td><td>蓝色</td></tr><tr><td></td><td></td><td><code>d</code></td><td>菱形</td><td><code>w</code></td><td>白色</td></tr><tr><td></td><td></td><td><code>^</code></td><td>上三角</td><td><code>k</code></td><td>黑色</td></tr><tr><td></td><td></td><td><code>v</code></td><td>下三角</td><td></td><td></td></tr><tr><td></td><td></td><td><code>&gt;</code></td><td>右三角</td><td></td><td></td></tr><tr><td></td><td></td><td><code>&lt;</code></td><td>左三角</td><td></td><td></td></tr><tr><td></td><td></td><td><code>p</code></td><td>五角形</td><td></td><td></td></tr><tr><td></td><td></td><td><code>h</code></td><td>六角形</td><td></td></tr></tbody></table></div><p>注：Python中的matplotlib的画图方式和这里几乎一样</p><h3 id="装饰图线"><a href="#装饰图线" class="headerlink" title="装饰图线"></a>装饰图线</h3><ul><li><p>使用<code>legend()</code>函数为图片增加图例</p><p>  使用<code>legend(label1, ..., labelN)</code>函数可以为图片添加图例.</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x&#x3D;0:0.5:4*pi;y&#x3D;sin(x); h&#x3D;cos(x); w&#x3D;1.&#x2F;(1+exp(-x)); g&#x3D;(1&#x2F;(2*pi*2)^0.5).*exp((-1.*(x-2*pi).^2).&#x2F;(2*2^2));plot(x,y,&#39;bd-&#39; ,x,h,&#39;gp:&#39;,x,w,&#39;ro-&#39; ,x,g,&#39;c^-&#39;);% 绘制多条图线legend(&#39;sin(x)&#39;,&#39;cos(x)&#39;,&#39;Sigmoid&#39;,&#39;Gauss function&#39;);% 添加图例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213101.jpeg" alt="使用legend增加图例"></p></li><li><p>使用<code>title()</code>和<code>*label()</code>为图片增加标题和标签</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 0:0.1:2*pi; y1 &#x3D; sin(x); y2 &#x3D; exp(-x);plot(x, y1, &#39;--*&#39;, x, y2, &#39;:o&#39;);xlabel(&#39;t &#x3D; 0 to 2\pi&#39;);ylabel(&#39;values of sin(t) and e^&#123;-x&#125;&#39;)title(&#39;Function Plots of sin(t) and e^&#123;-x&#125;&#39;);legend(&#39;sin(t)&#39;,&#39;e^&#123;-x&#125;&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213130.jpeg" alt="使用title()和*label()为图片增加标题和标签"></p></li></ul><ul><li><p>使用<code>text()</code>和<code>annotation()</code>为图片增加注解</p>  <pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; linspace(0,3); y &#x3D; x.^2.*sin(x); plot(x,y);line([2,2],[0,2^2*sin(2)]);str &#x3D; &#39;$$ \int_&#123;0&#125;^&#123;2&#125; x^2\sin(x) dx $$&#39;;text(0.25,2.5,str,&#39;Interpreter&#39;,&#39;latex&#39;);annotation(&#39;arrow&#39;,&#39;X&#39;,[0.32,0.5],&#39;Y&#39;,[0.6,0.4]); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213259.jpeg" alt="使用text()和annotation()为图片增加注解"></p></li></ul><h3 id="控制坐标轴-边框与网格"><a href="#控制坐标轴-边框与网格" class="headerlink" title="控制坐标轴,边框与网格"></a>控制坐标轴,边框与网格</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>grid on/off</code></td><td>设置网格可见性</td></tr><tr><td><code>box on/off</code></td><td>设置边框可见性</td></tr><tr><td><code>axis on/off</code></td><td>设置坐标轴可见性</td></tr><tr><td><code>axis normal</code></td><td>还原默认行为,将图框纵横比模式和数据纵横比模式的属性设置为自动</td></tr><tr><td><code>axis square</code></td><td>使用相同长度的坐标轴线,相应调整数据单位之间的增量</td></tr><tr><td><code>axis equal</code></td><td>沿每个坐标轴使用相同的数据单位长度</td></tr><tr><td><code>axis tight</code></td><td>将坐标轴范围设置为等同于数据范围,使轴框紧密围绕数据</td></tr></tbody></table></div><p>下面的例子演示<code>axis</code>命令的效果:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">t &#x3D; 0:0.1:2*pi; x &#x3D; 3*cos(t); y &#x3D; sin(t);subplot(2, 2, 1); plot(x, y); axis normalsubplot(2, 2, 2); plot(x, y); axis squaresubplot(2, 2, 3); plot(x, y); axis equalsubplot(2, 2, 4); plot(x, y); axis equal tight<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213545.png" alt="axis命令的效果"></p><h2 id="绘制多条图线"><a href="#绘制多条图线" class="headerlink" title="绘制多条图线"></a>绘制多条图线</h2><h3 id="在一个图像上绘制多条图线"><a href="#在一个图像上绘制多条图线" class="headerlink" title="在一个图像上绘制多条图线"></a>在一个图像上绘制多条图线</h3><p>默认情况下,每次执行<code>plot()</code>函数都会清除上一次绘图的结果,多次执行<code>plot()</code>只会保留最后一次绘制的图形.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213755.jpeg" alt="多次执行plot只会保留最后一次绘制的图形"></p><p>我们可以使用<code>hold on</code>和<code>hold off</code>命令控制绘图区域的刷新,使得多个绘图结果同时保留在绘图区域中.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on% 提起画笔,开始绘制一组图片plot(cos(0:pi&#x2F;20:2*pi));plot(sin(0:pi&#x2F;20:2*pi));hold off% 放下画笔,该组图片绘制完毕<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203213800.jpeg" alt="使用hold命令控制绘图区域的刷新"></p><h3 id="在一个窗口内绘制多个图像"><a href="#在一个窗口内绘制多个图像" class="headerlink" title="在一个窗口内绘制多个图像"></a>在一个窗口内绘制多个图像</h3><p>subplot</p><h2 id="图形对象的操作"><a href="#图形对象的操作" class="headerlink" title="图形对象的操作"></a>图形对象的操作</h2><p>在MATLAB中,图形都是以对象的形式储存在内存中,通过获取其图形句柄可以对其进行操作.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214106.png" alt="在MATLAB中图形都是以对象的形式储存的"></p><h3 id="获取图形句柄"><a href="#获取图形句柄" class="headerlink" title="获取图形句柄"></a>获取图形句柄</h3><p>图形句柄本质上就是一个浮点数,可以唯一确定一个图形对象.下面几个函数用于获取图形句柄.</p><div class="table-container"><table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody><tr><td><code>gca()</code></td><td>获取当前坐标轴的句柄</td></tr><tr><td><code>gcf()</code></td><td>获取当前图像的句柄</td></tr><tr><td><code>allchild(handle_list)</code></td><td>获取该对象的所有子对象的句柄</td></tr><tr><td><code>ancestor(h,type)</code></td><td>获取对象最近的<code>type</code>类型的祖先节点</td></tr><tr><td><code>delete(h)</code></td><td>删除某对象</td></tr><tr><td><code>findall(handle_list)</code></td><td>获取该对象的后代对象</td></tr></tbody></table></div><p>所有绘图函数也会返回图形对象的句柄.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214204.png" alt="绘图函数也会返回图形对象的句柄"></p><h3 id="通过图形句柄操作图形属性"><a href="#通过图形句柄操作图形属性" class="headerlink" title="通过图形句柄操作图形属性"></a>通过图形句柄操作图形属性</h3><p>使用<code>get()</code>和<code>set()</code>函数可以对图形对象的属性进行访问和修改.访问<a href="http://www.mathworks.com/help/matlab/ref/figure-properties.html">官方文档</a>可以查看所有图形对象的属性.</p><ul><li><p><code>set(H,Name,Value)</code></p></li><li><p><code>v = get(h,propertyName)</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214258.png" alt="图形对象的属性"></p><p>下面两个例子演示使用图形句柄操作图形对象:</p><ol><li><p>改变坐标轴属性:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 第一张图set(gca, &#39;FontSize&#39;, 25);% 第二张图set(gca, &#39;XTick&#39;, 0:pi&#x2F;2:2*pi);set(gca, &#39;XTickLabel&#39;, 0:90:360);% 第三张图set(gca, &#39;FontName&#39;, &#39;symbol&#39;);set(gca, &#39;XTickLabel&#39;, &#123;&#39;0&#39;, &#39;p&#x2F;2&#39;, &#39;p&#39;, &#39;3p&#x2F;2&#39;, &#39;2p&#39;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214348.jpeg" alt="句柄操作实例1"></p></li><li><p>改变线型</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h &#x3D; plot(x,y); set(h, &#39;LineStyle&#39;,&#39;-.&#39;, ...&#39;LineWidth&#39;, 7.0, ...&#39;Color&#39;, &#39;g&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203214348.jpeg" alt="句柄操作实例2"></p></li></ol><h3 id="将图形保存到文件"><a href="#将图形保存到文件" class="headerlink" title="将图形保存到文件"></a>将图形保存到文件</h3><p>使用<code>saveas(fig,filename)</code>命令可以将图形对象保存到文件中,其中<code>fig</code>为图形句柄,<code>filname</code>为文件名.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">saveas(gcf, &#39;myfigure.png&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="绘制高级图表"><a href="#绘制高级图表" class="headerlink" title="绘制高级图表"></a>绘制高级图表</h1><h2 id="二维图表"><a href="#二维图表" class="headerlink" title="二维图表"></a>二维图表</h2><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><div class="table-container"><table><thead><tr><th>函数</th><th>图形描述</th></tr></thead><tbody><tr><td><code>loglog()</code></td><td>x轴和y轴都取对数坐标</td></tr><tr><td><code>semilogx()</code></td><td>x轴取对数坐标,y轴取线性坐标</td></tr><tr><td><code>semilogy()</code></td><td>x轴取线性坐标,y轴取对数坐标</td></tr><tr><td><code>plotyy()</code></td><td>带有两套y坐标轴的线性坐标系</td></tr><tr><td><code>ploar()</code></td><td>极坐标系</td></tr></tbody></table></div><h4 id="对数坐标系图线"><a href="#对数坐标系图线" class="headerlink" title="对数坐标系图线"></a>对数坐标系图线</h4><p>下面例子演示对数坐标系图线:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; logspace(-1,1,100); y &#x3D; x.^2;subplot(2,2,1);plot(x,y);title(&#39;Plot&#39;);subplot(2,2,2);semilogx(x,y);title(&#39;Semilogx&#39;);subplot(2,2,3);semilogy(x,y);title(&#39;Semilogy&#39;);subplot(2,2,4);loglog(x, y);title(&#39;Loglog&#39;); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203215844.jpeg" alt="对数坐标系"></p><p>对数坐标系可以加上<strong>网格</strong>,以区分线性坐标系与对数坐标系.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">set(gca, &#39;XGrid&#39;,&#39;on&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220009.jpeg" alt="对数坐标加网格的重要性"></p><h4 id="双y轴图线"><a href="#双y轴图线" class="headerlink" title="双y轴图线"></a>双y轴图线</h4><p><code>plotyy()</code>的返回值为数组<code>[ax,hlines1,hlines2]</code>,其中:</p><ul><li><code>ax</code>为一个向量,保存两个坐标系对象的句柄.</li><li><code>hlines1</code>和<code>hlines2</code>分别为两个图线的句柄.</li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 0:0.01:20;y1 &#x3D; 200*exp(-0.05*x).*sin(x);y2 &#x3D; 0.8*exp(-0.5*x).*sin(10*x);[AX,H1,H2] &#x3D; plotyy(x,y1,x,y2);set(get(AX(1),&#39;Ylabel&#39;),&#39;String&#39;,&#39;Left Y-axis&#39;)set(get(AX(2),&#39;Ylabel&#39;),&#39;String&#39;,&#39;Right Y-axis&#39;)title(&#39;Labeling plotyy&#39;);set(H1,&#39;LineStyle&#39;,&#39;--&#39;); set(H2,&#39;LineStyle&#39;,&#39;:&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220101.jpeg" alt="双y轴图线"></p><h3 id="统计图表"><a href="#统计图表" class="headerlink" title="统计图表"></a>统计图表</h3><div class="table-container"><table><thead><tr><th>函数</th><th>图形描述</th></tr></thead><tbody><tr><td><code>hist()</code></td><td>直方图</td></tr><tr><td><code>bar()</code></td><td>二维柱状图</td></tr><tr><td><code>pie()</code></td><td>饼图</td></tr><tr><td><code>stairs()</code></td><td>阶梯图</td></tr><tr><td><code>stem()</code></td><td>针状图</td></tr></tbody></table></div><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220732.jpeg" alt="直方图"></p><h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><ul><li><p>使用<code>bar()</code>和<code>bar3()</code>函数分别绘制二维和三维直方图</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 4 8]; y &#x3D; [x;1:5];subplot(1,3,1); bar(x); title(&#39;A bargraph of vector x&#39;);subplot(1,3,2); bar(y); title(&#39;A bargraph of vector y&#39;);subplot(1,3,3); bar3(y); title(&#39;A 3D bargraph&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191116210529183.jpg" alt="在这里插入图片描述"></p><blockquote><p><code>hist</code>主要用于查看变量的频率分布,而<code>bar</code>主要用于查看分立的量的统计结果.</p></blockquote></li><li><p>使用<code>barh()</code>函数可以绘制纵向排列的柱状图</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 4 8];y &#x3D; [x;1:5];barh(y);title(&#39;Horizontal&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191116212011255.jpg" alt="纵向排列的柱状图"></p></li><li><p>向<code>bar()</code>传入<code>&#39;stack&#39;</code>参数可以让柱状图以堆栈的形式画出.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 4 8];y &#x3D; [x;1:5];bar(y,&#39;stacked&#39;);title(&#39;Stacked&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203220924.jpeg" alt="堆栈式柱状图"></p></li></ul><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>使用<code>pie()</code>和<code>pie3()</code>可以绘制二维和三维的饼图.向其传入一个bool向量表示每一部分扇区是否偏移.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; [10 5 20 30];subplot(1,3,1); pie(a);subplot(1,3,2); pie(a, [0,0,0,1]);subplot(1,3,3); pie3(a, [0,0,0,1]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221246.jpeg" alt="饼图"></p><h4 id="阶梯图和针状图-绘制离散数字序列"><a href="#阶梯图和针状图-绘制离散数字序列" class="headerlink" title="阶梯图和针状图:绘制离散数字序列"></a>阶梯图和针状图:绘制离散数字序列</h4><p><code>stairs()</code>和<code>stem()</code>函数分别用来绘制阶梯图和针状图,用于表示离散数字序列.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; linspace(0, 4*pi, 40); y &#x3D; sin(x);subplot(1,2,1); stairs(y);subplot(1,2,2); stem(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221311.jpeg" alt="在这里插入图片描述"></p><h2 id="三维图表"><a href="#三维图表" class="headerlink" title="三维图表"></a>三维图表</h2><h4 id="二维图转为三维图"><a href="#二维图转为三维图" class="headerlink" title="二维图转为三维图"></a>二维图转为三维图</h4><p>在MATLAB中,所有的图都是三维图,二维图只不过是三维图的一个投影.点击图形窗口的<code>Rotate 3D</code>按钮,即可通过鼠标拖拽查看该图形的三维视图.</p><h4 id="三维图转换为二维图"><a href="#三维图转换为二维图" class="headerlink" title="三维图转换为二维图"></a>三维图转换为二维图</h4><p>使用<code>imagesc()</code>函数可以将三维图转换为二维俯视图,通过点的颜色指示高度.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">[x, y] &#x3D; meshgrid(-3:.2:3,-3:.2:3); z &#x3D; x.^2 + x.*y + y.^2; subplot(1, 2, 1)surf(x, y, z); subplot(1, 2, 2)imagesc(z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221702.jpeg" alt="在这里插入图片描述"></p><p>使用<code>colorbar</code>命令可以在生成的二维图上增加颜色与高度间对应关系的图例,使用<code>colormap</code>命令可以改变配色方案.具体细节请参考<a href="https://ww2.mathworks.cn/help/matlab/ref/colormap.html?lang=en">官方文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221742.png" alt="在这里插入图片描述"></p><h3 id="三维图的绘制"><a href="#三维图的绘制" class="headerlink" title="三维图的绘制"></a>三维图的绘制</h3><h4 id="绘制三维图前的准备工作"><a href="#绘制三维图前的准备工作" class="headerlink" title="绘制三维图前的准备工作"></a>绘制三维图前的准备工作</h4><ul><li>使用<code>meshgrid()</code>生成二维网格</li></ul><p><code>meshgrid()</code>函数将输入的两个向量进行相应的行扩充和列扩充以得到两个增广矩阵,对该矩阵可应用二元函数.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -2:1:2;y &#x3D; -2:1:2;[X,Y] &#x3D; meshgrid(x,y)Z &#x3D; X.^2 + Y.^2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="绘制三维线"><a href="#绘制三维线" class="headerlink" title="绘制三维线"></a>绘制三维线</h4><p>使用<code>plot3()</code>函数即可绘制三维面,输入应为三个向量.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x&#x3D;0:0.1:3*pi; z1&#x3D;sin(x); z2&#x3D;sin(2.*x); z3&#x3D;sin(3.*x);y1&#x3D;zeros(size(x)); y3&#x3D;ones(size(x)); y2&#x3D;y3.&#x2F;2;plot3(x,y1,z1,&#39;r&#39;,x,y2,z2,&#39;b&#39;,x,y3,z3,&#39;g&#39;); grid on;xlabel(&#39;x-axis&#39;); ylabel(&#39;y-axis&#39;); zlabel(&#39;z-axis&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221905.jpeg" alt="三维曲线"></p><h4 id="绘制三维面"><a href="#绘制三维面" class="headerlink" title="绘制三维面"></a>绘制三维面</h4><p>使用<code>mesh()</code>和<code>surf()</code>命令可以绘制三维面,前者不会填充网格而后者会.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -3.5:0.2:3.5; y &#x3D; -3.5:0.2:3.5;[X,Y] &#x3D; meshgrid(x,y);Z &#x3D; X.*exp(-X.^2-Y.^2);subplot(1,2,1); mesh(X,Y,Z);subplot(1,2,2); surf(X,Y,Z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203221954.png" alt="在这里插入图片描述"></p><h4 id="绘制三维图形的等高线"><a href="#绘制三维图形的等高线" class="headerlink" title="绘制三维图形的等高线"></a>绘制三维图形的等高线</h4><p>使用<code>contour()</code>和<code>contourf()</code>函数可以绘制三维图形的等高线,前者不会填充网格而后者会.</p><p>向<code>contour()</code>函数传入参数或操作图形句柄可以改变图像的细节:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -3.5:0.2:3.5; y &#x3D; -3.5:0.2:3.5;[X,Y] &#x3D; meshgrid(x,y); Z &#x3D; X.*exp(-X.^2-Y.^2);subplot(1,3,1); contour(Z,[-.45:.05:.45]); axis square;subplot(1,3,2); [C,h] &#x3D; contour(Z); clabel(C,h); axis square;subplot(1,3,3); contourf(Z); axis square;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222505.jpeg" alt="在这里插入图片描述"></p><p>使用<code>meshc()</code>和<code>surfc()</code>函数可以在绘制三维图形时绘制其等高线.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -3.5:0.2:3.5; y &#x3D; -3.5:0.2:3.5;[X,Y] &#x3D; meshgrid(x,y); Z &#x3D; X.*exp(-X.^2-Y.^2);subplot(1,2,1); meshc(X,Y,Z);subplot(1,2,2); surfc(X,Y,Z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222646.jpeg" alt="在这里插入图片描述"></p><h4 id="绘制三维体"><a href="#绘制三维体" class="headerlink" title="绘制三维体"></a>绘制三维体</h4><p>使用<code>patch()</code>函数可以绘制三维体.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">v &#x3D; [0 0 0; 1 0 0 ; 1 1 0; 0 1 0; 0.25 0.25 1; 0.75 0.25 1; 0.75 0.75 1; 0.25 0.75 1];f &#x3D; [1 2 3 4; 5 6 7 8; 1 2 6 5; 2 3 7 6; 3 4 8 7; 4 1 5 8];subplot(1,2,1); patch(&#39;Vertices&#39;, v, &#39;Faces&#39;, f, &#39;FaceVertexCData&#39;, hsv(6), &#39;FaceColor&#39;, &#39;flat&#39;);view(3); axis square tight; grid on;subplot(1,2,2); patch(&#39;Vertices&#39;, v, &#39;Faces&#39;, f, &#39;FaceVertexCData&#39;, hsv(8), &#39;FaceColor&#39;,&#39;interp&#39;);view(3); axis square tight; grid on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222800.jpeg" alt="在这里插入图片描述"></p><h3 id="三维图的视角与打光"><a href="#三维图的视角与打光" class="headerlink" title="三维图的视角与打光"></a>三维图的视角与打光</h3><h4 id="调整视角"><a href="#调整视角" class="headerlink" title="调整视角"></a>调整视角</h4><p>使用<code>view()</code>函数可以调整视角,<code>view()</code>函数接受两个浮点型参数,分别表示两个方位角<code>azimuth</code>和<code>elevation</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203222959.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sphere(50); shading flat;material shiny;axis vis3d off;view(-45,20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220203223018.png" alt="image-20220203223018744"></p><h1 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a>符号运算</h1><h2 id="创建符号变量"><a href="#创建符号变量" class="headerlink" title="创建符号变量"></a>创建符号变量</h2><h3 id="创建符号数字"><a href="#创建符号数字" class="headerlink" title="创建符号数字"></a>创建符号数字</h3><p>使用<code>sym</code>函数可以创建符号数字.使用符号数字可以精确地保存无理数,不会产生误差.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sym(1&#x2F;3)% 得到 1&#x2F;31&#x2F;3% 得到 0.3333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将无理数保存为符号数字可以避免将其转换为浮点数的误差:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sin(sym(pi))% 得到 0sin(pi)% 得到 1.2246e-16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建符号变量-1"><a href="#创建符号变量-1" class="headerlink" title="创建符号变量"></a>创建符号变量</h3><p>使用<code>sym</code>和<code>syms</code>可以创建符号变量,区别在于:</p><ol><li><p><code>sym</code>每次只能创建一个符号变量,而<code>syms</code>一次可以创建多个符号变量.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms a% sym命令只能创建一个符号变量syms b c d% syms命令可以创建多个符号变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>若所指定的符号变量已存在,<code>sym</code>不会保留其原有的值,而<code>syms</code>会清空其值.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yf &#x3D; x+y;% 隐式创建符号变量fsym f% 不清空变量f原有的值,即f &#x3D; x + y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yf &#x3D; x+y;% 隐式创建符号变量fsyms f% 清空变量f原有的值,即f &#x3D; f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>sym</code>可以创建符号变量矩阵.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A &#x3D; sym(&#39;a&#39;, [2 5])% 创建一个2*5的符号变量矩阵whos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到的输出如下:</p><pre class="line-numbers language-none"><code class="language-none">A &#x3D;[ a1_1, a1_2, a1_3, a1_4, a1_5][ a2_1, a2_2, a2_3, a2_4, a2_5]    Name      Size            Bytes  Class    Attributes  A         2x5               112  sym      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合使用<code>sym</code>和<code>syms</code>可以快速创建一系列带下标的变量</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear allsyms(sym(&#39;a&#39;, [1 5]))whos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到输出如下:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">Name      Size            Bytes  Class    Attributesa1        1x1                 8  sym                a2        1x1                 8  sym                a3        1x1                 8  sym                a4        1x1                 8  sym                a5        1x1                 8  sym                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="符号运算-1"><a href="#符号运算-1" class="headerlink" title="符号运算"></a>符号运算</h2><h3 id="符号表达式的化简与代入"><a href="#符号表达式的化简与代入" class="headerlink" title="符号表达式的化简与代入"></a>符号表达式的化简与代入</h3><h4 id="符号表达式的化简"><a href="#符号表达式的化简" class="headerlink" title="符号表达式的化简"></a>符号表达式的化简</h4><p>使用<code>simplify()</code>函数可以化简符号表达式.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x a b csimplify(sin(x)^2 + cos(x)^2);% 得到 1simplify(exp(c*log(sqrt(a+b))));% 得到 (a + b)^(c&#x2F;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>表达式化简的标准是不确定的,下面三个函数分别按照不同标准化简表达式:</p><ul><li><p><code>expand()</code>函数可以展开表达式</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xf &#x3D; (x ^2- 1)*(x^4 + x^3 + x^2 + x + 1)*(x^4 - x^3 + x^2 - x + 1);expand(f);% 得到 x^10 - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>factor()</code>函数可以分解因式</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xg &#x3D; x^3 + 6*x^2 + 11*x + 6;factor(g);% 得到 (x + 3)*(x + 2)*(x + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>horner()</code>函数可以将多项式变为嵌套形式</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xh &#x3D; x^5 + x^4 + x^3 + x^2 + x;horner(h);% 得到 x*(x*(x*(x*(x + 1) + 1) + 1) + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="符号表达式的代入"><a href="#符号表达式的代入" class="headerlink" title="符号表达式的代入"></a>符号表达式的代入</h4><p>使用<code>sub(expr, old, new)</code>函数可以将符号表达式<code>expr</code>中的<code>old</code>替换为<code>new</code>.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yf &#x3D; x^2*y + 5*x*sqrt(y);subs(f, x, 3);% 得到 9*y + 15*y^(1&#x2F;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求方程的解析解"><a href="#求方程的解析解" class="headerlink" title="求方程的解析解"></a>求方程的解析解</h3><p>使用<code>solve(eqn,var)</code>和<code>solve(eqns,vars)</code>可以求取方程式的解析解.</p><h4 id="解单变量方程"><a href="#解单变量方程" class="headerlink" title="解单变量方程"></a>解单变量方程</h4><p>使用<code>==</code>定义一个方程,并对其调用<code>solve</code>函数求解.（若不指定<code>==</code>符号右边的值,则默认等式右边为0.）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xeqn &#x3D; x^3 - 6*x^2 &#x3D;&#x3D; 6 - 11*x;solve(eqn);% 得到 [1 2 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解多变量方程"><a href="#解多变量方程" class="headerlink" title="解多变量方程"></a>解多变量方程</h4><p>对于多变量方程,我们需要指定针对哪个变量进行求解.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yeqn &#x3D; [6*x^2 - 6*x^2*y + x*y^2 - x*y + y^3 - y^2 &#x3D;&#x3D; 0];solve(eqn, y);% 得到 [1, 2*x, -3*x]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解方程组"><a href="#解方程组" class="headerlink" title="解方程组"></a>解方程组</h4><p>向<code>solve()</code>函数传入方程组可以解方程.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms u veqns &#x3D; [2*u + v &#x3D;&#x3D; 0, u - v &#x3D;&#x3D; 1];S &#x3D; solve(eqns,[u v]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过变量名索引方程的解,并可以将该解代入其他表达式中.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">S.u;% 得到 1&#x2F;3S.v;% 得到 -2&#x2F;3subs(3*v + u, S);% 得到 -3&#x2F;5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="符号微积分运算"><a href="#符号微积分运算" class="headerlink" title="符号微积分运算"></a>符号微积分运算</h3><h4 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h4><p>使用<code>limit(expr, var, a)</code>函数可以求取符号表达式<code>expr</code>在变量<code>var</code>趋近于<code>a</code>时的极限,添加参数<code>&#39;left&#39;</code>或<code>&#39;right&#39;</code>可以指定左极限或右极限.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x;expr &#x3D; 1&#x2F;x;limit(expr,x,0);% 得到NaNlimit(expr,x,0,&#39;left&#39;);% 得到-Inflimit(expr,x,0,&#39;right&#39;);% 得到Inf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h4><p>使用<code>diff(expr, var, n)</code>函数可以求取符号表达式<code>expr</code>对变量<code>var</code>的<code>n</code>阶微分.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms a b c x;expr &#x3D; a*x^2 + b*x + c;diff(expr, a);% 得到 x^2diff(expr, b);% 得到 xdiff(expr, x);% 得到 b + 2*a*xdiff(expr, x, 2);% 得到 2*a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p>使用<code>int(expr, var)</code>函数可以求取符号表达式<code>expr</code>对变量<code>var</code>的不定积分.使用<code>int(expr, var, [a, b])</code>函数可以指定上下限求定积分,<code>a</code>和<code>b</code>可以是符号表达式.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x a bexpr &#x3D; -2*x&#x2F;(1+x^2)^2;int(expr, x);% 得到 1&#x2F;(x^2 + 1)int(expr, x, [1, 2]);% 得到 -0.3int(expr, x, [1, Inf]);% 得到 -0.5int(expr, x, [a, b]);% 得到 1&#x2F;(b^2 + 1) - 1&#x2F;(a^2 + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一些函数,MATLAB不能求出其积分,这时MATLAB会返回一个未解析(unsolved)的积分形式.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xint(sin(sinh(x)));% 一个无解的积分,MATLAB返回 int(sin(sinh(x)),<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h4><p>使用<code>symsum(expr, k, [a b])</code>计算级数<code>expr</code>的索引<code>k</code>从<code>a</code>到<code>b</code>的加和.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms k xsymsum(k^2, k)% 得到 k^3&#x2F;3 - k^2&#x2F;2 + k&#x2F;6symsum(k^2, k, [0 10])% 得到 385symsum(x^k&#x2F;factorial(k),k,1,Inf)% 得到 exp(x) - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><p>使用<code>taylor(expr,var,a)</code>计算表达式<code>expr</code>在<code>var=a</code>处的泰勒级数.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms xtaylor(exp(x))% 得到 x^5&#x2F;120 + x^4&#x2F;24 + x^3&#x2F;6 + x^2&#x2F;2 + x + 1taylor(sin(x))% 得到 x^5&#x2F;120 - x^3&#x2F;6 + xtaylor(cos(x))% 得到 x^4&#x2F;24 - x^2&#x2F;2 + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><p>可以对符号表达式绘制图像,常用的绘图函数如下:</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>fplot()</code></td><td>绘制符号表达式的二维线图像</td></tr><tr><td><code>fplot3()</code></td><td>绘制符号表达式的三维线图像</td></tr><tr><td><code>ezpolar()</code></td><td>绘制符号表达式的极坐标线图像</td></tr><tr><td><code>fmesh()</code></td><td>绘制网状面图像</td></tr><tr><td><code>fsurf()</code></td><td>绘制带颜色的面图像</td></tr><tr><td><code>fcontour()</code></td><td>绘制轮廓图像</td></tr><tr><td><code>fimplicit()</code></td><td>绘制隐含函数关系的图像</td></tr></tbody></table></div><ol><li><p>下面例子展示二维和三维线图像的绘制</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">subplot(1, 2, 1)syms xf &#x3D; x^3 - 6*x^2 + 11*x - 6;fplot(f, x)subplot(1, 2, 2)syms tfplot3(t^2*sin(10*t), t^2*cos(10*t), t)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191123174049841.png" alt="在这里插入图片描述"></p></li><li><p>下面例子演示三维面的绘制</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yfsurf(x^2 + y^2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191123194055609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25jZXB1X0NoZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>下面例子演示隐含函数关系图像的绘制</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">syms x yeqn &#x3D; (x^2 + y^2)^4 &#x3D;&#x3D; (x^2 - y^2)^2;fimplicit(eqn, [-1 1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191123174144464.png" alt="在这里插入图片描述"></p></li></ol><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="多项式的数值运算"><a href="#多项式的数值运算" class="headerlink" title="多项式的数值运算"></a>多项式的数值运算</h2><h3 id="使用MATLAB表示多项式"><a href="#使用MATLAB表示多项式" class="headerlink" title="使用MATLAB表示多项式"></a>使用MATLAB表示多项式</h3><h4 id="使用向量表示多项式"><a href="#使用向量表示多项式" class="headerlink" title="使用向量表示多项式"></a>使用向量表示多项式</h4><p>在MATLAB中,多项式可以用向量表示,向量中的元素为多项式的系数(降幂排序):第一位为多项式最高次项系数,最后一位为常数项.</p><p>例如多项式:<br>f(x) = x^3 - 2x - 5f(x)=x3−2x−5</p><p>可以用向量<code>p = [1 0 -2 -5]</code>表示.</p><h4 id="多项式求值-polyval"><a href="#多项式求值-polyval" class="headerlink" title="多项式求值:polyval()"></a>多项式求值:<code>polyval()</code></h4><p>使用<code>polyval(p, x)</code>可以计算多项式<code>p</code>在<code>x</code>的每个点处的值.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; [9,-5,3,7]; x &#x3D; -2:0.01:5;f &#x3D; polyval(a,x);plot(x,f);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204115820.jpeg" alt="在这里插入图片描述"></p><h4 id="多项式的乘法-conv"><a href="#多项式的乘法-conv" class="headerlink" title="多项式的乘法:conv()"></a>多项式的乘法:<code>conv()</code></h4><p>使用<code>conv(p1, p2)</code>函数可以对两个向量<code>p1</code>和<code>p2</code>进行卷积相乘,用于计算多项式的乘法.</p><p>例如多项式:<br>f(x) = (x^2+1) (2x+7)f(x)=(x2+1)(2x+7)</p><p>可以使用<code>conv()</code>函数得到展开后的多项式:</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; conv([1 0 1], [2 7])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [2 7 2 7]</code>.</p><h3 id="多项式的数值运算-1"><a href="#多项式的数值运算-1" class="headerlink" title="多项式的数值运算"></a>多项式的数值运算</h3><h4 id="多项式的因式分解-roots"><a href="#多项式的因式分解-roots" class="headerlink" title="多项式的因式分解:roots()"></a>多项式的因式分解:<code>roots()</code></h4><p>使用<code>roots(p)</code>函数可以对多项式<code>p</code>进行因式分解,即求表达式值为0的根.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; roots([1 -3.5 2.75 2.125 -3.875 1.25])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [2 -1, 1+0.5i, 1-0.5i, 0.5]</code>,表示x^5 -3.5 x^4 +2.75 x^3 + 2.125 x^2 + -3.875 x+1.25 = (x-2)(x+1)(x-1-0.5i)(x-1+0.5i)(x-0.5)x5−3.5x4+2.75x3+2.125x2+−3.875x+1.25=(x−2)(x+1)(x−1−0.5i)(x−1+0.5i)(x−0.5).</p><h4 id="多项式的微分-polyder"><a href="#多项式的微分-polyder" class="headerlink" title="多项式的微分:polyder()"></a>多项式的微分:<code>polyder()</code></h4><p>使用<code>polyder(p)</code>函数可以计算多项式的导数.</p><p>例如对下面多项式求导:<br>f(x) = 5x^4 - 2x^2 + 1f(x)=5x4−2x2+1</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; polyder([5 0 -2 0 1]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [20 0 -4 0]</code>,表示计算得到导数f’(x) = 20 x^3 - 4xf′(x)=20x3−4x.</p><h4 id="多项式的积分-polyint"><a href="#多项式的积分-polyint" class="headerlink" title="多项式的积分:polyint()"></a>多项式的积分:<code>polyint()</code></h4><p>使用<code>polyint(p, k)</code>函数可以计算多项式<code>p</code>的积分,积分结果的常数项设为<code>k</code>.</p><p>例如对下面多项式求导:<br>f(x) = 5x^4 - 2x^2 + 1f(x)=5x4−2x2+1</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">p &#x3D; polyint([5 0 -2 0 1], 3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>p = [1 0 -0.6667 0 1 3]</code>,表示计算得到积分\int f(x) dx = x^5 -0.6667x^3 + x + 3∫f(x)dx=x5−0.6667x3+x+3.</p><h2 id="非线性表达式的数值运算"><a href="#非线性表达式的数值运算" class="headerlink" title="非线性表达式的数值运算"></a>非线性表达式的数值运算</h2><h3 id="方程-组-求根fsolve"><a href="#方程-组-求根fsolve" class="headerlink" title="方程(组)求根fsolve()"></a>方程(组)求根<code>fsolve()</code></h3><p>使用<code>fsolve(fun, x0)</code>求非线性方程组的根,<code>fun</code>为待求方程的函数句柄,<code>x0</code>为初值.</p><ol><li><p>求方程1.2x+x\sin(x)+0.3=01.2x+xsin(x)+0.3=0在x=0x=0附近的解.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f2 &#x3D; @(x) (1.2*x+x*sin(x)+0.3);fsolve(f2,0)% 得到 -0.3500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>解方程组<br>\begin{aligned} \left\{ \begin{aligned} e^{-e^{-(x_1+x_2)}} - x_2(1+x_1^2) = 0 \\ x_1 \cos x_2 + x_2 \sin x_1 - \frac{1}{2} = 0 \end{aligned} \right. \end{aligned}⎩⎪⎨⎪⎧​e−e−(x1​+x2​)−x2​(1+x12​)=0x1​cosx2​+x2​sinx1​−21​=0​​</p><p>设定初值为[0, 0][0,0]</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">fun &#x3D; @(x) [exp(-exp(-(x(1)+x(2))))-x(2)*(1+x(1)^2)...    x(1)*cos(x(2)) + x(2)*sin(x(1)) - 0.5]x0 &#x3D; [0,0];x &#x3D; fsolve(fun,x0)% 得到[0.3532 0.6061]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h3><h4 id="求差分-diff"><a href="#求差分-diff" class="headerlink" title="求差分:diff()"></a>求差分:<code>diff()</code></h4><p>使用<code>diff(X, n)</code>计算向量<code>X</code>的<code>n</code>阶差分,<code>n</code>默认为<code>1</code>.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [1 2 5 2 1];diff(x);% 得到 [1 3 -3 -1]diff(x,1);% 得到 [1 3 -3 -1]diff(x,2);% 得到 [2 -6 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求导数-diff-y-diff-x"><a href="#求导数-diff-y-diff-x" class="headerlink" title="求导数:diff(y)./diff(x)"></a>求导数:<code>diff(y)./diff(x)</code></h4><p>使用导数的定义</p><script type="math/tex; mode=display">f'(x_0) = \lim_{h\rarr 0} \frac{f(x_0 + h) - f(x_0)}{h}$</script><p>可以计算函数在某点的近似导数.</p><p>下面程序计算f(x) = x^3f(x)=x3的一阶和二阶导数的值.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; -2:0.005:2; y &#x3D; x.^3;m &#x3D; diff(y).&#x2F;diff(x);% 计算一阶导数m2 &#x3D; diff(m).&#x2F;diff(x(1:end-1));% 计算二阶导数plot(x,y,x(1:end-1),m,x(1:end-2),m2);xlabel(&#39;x&#39;); ylabel(&#39;y&#39;);legend(&#39;f(x) &#x3D;x^3&#39;,&#39;f&#39;&#39;(x)&#39;,&#39;f&#39;&#39;&#39;&#39;(x)&#39;, 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204120807.jpeg" alt="在这里插入图片描述"></p><h3 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h3><h4 id="数值积分原理"><a href="#数值积分原理" class="headerlink" title="数值积分原理"></a>数值积分原理</h4><p>有三种常见算法用于计算数值积分: <strong>矩形法</strong>,<strong>梯形法</strong>,<strong>抛物线法</strong>,它们分别把微分区间的图形视为矩形,梯形,抛物线以计算面积.</p><div class="table-container"><table><thead><tr><th>算法</th><th>图示</th><th>表达式</th></tr></thead><tbody><tr><td>矩形法(Midpoint Rule)</td><td><img src="https://img-blog.csdnimg.cn/20191120165104999.png" alt="在这里插入图片描述"></td><td><script type="math/tex">\int_a^b f(x) dx = 2h \sum_{i=0}^{(n/2)-1} f(x_{2i+1})</script></td></tr><tr><td>梯形法(Trapezoid Rule)</td><td><img src="https://img-blog.csdnimg.cn/20191120165114624.png" alt="在这里插入图片描述"></td><td><script type="math/tex">\int_a^b f(x) dx = \frac{h}{2} \left[ f(a) + 2\sum_{i=1}^{n-1} f(x_i) +f(b) \right]</script></td></tr><tr><td>抛物线法(Simpson’s Rule)</td><td><img src="https://img-blog.csdnimg.cn/20191120165124685.png" alt="在这里插入图片描述"></td><td><script type="math/tex">\int_a^b f(x) dx = \frac{h}{3} \left[ f(a) + 2\sum_{i=1}^{(n/2)-1} f(x_{2i}) + 4\sum_{i=1}^{n/2} f(x_{2i-1}) + f(b) \right]</script></td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/20191120180550884.png" alt="在这里插入图片描述"></p><p>下面分别使用三种方法计算f(x) = 4x^3f(x)=4x3在区间(0, 2)(0,2)内的积分.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h &#x3D; 0.05; x &#x3D; 0:h:2;% 使用矩形法计算近似积分midpoint &#x3D; (x(1:end-1)+x(2:end)).&#x2F;2;y &#x3D; 4*midpoint.^3;s &#x3D; sum(h*y)% 得到 15.9950% 使用梯形法计算近似积分trapezoid &#x3D; (y(1:end-1)+y(2:end))&#x2F;2;s &#x3D; h*sum(trapezoid)% 得到 15.2246% 使用抛物线法计算数值积分s &#x3D; h&#x2F;3*(y(1)+2*sum(y(3:2:end-2))+4*sum(y(2:2:end))+y(end))% 得到 15.8240<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值积分函数-integral"><a href="#数值积分函数-integral" class="headerlink" title="数值积分函数:integral()"></a>数值积分函数:<code>integral()</code></h4><p><code>integral()</code>,<code>integral2()</code>,<code>integral3()</code>分别对函数在<code>xmin</code>至<code>xmax</code>间进行一重,二重,三重积分.</p><p>它们的第一个参数都应该是一个函数句柄,下面例子演示他们的用法:</p><ol><li><p>计算\int_0^2 \frac{1}{x^3-2x-5}∫02x3−2x−51</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x) 1.&#x2F;(x.^3-2*x-5);integral(f,0,2)% 得到 -0.4605<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>计算\int_0^\pi \int_\pi^{2\pi} (y\sin(x) + x \cos(y)) dx dy∫0π∫π2π(ysin(x)+xcos(y))dxdy</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x,y) y.*sin(x)+x.*cos(y);integral2(f,pi,2*pi,0,pi)% 得到 -9.8696<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>计算\int_{-1}^1 \int_0^1 \int_0^\pi (y\sin(x) + z \cos(y)) dx dy dz∫−11∫01∫0π(ysin(x)+zcos(y))dxdydz</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">f &#x3D; @(x,y,z) y.*sin(x)+z.*cos(y);integral3(f,0,pi,0,1,-1,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h1 id="统计与拟合"><a href="#统计与拟合" class="headerlink" title="统计与拟合"></a>统计与拟合</h1><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="描述性统计-Descriptive-Statistics"><a href="#描述性统计-Descriptive-Statistics" class="headerlink" title="描述性统计(Descriptive Statistics)"></a>描述性统计(Descriptive Statistics)</h3><p>描述性统计主要研究数据的<strong>中心趋势</strong>(Central Tendency)和Variation</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204121855.png" alt="在这里插入图片描述"></p><h4 id="中心趋势-Central-Tendency"><a href="#中心趋势-Central-Tendency" class="headerlink" title="中心趋势(Central Tendency)"></a>中心趋势(Central Tendency)</h4><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>mean()</code></td><td>计算平均值</td></tr><tr><td><code>median()</code></td><td>计算中位数</td></tr><tr><td><code>mode()</code></td><td>计算众数</td></tr><tr><td><code>prctile(X,num)</code></td><td>数据X的num%分位数为多少</td></tr><tr><td><code>max()</code></td><td>计算最大值</td></tr><tr><td><code>min()</code></td><td>计算最小值</td></tr></tbody></table></div><p>下列函数绘制统计图表:</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>bar()</code></td><td>绘制条形图</td></tr><tr><td><code>stem()</code></td><td>绘制针状图</td></tr><tr><td><code>area()</code></td><td>绘制填充图</td></tr><tr><td><code>boxplot()</code></td><td>绘制箱线图</td></tr></tbody></table></div><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 1:14;freqy &#x3D; [1 0 1 0 4 0 1 0 3 1 0 0 1 1];subplot(1,3,1); bar(x,freqy); xlim([0 15]);subplot(1,3,2); area(x,freqy); xlim([0 15]);subplot(1,3,3); stem(x,freqy); xlim([0 15]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191125180936445.jpg" alt="在这里插入图片描述"></p><p>  箱线图可以突出显示数据的四分位点.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204122616.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">marks &#x3D; [80 81 81 84 88 92 92 94 96 97];boxplot(marks) % prctile(marks, [25 50 75])% 得到 [81 90 94]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2019112517244367.jpg" alt="在这里插入图片描述"></p><h4 id="Variation"><a href="#Variation" class="headerlink" title="Variation"></a>Variation</h4><h5 id="离散程度"><a href="#离散程度" class="headerlink" title="离散程度"></a>离散程度</h5><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>std()</code></td><td>计算数据的标准差</td></tr><tr><td><code>var()</code></td><td>计算数据的方差</td></tr></tbody></table></div><h5 id="偏度-Skewness"><a href="#偏度-Skewness" class="headerlink" title="偏度(Skewness"></a>偏度(Skewness</h5><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>skewness()</code></td><td>计算数据的偏度</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/20191125164908565.png" alt="在这里插入图片描述"></p><p>偏度反映数据的对称程度</p><ul><li>数据左偏时,其偏度小于0.</li><li>数据完全对称时,其偏度等于0.</li><li>数据右偏时,其偏度大于0.</li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">X &#x3D; randn([10 3]);% 构造10*3的矩阵X(X(:,1)&lt;0, 1) &#x3D; 0; % 将第一列数据右偏X(X(:,3)&gt;0, 3) &#x3D; 0;% 将第二列数据左偏boxplot(X, &#123;&#39;Right-skewed&#39;, &#39;Symmetric&#39;, &#39;Left-skewed&#39;&#125;);skewness(X);% 得到 [0.5162 -0.7539 -1.1234]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191125172206776.jpg" alt="在这里插入图片描述"></p><h5 id="峰度-Kurtosis"><a href="#峰度-Kurtosis" class="headerlink" title="峰度(Kurtosis)"></a>峰度(Kurtosis)</h5><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>kurtosis()</code></td><td>计算数据的峰度</td></tr></tbody></table></div><p>峰度(Kurtosis)表征概率密度分布曲线在平均值处峰值的高低.直观来看,峰度反映了峰部的尖度.</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204123115.png" alt="在这里插入图片描述"></p><h3 id="统计推断-Inferential-Statistics"><a href="#统计推断-Inferential-Statistics" class="headerlink" title="统计推断(Inferential Statistics)"></a>统计推断(Inferential Statistics)</h3><p>推论统计的核心即为假设检验.下列函数用于进行假设检验.</p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>ttest()</code></td><td>进行T检验</td></tr><tr><td><code>ztest()</code></td><td>进行Z检验</td></tr><tr><td><code>ranksum()</code></td><td>进行秩和检验</td></tr><tr><td><code>signrank()</code></td><td>进行符号秩检验</td></tr></tbody></table></div><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">load examgradesx &#x3D; grades(:,1);y &#x3D; grades(:,2);[h,p] &#x3D; ttest(x,y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行上述程序,得到<code>[h p] = [0 0.9805]</code>,表示在默认显著性水平(5%)下我们没有理由拒绝<code>x</code>与<code>y</code>同分布.</p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><h3 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h3><h4 id="一元多项式拟合-polyfit"><a href="#一元多项式拟合-polyfit" class="headerlink" title="一元多项式拟合:polyfit()"></a>一元多项式拟合:<code>polyfit()</code></h4><p>使用<code>polyfit(x, y, n)</code>函数对数据<code>x</code>和<code>y</code>进行<code>n</code>次多项式拟合.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; [-1.2 -0.5 0.3 0.9 1.8 2.6 3.0 3.5];y &#x3D; [-15.6 -8.5 2.2 4.5 6.6 8.2 8.9 10.0];for i &#x3D; 1:3 % 分别进行一次,二次,三次拟合    p &#x3D; polyfit(x, y, i);    xfit &#x3D; x(1):0.1:x(end); yfit &#x3D; polyval(p, xfit);    subplot(1, 3, i); plot(x, y, &#39;ro&#39;, xfit, yfit);    legend(&#39;Data points&#39;, &#39;Fitted curve&#39;, &#39;Location&#39;, &#39;southeast&#39;);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204123618.png" alt="untitled"></p><h4 id="多元线性拟合-regress"><a href="#多元线性拟合-regress" class="headerlink" title="多元线性拟合:regress()"></a>多元线性拟合:<code>regress()</code></h4><p>使用<code>regress(y, X)</code>函数对数据<code>X</code>和<code>y</code>进行多元线性回归.</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">load carsmall;y &#x3D; MPG; x1 &#x3D; Weight; x2 &#x3D; Horsepower;% 导入数据集X &#x3D; [ones(length(x1),1) x1 x2];% 构建增广X矩阵b &#x3D; regress(y,X);% 进行线性回归% 下面是绘图语句x1fit &#x3D; min(x1):100:max(x1); x2fit &#x3D; min(x2):10:max(x2);[X1FIT,X2FIT] &#x3D; meshgrid(x1fit,x2fit);YFIT &#x3D; b(1)+b(2)*X1FIT+b(3)*X2FIT;scatter3(x1,x2,y,&#39;filled&#39;); hold on;mesh(X1FIT,X2FIT,YFIT); hold off;xlabel(&#39;Weight&#39;); ylabel(&#39;Horsepower&#39;); zlabel(&#39;MPG&#39;); view(50,10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204123757.png" alt="untitled"></p><h3 id="非线性拟合"><a href="#非线性拟合" class="headerlink" title="非线性拟合"></a>非线性拟合</h3><p>对于非线性拟合,需要使用曲线拟合工具箱.在命令窗口输入<code>cftool()</code>打开曲线拟合工具箱.</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="一维插值"><a href="#一维插值" class="headerlink" title="一维插值"></a>一维插值</h3><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>interp1(x,v)</code>或<code>interp1(x,v,xq)</code></td><td>线性插值</td></tr><tr><td><code>spline(x,v)</code>或<code>spline(x,v,xq)</code></td><td>三次样条插值</td></tr><tr><td><code>pchip(x,v)</code>或<code>pchip(x,v,xq)</code></td><td>三次Hermite插值</td></tr><tr><td><code>mkpp(breaks,coefs)</code></td><td>生成分段多项式</td></tr><tr><td><code>ppval(pp,xq)</code></td><td>计算分段多项式的插值结果</td></tr></tbody></table></div><p>下面例子演示使用<code>interp1(x, v, xq)</code>进行线性插值和使用<code>spline(x, v, xq)</code>进行三次样条插值.各参数意义如下:</p><ul><li><code>x</code>,<code>v</code>: 待插值样本点.</li><li><code>xq</code>: 查询点,函数返回在这些点处的插值结果.</li></ul><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 构造数据x &#x3D; linspace(0, 2*pi, 40); x_m &#x3D; x; x_m([11:13, 28:30]) &#x3D; NaN; y_m &#x3D; sin(x_m);plot(x_m, y_m, &#39;ro&#39;, &#39;MarkerFaceColor&#39;, &#39;r&#39;); hold on; % 对数据进行线性插值m_i &#x3D; ~isnan(x_m);y_i &#x3D; interp1(x_m(m_i), y_m(m_i), x);plot(x,y_i, &#39;-b&#39;); hold on;% 对数据进行三次样条插值m_i &#x3D; ~isnan(x_m);y_i &#x3D; spline(x_m(m_i), y_m(m_i), x);plot(x,y_i, &#39;-g&#39;); legend(&#39;Original&#39;, &#39;Linear&#39;, &#39;Spline&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204124746.jpeg" alt="在这里插入图片描述"></p><h3 id="二维插值"><a href="#二维插值" class="headerlink" title="二维插值"></a>二维插值</h3><p>使用<code>interp2()</code>可以进行二维插值,向其<code>method</code>参数传入字符串可以指定插值算法.</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th><th>连续性</th></tr></thead><tbody><tr><td><code>&#39;linear&#39;</code></td><td>(默认)在查询点插入的值基于各维中邻点网格点处数值的线性插值.</td><td>C0</td></tr><tr><td><code>&#39;spline&#39;</code></td><td>在查询点插入的值基于各维中邻点网格点处数值的三次插值.插值基于使用非结终止条件的三次样条.</td><td>C2</td></tr><tr><td><code>&#39;nearest&#39;</code></td><td>在查询点插入的值是距样本网格点最近的值.</td><td>不连续</td></tr><tr><td><code>&#39;cubic&#39;</code></td><td>在查询点插入的值基于各维中邻点网格点处数值的三次插值.插值基于三次卷积.</td><td>C1</td></tr><tr><td><code>&#39;makima&#39;</code></td><td>修改后的Akima三次Hermite插值.在查询点插入的值基于次数最大为3的多项式的分段函数,使用各维中相邻网格点的值进行计算.为防过冲,已改进 Akima 公式.</td><td>C1</td></tr></tbody></table></div><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 构建样本点xx &#x3D; -2:.5:2; yy &#x3D; -2:.5:3; [x,y] &#x3D; meshgrid(xx,yy); xx_i &#x3D; -2:.1:2; yy_i &#x3D; -2:.1:3; [x_i,y_i] &#x3D; meshgrid(xx_i,yy_i);z &#x3D; x.*exp(-x.^2-y.^2);% 线性插值subplot(1, 2, 1); z_i &#x3D; interp2(xx,yy,z,x_i,y_i);surf(x_i,y_i,z_i); hold on;plot3(x,y,z+0.01,&#39;ok&#39;,&#39;MarkerFaceColor&#39;,&#39;r&#39;); hold on;% 三次插值subplot(1, 2, 2); z_ic &#x3D; interp2(xx,yy,z,x_i,y_i, &#39;spline&#39;);surf(x_i,y_i,z_ic); hold on;plot3(x,y,z+0.01,&#39;ok&#39;,&#39;MarkerFaceColor&#39;,&#39;r&#39;); hold on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220204125228.png" alt="untitled"></p>]]></content>
    
    
    <summary type="html">在b站学习‘MATLAB教程_台大郭彦甫（14课）’的笔记，梳理原课程的过程中，做了一点改动。</summary>
    
    
    
    <category term="建模" scheme="https://changqingaas.github.io/categories/%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="https://changqingaas.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="建模" scheme="https://changqingaas.github.io/tags/%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>美赛校选培训课笔记</title>
    <link href="https://changqingaas.github.io/others/math/%E7%BE%8E%E8%B5%9B%E6%A0%A1%E9%80%89%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/others/math/%E7%BE%8E%E8%B5%9B%E6%A0%A1%E9%80%89%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-17T01:29:34.000Z</published>
    <updated>2022-02-04T05:53:20.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多元统计分析"><a href="#多元统计分析" class="headerlink" title="多元统计分析"></a>多元统计分析</h1><h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>事先不知道类别的个数与结构；</li><li>进行分析的数据是对象间的相似性或相异性（距离）；</li><li>将距离近的对象归入一类。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>根据分类对象不同分为</p><ul><li><p>Q型聚类：对样本进行聚类</p></li><li><p>R型聚类：对变量进行聚类</p></li></ul></li><li><p>根据聚类方法主要分为</p><ul><li>系统聚类法</li><li>动态聚类法</li></ul></li></ul><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><h4 id="Minikowski距离："><a href="#Minikowski距离：" class="headerlink" title="Minikowski距离："></a>Minikowski距离：</h4><script type="math/tex; mode=display">d(x,y) = [\sum\limits_{k=1}^p|x_{k} - y_{k}|^{m}]^{\frac{1}{m}}，  x,y为p维列向量</script><ul><li>m = 1时，为绝对距离</li><li>m = 2时，为欧氏距离</li><li>m = $\infty$,  为切比雪夫距离，即 $\mathop{max}\limits_{1\le k \le p}|x_{k} - y_{k}|$</li></ul><h4 id="Mahalanobis距离-聚类分析中常用"><a href="#Mahalanobis距离-聚类分析中常用" class="headerlink" title="Mahalanobis距离(聚类分析中常用)"></a>Mahalanobis距离(聚类分析中常用)</h4><script type="math/tex; mode=display">d(x,y) = \sqrt{(x - y)^{T} \sum\nolimits^{-1} (x - y)}</script><p>其中x, y为来自 p 维总体Z的样本观测值，Σ为Z 的协方差矩阵，实际中Σ往往是不知道的，常常需要用样本协方差来估计。马氏距离对一切线性变换是不变的，故不受量纲的影响。 </p><h4 id="R语句："><a href="#R语句：" class="headerlink" title="R语句："></a>R语句：</h4><pre class="line-numbers language-R" data-language="R"><code class="language-R">dist(x,method&#x3D;“euclidean”, diag&#x3D;FALSE, upper&#x3D;FALSE, p&#x3D;2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>method: 计算距离的方法</p><ul><li><p>“euclidean”: 欧式距离</p></li><li><p>“maximum”: Chebyshev距离</p></li><li><p>“manhattan”: 绝对值距离</p></li><li><p>“minkowski”: Minkowski距离，p是Minkowski距离的阶数</p></li></ul></li><li><p>diag=TRUE: 输出对角线上的距离</p></li><li>upper=TRUE: 输出上三角矩阵的值（默认值仅输出下 三角矩阵的值）</li></ul><h4 id="python语句："><a href="#python语句：" class="headerlink" title="python语句："></a>python语句：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rpy2.robjects as robjectsx &#x3D; [1, 2, 6, 8, 11]r &#x3D; robjects.rres &#x3D; r.dist(x)print(res)#    1  2  3  4# 2  1# 3  5  4# 4  7  6  2# 5 10  9  5  3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rpy2import rpy2.robjects.numpy2riR &#x3D; rpy2.robjects.rr_code &#x3D; &quot;&quot;&quot;x&lt;-c(1,2,6,8,11)y&lt;-dist(x)print(y)&quot;&quot;&quot;R(r_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注：我用rpy2来实现这个感觉比较费劲。可能不太能从python 调用R语言，建议直接用R语言吧</li></ul><h3 id="标准化处理"><a href="#标准化处理" class="headerlink" title="标准化处理"></a>标准化处理</h3><p>当指标的测量值相差悬殊时，应先对数据进行标准化处理，再利用标准化的数据计算距离。</p><h4 id="普通标准化变换"><a href="#普通标准化变换" class="headerlink" title="普通标准化变换"></a>普通标准化变换</h4><script type="math/tex; mode=display">X_{ij}^{*} = \frac{X_{ij} - \overline{X}_{j}}{S_{j}}</script><p>i=1,2,…n表示第i个样本，j=1,2,…p表示样本的第j个指标，每个样本均有p个观测指标.       是第j个指标的样本均值</p><h4 id="极差标准化变换"><a href="#极差标准化变换" class="headerlink" title="极差标准化变换"></a>极差标准化变换</h4><script type="math/tex; mode=display">X_{ij}^{*} = \frac{X_{ij} - \overline{X}_{j}}{R_{j}} \\其中，R_{j} = \mathop{\max}\limits_{1\le k \le n}X_{kj} - \mathop{\max}\limits_{1 \le k \le n}X_{kj}</script><h4 id="极差正规化变换"><a href="#极差正规化变换" class="headerlink" title="极差正规化变换"></a>极差正规化变换</h4><script type="math/tex; mode=display">X_{ij}^{*} = \frac{X_{ij} - \mathop{\min}\limits_{1\le k\le n} X_{kj}}{R_{j}}</script><h4 id="程序语句"><a href="#程序语句" class="headerlink" title="程序语句"></a>程序语句</h4><h5 id="数据的中心化和标准化处理"><a href="#数据的中心化和标准化处理" class="headerlink" title="数据的中心化和标准化处理"></a>数据的中心化和标准化处理</h5><h6 id="R语句"><a href="#R语句" class="headerlink" title="R语句"></a>R语句</h6><pre class="line-numbers language-R" data-language="R"><code class="language-R">scale(X,center &#x3D; True, scale &#x3D; True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>X:样本数据矩阵，center = TURE表示对数据做中心化变换，scale=TRUE表示对数据做标准化变化</p><h6 id="python语句"><a href="#python语句" class="headerlink" title="python语句"></a>python语句</h6><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rpy2import numpyimport rpy2.robjects.numpy2rirpy2.robjects.numpy2ri.activate()R &#x3D; rpy2.robjects.rx &#x3D; numpy.array([[1.0, 2.0], [3.0, 1.0]])res &#x3D; R.scale(x, center&#x3D;True, scale&#x3D;True)print(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数据做极差标准化处理"><a href="#数据做极差标准化处理" class="headerlink" title="数据做极差标准化处理"></a>数据做极差标准化处理</h5><pre class="line-numbers language-R" data-language="R"><code class="language-R">x &lt;- data.frame(    points &#x3D; c(99, 97, 104, 79, 84, 88, 91, 99),    rebounds &#x3D; c(34, 40, 41, 38, 29, 30, 22, 25),    blocks &#x3D; c(12, 8, 8, 7, 8, 11, 6, 7))# apply（）函数必须应用于dataframe或matrixcenter &lt;- sweep(x, 2, apply(x, 2, mean))R &lt;- apply(x, 2, max) - apply(x, 2, min)x_star &lt;- sweep(center, 2, R, &quot;&#x2F;&quot;)# 若x_star&lt;-sweep(center, 2, sd(x), &quot;&#x2F;&quot;), 则得到（普通）标准化变换后的数据；print(x_star)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220117160257.png" alt="image-20220117160237414"></p><p>sweep(x, MARGIN, STATS, FUN=”-“, …)</p><ul><li><p>x:数组或矩阵；MARGIN:运算区域，对矩阵1表示行，2表示列；</p></li><li><p>STATS是统计量，apply(x, 2, mean)表示各列的均值；</p></li><li><p>FUN表示函数的运算，缺省值为减法运算。</p></li></ul><h3 id="相似系数"><a href="#相似系数" class="headerlink" title="相似系数"></a>相似系数</h3><p>计算样本不同指标间的相关系数，适用于对变量进行聚类。</p><h3 id="系统聚类法"><a href="#系统聚类法" class="headerlink" title="系统聚类法"></a>系统聚类法</h3><h4 id="聚类分析方法中最常用"><a href="#聚类分析方法中最常用" class="headerlink" title="聚类分析方法中最常用"></a>聚类分析方法中最常用</h4><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>（1）视各样本（或变量）自成一类，规定类与类之间的距离（或相似系数）；</li><li>（2）把最相似的样本（或变量）聚为小类，再将已聚合的小类按相似性再聚合；</li><li>（3）最后将一切子类都聚合到一个大类，从而得到一个按相似性大小聚集起来的谱系关系</li></ul><h4 id="3-根据距离定义的不同分为"><a href="#3-根据距离定义的不同分为" class="headerlink" title="3.根据距离定义的不同分为"></a>3.根据距离定义的不同分为</h4><ul><li>（1）最短距离法：类与类之间的距离定义为两类中最近样本间的距离；</li><li>（2）最长距离法：类与类之间的距离定义为两类中最远样本间的距离；</li><li>（3）类平均法：类与类之间的距离定义为两类中两两样本间距离的平均数；</li></ul><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><pre class="line-numbers language-R" data-language="R"><code class="language-R"> x&lt;-c(1,2,6,8,11); dim(x)&lt;-c(5,1); d&lt;-dist(x) #生成距离结构hc1&lt;-hclust(d, &quot;single&quot;); hc2&lt;-hclust(d, &quot;complete&quot;)hc3&lt;-hclust(d, &quot;median&quot;); hc4&lt;-hclust(d, &quot;mcquitty&quot;) #生成系统聚类opar &lt;- par(mfrow &#x3D; c(2, 2))plot(hc1,hang&#x3D;-1); plot(hc2,hang&#x3D;-1)plot(hc3,hang&#x3D;-1); plot(hc4,hang&#x3D;-1)par(opar)#  画出所有树形结构图，以2*2的形式画在一张图上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hclust():进行系统聚类的计算<br>plot():画出系统聚类的树形图<br>hclust(d, method = “complete”)<br>d:dist构成的距离结构，<br>method:系统聚类的方法（默认为最长距离法），其参数有：<br>（1）“single”：最短距离法<br>（2）“complete”：最长距离法<br>（3）“average”：类平均法<br>……<br>plot(x, labels = NULL, hang = 0.1, main = “Cluster<br>Dendrogram”, sb = NULL, xlab = NULL, ylab =”Height”, …)</p><p>x: hclust()函数生成的对象<br>hang: 表明树形图中各类的位置，取负值表示树形图中的类从底部画起<br>main: 绘图名称</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20220117165301.png" alt="image-20220117165300798"></p><h3 id="动态聚类法"><a href="#动态聚类法" class="headerlink" title="动态聚类法"></a>动态聚类法</h3><p>系统聚类：一次形成类后就不再改变；<br>动态聚类：逐步聚类</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先粗略分类，然后按某种最优原则修改不合理的分类，直至分得比较合理为止，形成最终分类结果。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><p>kmeans(x, centers, <em>iter.max</em>=10, <em>nstart</em>=1, algorithm*=c(“Hartigan-Wong”, “Lloyd”, “MacQueen”))</p><ul><li>x是由数据构成的矩阵或数据框，</li><li>centers是聚类的个数或者初始类的中心，</li><li>iter.max为最大迭代次数（最大值为10），</li><li>nstart是随机集合的个数，</li><li>algorithm是动态聚类的算法。</li></ul><pre class="line-numbers language-R" data-language="R"><code class="language-R">X&lt;-data.frame(   x1&#x3D;c(2959.19, 2459.77, 1495.63, 1046.33, 1303.97, 1730.84, 1561.86, 1410.11, 3712.31, 2207.58, 2629.16, 1844.78, 2709.46, 1563.78, 1675.75, 1427.65, 1783.43, 1942.23, 3055.17, 2033.87, 2057.86, 2303.29, 1974.28, 1673.82, 2194.25, 2646.61, 1472.95, 1525.57, 1654.69, 1375.46, 1608.82),    x2&#x3D;c(730.79, 495.47, 515.90, 477.77, 524.29, 553.90, 492.42, 510.71, 550.74, 449.37, 557.32, 430.29, 428.11, 303.65, 613.32, 431.79, 511.88, 512.27, 353.23, 300.82, 186.44, 589.99, 507.76, 437.75, 537.01, 839.70, 390.89, 472.98, 437.77, 480.99, 536.05),   x3&#x3D;c(749.41, 697.33, 362.37, 290.15, 254.83, 246.91, 200.49, 211.88, 893.37, 572.40, 689.73, 271.28, 334.12, 233.81, 550.71, 288.55, 282.84, 401.39, 564.56, 338.65, 202.72, 516.21, 344.79, 461.61, 369.07, 204.44, 447.95, 328.90, 258.78, 273.84, 432.46),    x4&#x3D;c(513.34, 302.87, 285.32, 208.57, 192.17, 279.81, 218.36, 277.11, 346.93, 211.92, 435.69, 126.33, 160.77, 107.90, 219.79, 208.14, 201.01, 206.06, 356.27, 157.78, 171.79, 236.55, 203.21, 153.32, 249.54, 209.11, 259.51, 219.86, 303.00, 317.32, 235.82),   x5&#x3D;c(467.87, 284.19, 272.95, 201.50, 249.81, 239.18, 220.69, 224.65, 527.00, 302.09, 514.66, 250.56, 405.14, 209.70,272.59, 217.00, 237.60, 321.29, 811.88, 329.06, 329.65, 403.92, 240.24, 254.66, 290.84, 379.30, 230.61, 206.65, 244.93, 251.08, 250.28),   x6&#x3D;c(1141.82, 735.97, 540.58, 414.72, 463.09, 445.20, 459.62, 376.82, 1034.98, 585.23, 795.87, 513.18, 461.67, 393.99, 599.43, 337.76, 617.74, 697.22, 873.06, 621.74, 477.17, 730.05, 575.10, 445.59, 561.91, 371.04, 490.90, 449.69, 479.53, 424.75, 541.30),   x7&#x3D;c(478.42, 570.84, 364.91, 281.84, 287.87, 330.24, 360.48, 317.61, 720.33, 429.77, 575.76, 314.00, 535.13, 509.39, 371.62, 421.31, 523.52, 492.60, 1082.82, 587.02, 312.93,438.41, 430.36, 346.11, 407.70, 269.59, 469.10, 249.66, 288.56, 228.73, 344.85),   x8&#x3D;c(457.64, 305.08, 188.63, 212.10, 192.96, 163.86, 147.76, 152.85, 462.03, 252.54, 323.36, 151.39, 232.29, 160.12, 211.84, 165.32, 182.52, 226.45, 420.81, 218.27, 279.19, 225.80, 223.46, 191.48, 330.95, 389.33, 191.34, 228.19, 236.51, 195.93, 214.40),   row.names &#x3D; c(&quot;北京&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;山西&quot;, &quot;内蒙古&quot;, &quot;辽宁&quot;, &quot;吉林&quot;, &quot;黑龙江&quot;, &quot;上海&quot;, &quot;江苏&quot;, &quot;浙江&quot;, &quot;安徽&quot;, &quot;福建&quot;, &quot;江西&quot;, &quot;山东&quot;,  &quot;河南&quot;, &quot;湖北&quot;, &quot;湖南&quot;, &quot;广东&quot;, &quot;广西&quot;, &quot;海南&quot;, &quot;重庆&quot;, &quot;四川&quot;, &quot;贵州&quot;, &quot;云南&quot;, &quot;西藏&quot;, &quot;陕西&quot;, &quot;甘肃&quot;, &quot;青海&quot;, &quot;宁夏&quot;, &quot;新疆&quot;))kmeans(scale(X),5)K-means clustering with 5 clusters of sizes 10, 7, 3, 7, 4Clustering vector:  北京   天津   河北   山西 内蒙古   辽宁   吉林 黑龙江   上海   江苏      5      4      3      3      3      3      3      3      5      4   浙江   安徽   福建   江西   山东   河南   湖北   湖南   广东   广西      5      1      2      1      4      1      1      4      5      2   海南   重庆   四川   贵州   云南   西藏   陕西   甘肃   青海   宁夏      2      4      1      1      4      4      1      3      3      3   新疆     3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>实际问题中的变量的重要性有所不同，且众多变量间有一定的相关关系。通过这种相关性对这些变量加以改造，用为数较少的新变量反映原变量提供的大部分信息，简化原问题。即数据降维</p><p>主成分分析法就是在这种降维思想下产生的处理高维数据的统计方法。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>通过适当构造原变量的线性组合，产生一列互不相关的新变量，从中选出少数几个新变量并使它们含有尽可能多的原变量带有的信息，从而使用少数几个新变量代替原变量，以分析原问题。</p><p>变量中所含“信息”的大小通常用该变量的方差或样本方差来度量。</p><p>如常数a,Var(a) = 0 ,我们通过a，只能知道a这个常数，其所含信息少。</p><h3 id="主成分的定义"><a href="#主成分的定义" class="headerlink" title="主成分的定义"></a>主成分的定义</h3><p>设$X = (X_{1}, X_{2},……,X_{p})^{T}$为实际问题涉及的p个随机变量构成的向量，记X的均值为$\mu$，协方差阵为$\sum$.</p><p>考虑线性组合</p><script type="math/tex; mode=display">\left\{\begin{aligned}Y_{1} &  = & a_{1}^{T}X \\. \\. \\Y_{p} &  = & a_{p}^{T}X \\\end{aligned}\right.</script><p>………………………………………………………………………………………………………</p><p>warning： 直接写代码了</p><h3 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h3><h4 id="求矩阵的特征值和特征向量"><a href="#求矩阵的特征值和特征向量" class="headerlink" title="求矩阵的特征值和特征向量"></a>求矩阵的特征值和特征向量</h4><pre class="line-numbers language-R" data-language="R"><code class="language-R">a &lt;- c(1, -2, 0, -2, 5, 0, 0, 0, 2)# 由向量a构造一3列的矩阵， byrow&#x3D;T表示生成矩阵的数据按行放置；b &lt;- matrix(data &#x3D; a, ncol &#x3D; 3, byrow &#x3D; T)c &lt;- eigen(b) # 求b的特征值与特征向量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><p>1.变量之间的关系一般分为两类</p><ul><li>完全确定的关系，即可表达为函数解析式</li><li>非确定的关系，也称相关关系</li></ul><p>2.回归分析研究的主要内容</p><ul><li><p>通过观察或实验数据的处理，找出变量间相关系数的定量数学表达式—经验公式，即进行参数估计，并确定经验回归方程的具体形式</p></li><li><p>检验所建立的经验回归方程是否合理</p></li><li><p>利用合理的回归方程对随机变量Y进行预测和控制。</p></li></ul>]]></content>
    
    
    <summary type="html">美赛培训课：多元统计分析，线性模型</summary>
    
    
    
    
    <category term="数学" scheme="https://changqingaas.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="美赛" scheme="https://changqingaas.github.io/tags/%E7%BE%8E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Policy Gradient Methods</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Policy%20Gradient%20Mwthods/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Policy%20Gradient%20Mwthods/</id>
    <published>2021-10-06T15:00:33.000Z</published>
    <updated>2021-10-06T04:57:07.546Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博文的内容整理了我们如何去近似价值函数或者是动作价值函数的方法：</p><script type="math/tex; mode=display">V_{\theta}(s)\approx V^{\pi}(s) \\Q_{\theta}(s)\approx Q^{\pi}(s, a)</script><p>通过机器学习的方法我们一旦近似了价值函数或者是动作价值函数就可以通过一些策略进行控制，比如  ϵ-greedy。</p><p>通过机器学习的方法我们一旦近似了价值函数或者是动作价值函数就可以通过一些策略进行控制，比如 ϵ -greedy。</p><p>那么我们简单回顾下 RL 的学习目标：通过 agent 与环境进行交互，获取累计回报最大化。既然我们最终要学习如何与环境交互的策略，那么我们可以直接学习策略 ，而之前先近似价值函数，再通过贪婪策略控制的思路更像是”曲线救国”。<br>这就是本篇文章的内容，我们如何直接来学习策略，用数学的形式表达就是：</p><p>$\pi_{\theta}(s, a) = P[a | s, \theta]$</p><p>这就是被称为策略梯度（Policy Gradient，简称PG）算法。</p><p>当然，本篇内容同样的是针对 model-free 的强化学习。</p><h1 id="Value-Based-vs-Policy-Based-RL"><a href="#Value-Based-vs-Policy-Based-RL" class="headerlink" title="Value-Based vs. Policy-Based RL"></a>Value-Based vs. Policy-Based RL</h1><p>Value-Based：</p><ul><li>学习价值函数</li><li>Implicit policy，比如 ϵϵ-greedy</li></ul><p>Policy-Based：</p><ul><li>没有价值函数</li><li>直接学习策略</li></ul><p>Actor-Critic：</p><ul><li>学习价值函数</li><li>学习策略</li></ul><p>三者的关系可以形式化地表示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006124701.png" alt=""></p><p>认识到 Value-Based 与 Policy-Based 区别后，我们再来讨论Policy-Based RL 的优缺点：</p><p>优点：</p><ul><li>收敛性更好</li><li>对于具有高维或者连续动作空间的问题更加有效</li><li>可以学习随机策略</li></ul><p>缺点：</p><ul><li>绝大多数情况下收敛到局部最优点，而非全局最优</li><li>评估一个策略一般情况下低效且存在较高的方差</li></ul><h1 id="Policy-Search"><a href="#Policy-Search" class="headerlink" title="Policy Search"></a>Policy Search</h1><p>我们首先定义下目标函数。</p><h2 id="Policy-Objective-Functions"><a href="#Policy-Objective-Functions" class="headerlink" title="Policy Objective Functions"></a>Policy Objective Functions</h2><p>目标：给定一个带有参数 θ 的策略 π~θ~(s,a)  ，找到最优的参数 θ 。<br>但是我们如何评估不同参数下策略 π~θ(~s,a)  的优劣呢？</p><ul><li>对于episode 任务来说，我们可以使用start value：</li></ul><script type="math/tex; mode=display">J_1(\theta)=V^{\pi_{\theta}}(s_1)=E_{\pi_{\theta}}[v_1]</script><ul><li>对于连续性任务来说，我们可以使用 average value：</li></ul><script type="math/tex; mode=display">J_{avV}(\theta)=\sum_{s}d^{\pi_{\theta}}(s)V^{\pi_{\theta}}(s)</script><p>或者每一步的平均回报：</p><script type="math/tex; mode=display">J_{avR}(\theta)=\sum_{s}d^{\pi_{\theta}}(s)\sum_{a}\pi_{\theta}(s, a)R_s^a</script><p>其中 d^πθ^(s)  是马尔卡夫链在 π~θ~  下的静态分布。</p><h1 id="Policy-Optimisation"><a href="#Policy-Optimisation" class="headerlink" title="Policy Optimisation"></a>Policy Optimisation</h1><p>在明确目标以后，我们再来看基于策略的 RL 为一个典型的优化问题：找出 θ 最大化 J(θ)<br>最优化的方法有很多，比如不依赖梯度（gradient-free）的算法：</p><ul><li>爬山算法</li><li>模拟退火</li><li>进化算法</li><li>…</li></ul><p>但是一般来说，如果我们能在问题中获得梯度的话，基于梯度的最优化方法具有比较好的效果：</p><ul><li>梯度下降</li><li>共轭梯度</li><li>拟牛顿法</li><li>…</li></ul><p>我们本篇讨论梯度下降的方法。</p><h1 id="策略梯度定理"><a href="#策略梯度定理" class="headerlink" title="策略梯度定理"></a>策略梯度定理</h1><h1 id="蒙特卡洛策略梯度算法（REINFORCE）"><a href="#蒙特卡洛策略梯度算法（REINFORCE）" class="headerlink" title="蒙特卡洛策略梯度算法（REINFORCE）"></a>蒙特卡洛策略梯度算法（REINFORCE）</h1><h1 id="Actir-Critic-策略梯度算法"><a href="#Actir-Critic-策略梯度算法" class="headerlink" title="Actir-Critic 策略梯度算法"></a>Actir-Critic 策略梯度算法</h1><p>Monte-Carlo策略梯度的方差较高，因此放弃用return来估计行动-价值函数Q，而是使用 critic 来估计Q：</p><p>$Q_w(s, a)\approx Q^{\pi_{\theta}}(s, a)$</p><p>这就是大名鼎鼎的 Actor-Critic 算法，它有两套参数：</p><ul><li>Critic：更新动作价值函数参数 w </li><li>Actor： 朝着 Critic 方向更新策略参数 θ</li></ul><p>Actor-Critic 算法是一个近似的策略梯度算法：</p><script type="math/tex; mode=display">\triangledown_\theta J(\theta)\approx E_{\pi_{\theta}}[\triangledown_{\theta}\log \pi_{\theta}(s, a)Q_w(s, a)]\\\Delta\theta = \alpha\triangledown_\theta\log\pi_{\theta}(s,a)Q_w(s,a)</script><p>Critic 本质就是在进行策略评估：How good is policy π~θ~  for current parameters θ </p><p>策略评估我们之前介绍过MC、TD、TD(λλ)，以及价值函数近似方法。如下所示，简单的 Actir-Critic 算法 Critic 为动作价值函数近似，使用最为简单的线性方程，即：$Q_w(s, a) = \phi(s, a)^T w$，具体的伪代码如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006125435.png" alt="img"></p><p>在 Actir-Critic 算法中，对策略进行了估计，这会产生误差（bias），但是当满足以下两个条件时，策略梯度是准确的：</p><ul><li>价值函数的估计值没有和策略相违背，即： $\triangledown_w Q_w(s,a) = \triangledown_\theta\log\pi_{\theta}(s,a)$</li><li>价值函数的参数w能够最小化误差，即： $\epsilon = E_{\pi_{\theta}}[(Q^{\pi_{\theta}}(s, a) - Q_w(s,a))^2]$</li></ul><p>最后总结一下策略梯度算法：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006125705.png" alt="img"></p>]]></content>
    
    
    <summary type="html">Policy Gradient Methods</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Value Function Approximation</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Value%20Function%20Approximation/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Value%20Function%20Approximation/</id>
    <published>2021-10-06T15:00:33.000Z</published>
    <updated>2021-10-06T04:08:01.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要值函数近似？"><a href="#为什么需要值函数近似？" class="headerlink" title="为什么需要值函数近似？"></a>为什么需要值函数近似？</h1><p>之前我们提到过各种计算值函数的方法，比如对于 MDP 已知的问题可以使用 Bellman 期望方程求得值函数；对于 MDP 未知的情况，可以通过 MC 以及 TD 方法来获得值函数，为什么需要再进行值函数近似呢？</p><p>其实到目前为止，我们介绍的值函数计算方法都是通过查表的方式获取的：</p><ul><li>表中每一个状态 s  均对应一个 V(s) </li><li>或者每一个状态-动作 <s,a ></li></ul><p>但是对于大型 MDP 问题，上述方法会遇到瓶颈：</p><ul><li>太多的 MDP 状态、动作需要存储</li><li>单独计算每一个状态的价值都非常的耗时</li></ul><p>因此我们需要有一种能够适用于解决大型 MDP 问题的通用方法，这就是本文介绍的值函数近似方法。即：</p><script type="math/tex; mode=display">\hat{v}(s, \mathbf{w}) \approx v_{\pi}(s) \\\text{or } \hat{q}(s, a, \mathbf{w}) \approx q_{\pi}(s, a)</script><p>那么为什么值函数近似的方法可以求解大型 MDP 问题？</p><blockquote><p>对于大型 MDP 问题而言，我们可以近似认为其所有的状态和动作都被采样和计算是不现实的，那么我们一旦获取了近似的值函数，我们就可以对于那些在历史经验或者采样中没有出现过的状态和动作进行泛化（generalize）。</p></blockquote><p>进行值函数近似的训练方法有很多，比如：</p><ul><li>线性回归</li><li>神经网络</li><li>决策树</li><li>…</li></ul><p>此外，针对 MDP 问题的特点，训练函数必须可以适用于非静态、非独立同分布（non-i.i.d）的数据。</p><h1 id="增量方法"><a href="#增量方法" class="headerlink" title="增量方法"></a>增量方法</h1><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="通过随机梯度下降进行值函数近似"><a href="#通过随机梯度下降进行值函数近似" class="headerlink" title="通过随机梯度下降进行值函数近似"></a>通过随机梯度下降进行值函数近似</h3><p>我们优化的目标函数是找到一组参数 w  来最小化最小平方误差（MSE），即：</p><script type="math/tex; mode=display">J(\mathbf{w}) = E_{\pi}[(v_{\pi}(S) - \hat{v}(S, \mathbf{w}))^2]</script><p>通过梯度下降方法来寻优：</p><script type="math/tex; mode=display">\begin{align}\Delta\mathbf{w}&=-\frac{1}{2}\alpha\triangledown_{\mathbf{w}}J(\mathbf{w})\\&=\alpha E_{\pi}\Bigl[\Bigl(v_{\pi}(S) - \hat{v}(S, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}J(\mathbf{w})\Bigr]\end{align}</script><p>对于随机梯度下降（Stochastic Gradient Descent，SGD），对应的梯度：</p><script type="math/tex; mode=display">\Delta\mathbf{w} = \alpha\underbrace{\Bigl(v_{\pi}(S) - \hat{v}(S, \mathbf{w})\Bigr)}_{\text{error}}\underbrace{\triangledown_{\mathbf{w}}\hat{v}(S, \mathbf{w})}_{\text{gradient}}</script><h2 id="值函数近似"><a href="#值函数近似" class="headerlink" title="值函数近似"></a>值函数近似</h2><p>上述公式中需要真实的策略价值函数 vπ(S)vπ(S) 作为学习的目标（supervisor），但是在RL中没有真实的策略价值函数，只有rewards。在实际应用中，我们用v~π~(S)来代替target vπ(S)：</p><ul><li>对于MC，target 为 return G~t ~：</li></ul><script type="math/tex; mode=display">\Delta\mathbf{w}=\alpha\Bigl(G_t - \hat{v}(S_t, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(S_t, \mathbf{w})</script><ul><li>对于TD(0)，target 为TD target $_{t+1}+\gamma\hat{v}(S_{t+1}, \mathbf{w})$：</li></ul><script type="math/tex; mode=display">\Delta\mathbf{w}=\alpha\Bigl(R_{t+1} + \gamma\hat{v}(S_{t+1}, \mathbf{w})- \hat{v}(S_t, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(S_t, \mathbf{w})</script><ul><li>对于TD(λ)，target 为 TD λ-return  $G_t^{\lambda}$：</li></ul><script type="math/tex; mode=display">\Delta\mathbf{w}=\alpha\Bigl(G_t^{\lambda}- \hat{v}(S_t, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(S_t, \mathbf{w})</script><p>在获取了值函数近似后就可以进行控制了，具体示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006115744.png" alt=""></p><h2 id="动作价值函数近似"><a href="#动作价值函数近似" class="headerlink" title="动作价值函数近似"></a>动作价值函数近似</h2><p>动作价值函数近似：</p><script type="math/tex; mode=display">\hat{q}(S, A, \mathbf{w})\approx q_{\pi}(S, A)</script><p>优化目标：最小化MSE</p><script type="math/tex; mode=display">J(\mathbf{w}) = E_{\pi}[(q_{\pi}(S, A) - \hat{q}(S, A, \mathbf{w}))^2]</script><p>使用SGD寻优：</p><script type="math/tex; mode=display">\begin{align} \Delta\mathbf{w} &=-\frac{1}{2}\alpha\triangledown_{\mathbf{w}}J(\mathbf{w})\\ &=\alpha\Bigl(q_{\pi}(S, A)-\hat{q}_{\pi}(S, A, \mathbf{w})\Bigr) \triangledown_{\mathbf{w}}\hat{q}_{\pi}(S, A, \mathbf{w}) \end{align}</script><h1 id="批量方法"><a href="#批量方法" class="headerlink" title="批量方法"></a>批量方法</h1><p>随机梯度下降SGD简单，但是批量的方法可以根据agent的经验来更好的拟合价值函数。</p><h2 id="值函数近似-1"><a href="#值函数近似-1" class="headerlink" title="值函数近似"></a>值函数近似</h2><p>优化目标：批量方法解决的问题同样是  $\hat{v}(s, \mathbf{w})\approx v_{\pi}(s)$</p><p>经验集合  D 包含了一系列的 <state, value> pair：</p><script type="math/tex; mode=display">D=\{<s_1, v_1^{\pi}>, <s_2, v_2^{\pi}>, ..., <s_T, v_T^{\pi}>\}</script><p>根据最小化平方误差之和来拟合 $\hat{v}(s, \mathbf{w})$和 v~π~(s) ，即：</p><script type="math/tex; mode=display">\begin{align}LS(w) &= \sum_{t=1}^{T}(v_{t}^{\pi}-\hat{v}(s_t, \mathbf{w}))^2\\&= E_{D}[(v^{\pi}-\hat{v}(s, \mathbf{w}))^2]\end{align}</script><p>经验回放（Experience Replay）：</p><blockquote><p>给定经验集合：</p><script type="math/tex; mode=display">D=\{<s_1, v_1^{\pi}>, <s_2, v_2^{\pi}>, ..., <s_T, v_T^{\pi}>\}</script><p>Repeat：</p><ol><li>从经验集合中采样状态和价值：<s,v^π^>∼D </li><li>使用SGD进行更新：$\Delta\mathbf{w}=\alpha\Bigl(v^{\pi}-\hat{v}(s, \mathbf{w})\Bigr)\triangledown_{\mathbf{w}}\hat{v}(s, \mathbf{w})$<br>通过上述经验回放，获得最小化平方误差的参数值：</li></ol><p>$\mathbf{w}^{\pi}=\arg\min_{\mathbf{w}}LS(\mathbf{w})$</p></blockquote><p>我们经常听到的 DQN 算法就使用了经验回放的手段，这个后续会在《深度强化学习》中整理。</p><p>通过上述经验回放和不断的迭代可以获取最小平方误差的参数值，然后就可以通过 greedy 的策略进行策略提升，具体如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006120213.png" alt=""></p><h2 id="动作价值函数近似-1"><a href="#动作价值函数近似-1" class="headerlink" title="动作价值函数近似"></a>动作价值函数近似</h2><p>同样的套路：</p><ul><li>优化目标： $\hat{q}(s, a, \mathbf{w})\approx q_{\pi}(s, a)$</li><li>采取包含 <state, action, value> 的经验集合 D </li><li>通过最小化平方误差来拟合</li></ul><p>对于控制环节，我们采取与Q-Learning一样的思路：</p><ul><li>利用之前策略的经验</li><li>但是考虑另一个后继动作 $A’=\pi_{\text{new}}(S_{t+1})$</li><li>朝着另一个后继动作的方向去更新 $\hat{q}(S_t, A_t, \mathbf{w})$，即</li></ul><p>$\delta = R_{t+1} + \gamma\hat{q}(S_{t+1}, \pi{S_{t+1}, \mathbf{\pi}}) - \hat{q}(S_t, A_t, \mathbf{w})$</p><ul><li>梯度：线性拟合情况，$\Delta\mathbf{w}=\alpha\delta\mathbf{x}(S_t, A_t)$</li></ul>]]></content>
    
    
    <summary type="html">Value Function Approximation</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Model-Free Control</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Model-Free%20Control/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Model-Free%20Control/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-06T03:46:55.610Z</updated>
    
    <content type="html"><![CDATA[<p>上篇总结了 Model-Free Predict 问题及方法，本文内容介绍 Model-Free Control 方法，即 “Optimise the value function of an unknown MDP”。</p><p>在这里说明下，Model-Free Predict/Control 不仅适用于 Model-Free 的情况，其同样适用于 MDP 已知的问题：</p><ul><li>MDP model is unknown, but experience can be sampled.</li><li>MDP model is known, but is too big to use, except by samples.</li></ul><p>在正式介绍 Model-Free Control 方法之前，我们先介绍下 On-policy Learning 及 Off-policy Learning。</p><h2 id="On-policy-Learning-vs-Off-policy-Learning"><a href="#On-policy-Learning-vs-Off-policy-Learning" class="headerlink" title="On-policy Learning vs. Off-policy Learning"></a>On-policy Learning vs. Off-policy Learning</h2><p>On-policy Learning：</p><ul><li>“Learn on the job”</li><li>Learn about policy π from experience sampled from π（即采样的策略与学习的策略一致）</li></ul><p>Off-policy Learning：</p><ul><li>“Look over someone’s shoulder”</li><li>Learn about policy π from experience sampled from μ（即采样的策略与学习的策略不一致）</li></ul><h2 id="On-Policy-Monte-Carlo-Learning"><a href="#On-Policy-Monte-Carlo-Learning" class="headerlink" title="On-Policy Monte-Carlo Learning"></a>On-Policy Monte-Carlo Learning</h2><h3 id="Generalized-Policy-Iteration"><a href="#Generalized-Policy-Iteration" class="headerlink" title="Generalized Policy Iteration"></a>Generalized Policy Iteration</h3><p>具体的 Control 方法，在《动态规划》一文中我们提到了 Model-based 下的广义策略迭代 GPI 框架，那在 Model-Free 情况下是否同样适用呢？<br>如下图为 Model-based 下的广义策略迭代 GPI 框架，主要分两部分：策略评估及基于 Greedy 策略的策略提升。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006105433.png" alt=""></p><h4 id="Model-Free-策略评估"><a href="#Model-Free-策略评估" class="headerlink" title="Model-Free 策略评估"></a>Model-Free 策略评估</h4><p>在《Model-Free Predict》中我们分别介绍了两种 Model-Free 的策略评估方法：MC 和 TD。我们先讨论使用 MC 情况下的 Model-Free 策略评估。<br>如上图GPI框架所示：</p><ul><li>基于 V(s) 的贪婪策略提升需要 MDP 已知：</li></ul><script type="math/tex; mode=display">\pi'(s) = \arg\max_{a\in A}\Bigl(R_{s}^{a}+P_{ss'}^{a}V(s')\Bigr)</script><ul><li>基于 Q(s,a) 的贪婪策略提升不需要 MDP 已知，即 Model-Free：</li></ul><script type="math/tex; mode=display">\pi'(s) = \arg\max_{a\in A}Q(s, a)</script><p>因此 Model-Free 下需要对 Q(s,a) 策略评估，整个GPI策略迭代也要基于 Q(s,a) </p><h4 id="Model-Free-策略提升"><a href="#Model-Free-策略提升" class="headerlink" title="Model-Free 策略提升"></a>Model-Free 策略提升</h4><p>确定了策略评估的对象，那接下来要考虑的就是如何基于策略评估的结果 Q(s,a) 进行策略提升。<br>由于 Model-Free 的策略评估基于对经验的 samples（即评估的 q(s,a)  存在 bias），因此我们在这里不采用纯粹的 greedy 策略，防止因为策略评估的偏差导致整个策略迭代进入局部最优，而是采用具有 explore 功能的  ϵ-greedy 算法：</p><script type="math/tex; mode=display">\pi(a|s) = \begin{cases}&\frac{\epsilon}{m} + 1 - \epsilon, &\text{if } a^*=\arg\max_{a\in A}Q(s, a)\\&\frac{\epsilon}{m}, &\text{otherwise}\end{cases}</script><p>因此，我们确定了 Model-Free 下的 Monto-Carlo Control：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006105953.png" alt=""></p><h3 id="GLIE"><a href="#GLIE" class="headerlink" title="GLIE"></a>GLIE</h3><p>先直接贴下David的课件，GLIE 介绍如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006110036.png" alt=""></p><p>对于 ϵ-greedy 算法而言，如果 ϵ 随着迭代次数逐步减为0，那么  ϵ-greedy 是 GLIE，即：</p><script type="math/tex; mode=display">\epsilon_{k} = \frac{1}{k}</script><h4 id="GLIE-Monto-Carlo-Control"><a href="#GLIE-Monto-Carlo-Control" class="headerlink" title="GLIE Monto-Carlo Control"></a>GLIE Monto-Carlo Control</h4><ul><li>对于 episode 中的每个状态 S~t~  和动作 A~t~</li></ul><script type="math/tex; mode=display">N(S_t, A_t) ← N(S_t, A_t) + 1 \\Q(S_t, A_t) ← Q(S_t, A_t) + \frac{1}{N(S_t, A_t)}(G_t - Q(S_t, A_t))</script><ul><li>基于新的动作价值函数提升策略：</li></ul><script type="math/tex; mode=display">\epsilon ← \frac{1}{k}\\\pi ← \epsilon\text{-greedy}(Q)</script><p>定理：GLIE Monto-Carlo Control 收敛到最优的动作价值函数，即：</p><script type="math/tex; mode=display">Q(s, a) → q_*(s, a)</script><h2 id="On-Policy-Temporal-Difference-Learning"><a href="#On-Policy-Temporal-Difference-Learning" class="headerlink" title="On-Policy Temporal-Difference Learning"></a>On-Policy Temporal-Difference Learning</h2><h3 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h3><p>我们之前总结过 TD 相对 MC 的优势：</p><ul><li>低方差</li><li>Online</li><li>非完整序列</li></ul><p>那么一个很自然的想法就是在整个控制闭环中用 TD 代替 MC：</p><ul><li>使用 TD 来计算 Q(S,A) </li><li>仍然使用  ϵ-greedy 策略提升</li><li>每一个 step 进行更新</li></ul><p>通过上述改变就使得 On-Policy 的蒙特卡洛方法变成了著名的 Sarsa。</p><ul><li>更新动作价值函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006110844.png" alt=""></p><ul><li>Control</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006110937.png" alt=""></p><p>Sarsa算法的伪代码如下：<br><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006111038.png" alt="img"></p><h3 id="Sarsa-λ"><a href="#Sarsa-λ" class="headerlink" title="Sarsa(λ)"></a>Sarsa(λ)</h3><p>n-step Sarsa returns 可以表示如下：<br>n=1 时：$q_{t}^{(1)} = R_{t+1} + \gamma Q(S_{t+1})$<br>n=2 时：$q_{t}^{(2)} = R_{t+1} + \gamma R_{t+2} + \gamma^2 Q(S_{t+2})$<br>…<br>n=∞ 时：$q_{t}^{\infty} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{T-1} R_T)$<br>因此，n-step return $q_{t}^{(n)} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{n}Q(S_{t+n})$</p><p>n-step Sarse 更新公式：</p><p>$Q(S_t,A_t) ← Q(S_t,A_t) + \alpha (q_t^{(n)} - Q(S_t,A_t))$</p><p> 具体的 Sarsa(λ) 算法伪代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006111817.png" alt="img"></p><p>其中 E(s,a)   为资格迹。</p><p>下图为 Sarsa(λ) 用于 Gridworld 例子的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006112106.png" alt=""></p><h2 id="Off-Policy-Learning"><a href="#Off-Policy-Learning" class="headerlink" title="Off-Policy Learning"></a>Off-Policy Learning</h2><p>Off-Policy Learning 的特点是评估目标策略 π(a|s) 来计算 v~π~(s) 或者 q~π~(s,a) 但是跟随行为策略 {S~1~,A~1~,R~2~,…,S~T~}∼μ(a|s) </p><p>Off-Policy Learning 有什么意义？</p><ul><li>Learn from observing humans or other agents</li><li>Re-use experience generated from old policies π~1~,π~2~,…,π~t−1~ </li><li>Learn about optimal policy while following exploratory policy</li><li>Learn about multiple policies while following one policy</li></ul><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>重要性采样的目的是：Estimate the expectation of a different distribution。</p><script type="math/tex; mode=display">\begin{align}E_{X\sim P}[f(X)]&= \sum P(X)f(X)\\&= \sum Q(X)\frac{P(X)}{Q(X)}f(X)\\&= E_{X\sim Q}[\frac{P(X)}{Q(X)}f(X)]\end{align}</script><h4 id="Off-Policy-MC-重要性采样"><a href="#Off-Policy-MC-重要性采样" class="headerlink" title="Off-Policy MC 重要性采样"></a>Off-Policy MC 重要性采样</h4><p>使用策略 π  产生的 return 来评估 μ ：</p><script type="math/tex; mode=display">G_t^{\pi/\mu} = \frac{\pi(A_t|S_t)}{\mu(A_t|S_t)} \frac{\pi(A_{t+1}|S_{t+1})}{\mu(A_{t+1}|S_{t+1})}...\frac{\pi(A_T|S_T)}{\mu(A_T|S_T)}G_t</script><p>朝着正确的 return 方向去更新价值：</p><script type="math/tex; mode=display">V(S_t) ← V(S_t) + \alpha\Bigl(\textcolor{Red}{G_t^{\pi/\mu}}-V(S_t)\Bigr)</script><p>需要注意两点：</p><ul><li>Cannot use if μ  is zero when π  is non-zero</li><li>重要性采样会显著性地提升方差</li></ul><h4 id="Off-Policy-TD-重要性采样"><a href="#Off-Policy-TD-重要性采样" class="headerlink" title="Off-Policy TD 重要性采样"></a>Off-Policy TD 重要性采样</h4><p>TD 是单步的，所以使用策略 π  产生的 TD targets 来评估 μ ：</p><script type="math/tex; mode=display">V(S_t) ← V(S_t) + \alpha\Bigl(\frac{\pi(A_t|S_t)}{\mu(A_t|S_t)}(R_{t+1}+\gamma V(S_{t+1}))-V(S_t)\Bigr)</script><ul><li>方差比MC版本的重要性采样低很多</li></ul><h3 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h3><p>前面分别介绍了对价值函数 V(s)  进行 off-policy 学习，现在我们讨论如何对动作价值函数 Q(s,a)  进行 off-policy 学习：</p><ul><li><p>不需要重要性采样</p></li><li><p>使用行为策略选出下一步的动作：$A_{t+1}\sim\mu(·|S_t)$</p></li><li><p>但是仍需要考虑另一个后继动作：$A’\sim\pi(·|S_t)$</p></li><li><p>朝着另一个后继动作的价值更新 $Q(S_t, A_t)$</p></li></ul><script type="math/tex; mode=display">Q(S_t, A_t) ← Q(S_t, A_t) + \alpha\Bigl(R_{t+1}+\gamma Q(S_{t+1}, A')-Q(S_t, A_t)\Bigr)</script><p>讨论完对动作价值函数的学习，我们接着看如何通过 Q-Learning 进行 Control：</p><ul><li>行为策略和目标策略均改进</li><li>目标策略 π  以greedy方式改进：</li></ul><script type="math/tex; mode=display">\pi(S_t) = \arg\max_{a'}Q(S_{t+1}, a')</script><ul><li>行为策略 μ  以  ϵ-greedy 方式改进</li><li>Q-Learning target：</li></ul><script type="math/tex; mode=display">\begin{align}&R_{t+1}+\gamma Q(S_{t+1}, A')\\=&R_{t+1}+\gamma Q\Bigl(S_{t+1}, \arg\max_{a'}Q(S_{t+1}, a')\Bigr)\\=&R_{t+1}+\max_{a'}\gamma Q(S_{t+1}, a')\end{align}</script><p>Q-Learning 的 backup tree 如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114145.png" alt=""></p><p>关于 Q-Learning 的结论：</p><blockquote><p>Q-learning control converges to the optimal action-value function, Q(s,a)→q~∗~(s,a) </p></blockquote><p>Q-Learning 算法具体的伪代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114205.png" alt=""></p><p>对比 Sarsa 与 Q-Learning 可以发现两个最重要的区别：</p><ul><li>TD target 公式不同</li><li>Q-Learning 中下一步的动作从行为策略中选出，而不是目标策略</li></ul><h2 id="DP-vs-TD"><a href="#DP-vs-TD" class="headerlink" title="DP vs. TD"></a>DP vs. TD</h2><p>两者的区别见下表：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114507.png" alt="">  </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211006114532.png" alt=""></p>]]></content>
    
    
    <summary type="html">Model-Free Control</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Cross-entrpy Method</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Cross-entroy%20Method/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Cross-entroy%20Method/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:26:06.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CEM-amp-amp-RL"><a href="#CEM-amp-amp-RL" class="headerlink" title="CEM &amp;&amp; RL"></a>CEM &amp;&amp; RL</h3><p>注：以下内容引自博文《进化策略优化算法CEM(Cross Entropy Method)》[1]。</p><p>CEM也可以用来求解马尔可夫决策过程，也就是强化学习问题。我们知道，强化学习也是一种动态规划过程，在某个状态下选择某个动作就像在某个节点选择路径一样，整个过程就是一个从初始状态到末状态的路径规划问题，只不过我们希望得到一条能最大化收益的路径。在这种考虑下，就可以用CEM建模了，我们让一条完整的路径成为一个样本x=(s0,a0,s1,a1,…,sn,an)，路径获得的总收益为S(x)=∑Ni=0r(si,ai)，目标是最大化这个S(x)，那么如何采样出这些样本呢？我们可以构建一个pp矩阵：矩阵行表示状态，列表示动作，如pij表示在状态si下执行aj动作的概率，我们通过对这个pp矩阵进行多次采样就可以获得多个样本，然后选出S(x)较高的样本用来更新pp矩阵，不断迭代，最终找到最优p^矩阵。</p><p>这是一种类似于策略迭代(policy iteration)的强化学习方法：通过p矩阵找到在每一步状态下各个动作的概率来形成决策策略，但参数更新并没有用到梯度。从另外一个角度，你也可以认为这是一种值迭代(value iteration)的强化学习方法，此时p矩阵就是经典Q-learning中的Q矩阵，只不过Q矩阵中第i行第j列元素表示的是状态si下动作aj的未来收益的期望，基于贝尔曼方程(Bellman equation)来更新Q值；而p矩阵表示的是概率值，通过交叉墒来更新。</p><p>[1] <a href="https://blog.csdn.net/ppp8300885/article/details/80567682">进化策略优化算法CEM(Cross Entropy Method)</a></p>]]></content>
    
    
    <summary type="html">Cross-entrpy Method</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>Model-Free Prediction</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/Model-Free%20Prediction/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/Model-Free%20Prediction/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T15:15:35.589Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了 Model-based 的通用方法——动态规划，本文内容介绍 Model-Free 情况下 Prediction 问题，即 “Estimate the value function of an unknown MDP”。</p><ul><li>Model-based：MDP已知，即转移矩阵和奖赏函数均已知</li><li>Model-Free：MDP未知</li></ul><h2 id="蒙特卡洛学习"><a href="#蒙特卡洛学习" class="headerlink" title="蒙特卡洛学习"></a>蒙特卡洛学习</h2><p>蒙特卡洛方法（Monte-Carlo Methods，简称MC）也叫做蒙特卡洛模拟，是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。其实本质就是，通过尽可能随机的行为产生后验，然后通过后验来表征目标系统。</p><p>在Model-Free的情况下，MC在强化学习中的应用就是获取价值函数，其特点如下：</p><ul><li>MC 可以从完整的 episodes 中学习（no bootstrapping）</li><li>MC 以均值来计算价值，即 value = mean(return)</li><li>MC 只能适用于 episodic MDPs（有限MDPs）</li></ul><h3 id="First-Visit-蒙特卡洛策略评估"><a href="#First-Visit-蒙特卡洛策略评估" class="headerlink" title="First-Visit 蒙特卡洛策略评估"></a>First-Visit 蒙特卡洛策略评估</h3><p>First-Visit Monte-Carlo Policy Evaluation：</p><blockquote><p>评估状态 s  在给定策略 π  下的价值函数 v~π~(s))时，在一次 episode 中，状态 s  在时刻  t <strong>第一次</strong>被访问时，计数器 N(s)←N(s)+1 ，累计价值 S(s)←S(s)+Gt<br>当整个过程结束后，状态 s 的价值  $V(s) = \frac{S(s)}{N(s)}$根据大数定理（Law of Large Numbers）：$V(s) → v_{\pi}(s) \text{ as } N(s) → \infty$</p></blockquote><h3 id="Every-Visit-蒙特卡洛策略评估"><a href="#Every-Visit-蒙特卡洛策略评估" class="headerlink" title="Every-Visit 蒙特卡洛策略评估"></a>Every-Visit 蒙特卡洛策略评估</h3><p>Every-Visit Monte-Carlo Policy Evaluation：</p><blockquote><p>评估状态 s  在给定策略 π 下的价值函数 v~π(~s)时，在一次 episode 中，状态 s 在时刻 t <strong>每次</strong>被访问时，计数器 N(s)←N(s)+1，累计价值 S(s)←S(s)+Gt<br>当整个过程结束后，状态 s 的价值 V(s)=S(s)/N(s)<br>根据大数定理（Law of Large Numbers）：V(s)→v~π~(s) as N(s)→∞</p></blockquote><h3 id="Incremental-Monte-Carlo"><a href="#Incremental-Monte-Carlo" class="headerlink" title="Incremental Monte-Carlo"></a>Incremental Monte-Carlo</h3><p>增量式求平均：<br>The mean μ1,μ2,… of a sequence x1,x2,… . can be computed incrementally：</p><script type="math/tex; mode=display">\begin{align}\mu_k &= \frac{1}{k}\sum_{j=1}^{k}x_j\\&= \frac{1}{k}\Bigl(x_k+\sum_{j=1}^{k-1}x_j \Bigr)\\&= \frac{1}{k}(x_k + (k-1)\mu_{k-1})\\&= \mu_{k-1} + \frac{1}{k}(x_k - \mu_{k-1})\end{align}</script><p>根据上式我们可以得出增量式进行MC更新的公式：<br>每次 episode 结束后，增量式更新 V(s) ，对于每个状态 St ，其对应的 return 为 Gt :</p><p> $N(S_t) ← N(S_t) + 1 \\ V(S_t) ← V(S_t) + \frac{1}{N(S_t)}(G_t - V(S_t))$</p><p>在非静态问题中，更新公式形式可以改为如下：</p><p>$V(S_t) ← V(S_t) + \alpha (G_t - V(S_t))$</p><h2 id="时序差分学习"><a href="#时序差分学习" class="headerlink" title="时序差分学习"></a>时序差分学习</h2><p>时序差分方法（Temporal-Difference Methods，简称TD）特点：</p><ul><li>TD 可以通过 bootstrapping 从非完整的 episodes 中学习</li><li>TD updates a guess towards a guess</li></ul><h3 id="TD-λ"><a href="#TD-λ" class="headerlink" title="TD(λ)"></a>TD(λ)</h3><p>下图为 TD target 在不同 n 下的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005224847.png" alt=""></p><p>从上图可以看出，当 n 达到终止时，即为一个episode，此时对应的方法为MC，因此从这个角度看，MC属于TD的特殊情况。</p><h3 id="n-step-Return"><a href="#n-step-Return" class="headerlink" title="n-step Return"></a>n-step Return</h3><p>n-step returns 可以表示如下：<br>n=1 时：$G_{t}^{(1)} = R_{t+1} + \gamma V(S_{t+1})$<br>n=2 时：$G_{t}^{(2)} = R_{t+1} + \gamma R_{t+2} + \gamma^2 V(S_{t+2})$<br>…<br>n=∞ 时：$G_{t}^{\infty} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{T-1} R_T)$<br>因此，n-step return $G_{t}^{(n)} = R_{t+1} + \gamma R_{t+2} + … + \gamma^{n}V(S_{t+n})$</p><p>n-step TD 更新公式：</p><p>$V(S_t) ← V(S_t) + \alpha (G_t^{(n)} - V(S_t))$</p><h3 id="Forward-View-of-TD-λ"><a href="#Forward-View-of-TD-λ" class="headerlink" title="Forward View of TD(λ)"></a>Forward View of TD(λ)</h3><p>我们能否把所有的 n-step return 组合起来？答案肯定是可以，组合后的return被称为是λ-return，其中λ是为了组合不同的n-step returns引入的权重因子。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005225422.png" alt=""></p><p>λ-return:</p><p>$G_t^{\lambda} = (1-\lambda)\sum_{n=1}^{\infty}\lambda^{n-1}G_t^{(n)}$</p><p>Forward-view TD(λλ)：</p><p>$V(S_t) ← V(S_t) + \alpha\Bigl(G_t^{\lambda} - V(S_t)\Bigr)$</p><p>TD(λ)对应的权重公式为 (1−λ)λ^n−1^，分布图如下所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181029093216246-346895182.png" alt=""></p><p>Forward-view TD(λ)的特点：</p><ul><li>Update value function towards the λ-return</li><li>Forward-view looks into the future to compute GλtGtλ</li><li>Like MC, can only be computed from complete episodes</li></ul><h3 id="Backward-View-TD-λ"><a href="#Backward-View-TD-λ" class="headerlink" title="Backward View TD(λ)"></a>Backward View TD(λ)</h3><ul><li>Forward view provides theory</li><li>Backward view provides mechanism</li><li>Update online, every step, from incomplete sequences</li></ul><p>带有资格迹的TD(λλ)：</p><script type="math/tex; mode=display">\delta_t = R_{t+1} + \gamma V(S_{t+1}) - V(S_t)\\V(s) ← V(s) + \alpha \delta_t E_t(s)</script><p>其中δt为TD-error，Et(s)为资格迹。</p><p><strong>资格迹(Eligibility Traces)</strong></p><blockquote><p>资格迹本质就是对于频率高的，最近的状态赋予更高的信任（credit）/ 权重。</p></blockquote><p>下图是对资格迹的一个描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005230115.png" alt=""></p><p>关于TD(λ)有一个结论：</p><blockquote><p>The sum of offline updates is identical for forward-view and backward-view TD(λ).</p></blockquote><p>这一块的内容不再深入介绍了，感兴趣的可以看Sutton的书和David的教程。</p><h2 id="蒙特卡洛学习-vs-时序差分学习"><a href="#蒙特卡洛学习-vs-时序差分学习" class="headerlink" title="蒙特卡洛学习 vs. 时序差分学习"></a>蒙特卡洛学习 vs. 时序差分学习</h2><h3 id="MC与TD异同点"><a href="#MC与TD异同点" class="headerlink" title="MC与TD异同点"></a>MC与TD异同点</h3><p>相同点：都是从经验中在线的学习给定策略 π 的价值函数 v~π~</p><p>不同点：</p><ul><li>Incremental every-visit Monte-Carlo：朝着真实的 return G~t~  更新 V(S~t~) </li></ul><p>$V(S_t) ← V(S_t) + \alpha (\textcolor{Red}{G_t}   - V(S_t))$</p><ul><li><p>Simplest temporal-difference learning algorithm: TD(0)</p><ul><li>朝着已预估的 return  $\color{Red}{R_{t+1} + \gamma V(S_{t+1})}$ 更新 V(S~t~) </li></ul><script type="math/tex; mode=display">V(S_t) ← V(S_t) + \alpha (\textcolor{Red}{R_{t+1} + \gamma V(S_{t+1})} - V(S_t))</script><ul><li>$\color{Red}{R_{t+1} + \gamma V(S_{t+1})}$称为是 TD target</li><li>$\color{Red}{R_{t+1} + \gamma V(S_{t+1})}−V(S_{t})$ 称为是 TD error</li></ul></li></ul><p>下图以 Drive Home 举例说明两者的不同，MC 只能在回家后才能改变对回家时间的预判，而 TD 在每一步中不断根据实际情况来调整自己的预判。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231045.png" alt=""></p><h2 id="MC与TD优缺点"><a href="#MC与TD优缺点" class="headerlink" title="MC与TD优缺点"></a>MC与TD优缺点</h2><h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><ul><li>TD 可以在知道最后结果之前学习（如上图举例）<ul><li>TD can learn online after every step</li><li>MC must wait until end of episode before return is known</li></ul></li><li>TD 可以在不存在最后结果的情况下学习（比如无限/连续MDPs）<ul><li>TD can learn from incomplete sequences</li><li>MC can only learn from complete sequences</li><li>TD works in continuing (non-terminating) environments</li><li>MC only works for episodic (terminating) environments</li></ul></li></ul><h3 id="方差与偏差"><a href="#方差与偏差" class="headerlink" title="方差与偏差"></a>方差与偏差</h3><ul><li>MC has high variance, zero bias（高方差，零偏差）<ul><li>Good convergence properties</li><li>Not very sensitive to initial value</li><li>Very simple to understand and use</li></ul></li><li>TD has low variance, some bias（低方差，存在一定偏差）<ul><li>Usually more efficient than MC</li><li>TD(0) converges to vπ(s)vπ(s)</li><li>More sensitive to initial value</li></ul></li></ul><p>关于 MC 和 TD 中方差和偏差问题的解释：</p><blockquote><ul><li>MC 更新基于真实的 return  $G_t = R_{t+1} + \gamma R_{t+2} + … + \gamma^{T-1}R_{T}$是 v~π~(St)  的无偏估计。</li><li>真实的TD target $R_{t+1} + \gamma v_{\pi}(S_{t+1})$ 也是 vπ(St) 的无偏估计。但是实际更新时用的 TD target $R_{t+1} + \gamma V(S_{t+1})$ 是 vπ(St)  的有偏估计。</li><li>TD target 具有更低的偏差：<ul><li>Return 每次模拟依赖于许多的随机动作、转移概率以及回报</li><li>TD target 每次只依赖一次随机动作、转移概率以及回报</li></ul></li></ul></blockquote><h3 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h3><ul><li>TD exploits Markov property<ul><li>Usually more efficient in Markov environments</li></ul></li><li>MC does not exploit Markov property<ul><li>Usually more effective in non-Markov environments</li></ul></li></ul><h2 id="DP、MC以及TD-0"><a href="#DP、MC以及TD-0" class="headerlink" title="DP、MC以及TD(0)"></a>DP、MC以及TD(0)</h2><p>首先我们从 backup tree 上去直观地认识三者的不同。</p><ul><li>DP backup tree：Full-Width step（完整的step）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231417.png" alt=""></p><ul><li>MC backup tree：完整的episode</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231438.png" alt=""></p><ul><li>TD(0) backup tree：单个step</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231514.png" alt=""></p><h2 id="Bootstrapping-vs-Sampling"><a href="#Bootstrapping-vs-Sampling" class="headerlink" title="Bootstrapping vs. Sampling"></a>Bootstrapping vs. Sampling</h2><p>Bootstrapping：基于已预测的值进行更新</p><ul><li>DP bootstraps</li><li>MC does not bootstrap</li><li>TD bootstraps</li></ul><p>Sampling：基于采样的期望来更新</p><ul><li>DP does not sample（model-based methods don’t need sample）</li><li>MC samples（model-free methods need sample）</li><li>TD samples（model-free methods need sample）</li></ul><p>下图从宏观的视角显示了 RL 的几种基本方法的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005231530.png" alt=""></p>]]></content>
    
    
    <summary type="html">Model-Free Prediction</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:25:54.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，简称DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于具有如下性质的问题：</p><ul><li>具有最优子结构（Optimal substructure）<ul><li>Principle of optimality applies</li><li>Optimal solution can be decomposed into subproblems</li></ul></li><li>重叠子问题（Overlapping subproblems）<ul><li>Subproblems recur many times</li><li>Solutions can be cached and reused</li></ul></li></ul><p>动态规划方法所耗时间往往远少于朴素解法。</p><p>马尔可夫决策过程MDP满足上述两个性质：</p><ul><li>贝尔曼方程提供了递归分解的结构；</li><li>价值函数可以保存和重复使用递归时的结果。</li></ul><h2 id="使用动态规划解决MDP-MRP"><a href="#使用动态规划解决MDP-MRP" class="headerlink" title="使用动态规划解决MDP/MRP"></a>使用动态规划解决MDP/MRP</h2><p>动态规划需要满足MDP过程是已知的（model-based）。</p><ul><li>For Predict：<ul><li>Input：MDP  <S,A,P,R,$\gamma$> 和策略 π 或者是 MRP <S,P,R,$\gamma$> </li><li>Output：价值函数 v~π~</li></ul></li><li>For Control：<ul><li>Input：MDP <S,A,P,R,$\gamma$> </li><li>Output：最优价值函数 v∗  或者最优策略 π∗</li></ul></li></ul><h2 id="策略评估"><a href="#策略评估" class="headerlink" title="策略评估"></a>策略评估</h2><p>策略评估（Policy Evaluation）指的是计算给定策略的价值，解决的问题是 “How to evaluate a policy”。</p><p>策略评估的思路：迭代使用贝尔曼期望方程（关于 MDP 的贝尔曼期望方程形式见《马尔可夫决策过程》）。</p><p>策略评估过程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005220219.png" style="zoom: 67%;" /></p><script type="math/tex; mode=display">v_{k+1} = \sum_{a\in A}\pi(a|s) \Bigl( R_{s}^a + \gamma\sum_{s'\in S}P_{ss'}^a v_{k}(s') \Bigr)</script><p>使用向量形式表示：</p><script type="math/tex; mode=display">\mathbf{v^{k+1}} = \mathbf{R^{\pi}} + \gamma \mathbf{P^{\pi}v^{k}}</script><h2 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h2><p>策略迭代（Policy Iteration，简称PI）解决的问题是 “How to improve a policy”。</p><p>给定一个策略 π ：</p><ul><li>评估策略 π </li></ul><script type="math/tex; mode=display">v_{\pi}(s) = E[R_{t+1} + \gamma R_{t+2} + ...| S_t = s]</script><ul><li>提升策略：通过采用贪婪方法来提升策略：<script type="math/tex; mode=display">\pi ' = \text{greedy}(v_{\pi})</script></li></ul><p>可以证明，策略迭代不断进行总是能收敛到最优策略，即 π′=π∗</p><p>策略迭代可以使用下图来形式化的描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005221105.png" alt=""></p><h2 id="广义策略迭代"><a href="#广义策略迭代" class="headerlink" title="广义策略迭代"></a>广义策略迭代</h2><p>通过上述提到的策略评估我们不难发现，策略评估是一个不断迭代的过程：</p><script type="math/tex; mode=display">v_{\pi}(s) = E[R_{t+1} + \gamma R_{t+2} + ...| S_t = s]</script><p>那么问题来了，Does policy evaluation need to converge to vπvπ?<br>我们是不是可以引入一个停止规则或者规定在迭代 kk 次后停止策略评估？<br>再进一步想，我们为什么不在每次策略评估的迭代过程中进行策略提升（等同于策略评估迭代1次后停止）？<br>注：这和后续要介绍的值迭代等价。</p><p>因此我们可以把上述策略迭代的过程一般化，即广义策略迭代（Generalised Policy Iteration，简称GPI）框架：</p><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005221407.png" alt=""></p><h1 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h1><p>介绍值迭代之前，我们先介绍下最优化原理。</p><h2 id="最优化原理"><a href="#最优化原理" class="headerlink" title="最优化原理"></a>最优化原理</h2><p>最优化原理（Principle of Optimality）定义：</p><blockquote><p>一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后诸策略对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略。</p></blockquote><p>最优化原理如果用数学化一点的语言来描述的话就是：</p><blockquote><p>以状态 ss 为起始点，策略 π(a|s) 可以得到最优值   $v_{\pi}(s) = v_*(s)$当且仅当：</p><ul><li>任意状态 s′ 对于状态 s  均可达；</li><li>以状态 s′ 为起始点，策略 π 可以得到最优值$v_{\pi}(s’) = v_*(s’)$</li></ul></blockquote><p>根据最优化原理可知，如果我们得到了子问题的解 v∗(s′)v∗(s′)，那么以状态 ss 为起始点的最优解 v∗(s)v∗(s) 可以通过一步回退（one-step lookahead）就能获取：</p><script type="math/tex; mode=display">v_*(s) ← \max_{a\in A}\Bigl(R_s^a + \gamma \sum_{s'\in S}P_{ss'}^{a}v_*(s') \Bigr)</script><p>也就是说，我们可以从最后开始向前回退从而得到最优解，值迭代就是基于上述思想进行迭代更新的。</p><h2 id="MDP值迭代"><a href="#MDP值迭代" class="headerlink" title="MDP值迭代"></a>MDP值迭代</h2><p>值迭代（Value Iteration，简称VI）解决的问题也是 “Find optimal policy ππ”。<br>但是不同于策略迭代使用贝尔曼期望方程的是，值迭代使用贝尔曼最优方程进行迭代提升。</p><p>值迭代与策略迭代不同的地方在于：</p><ul><li>Use Bellman optimal function, rather than Bellman expectation function</li><li>Unlike policy iteration, there is no explicit policy</li><li>Intermediate value functions may not correspond to any policy</li></ul><p>如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181028144014755-573375074.png" alt=""></p><script type="math/tex; mode=display">v_{k+1}(s) = \max_{a\in A}\Bigl(R_s^a + \gamma\sum_{s'\in S}P_{ss'}^a v_k(s') \Bigr)</script><p>对应的向量表示为：</p><script type="math/tex; mode=display">\mathbf{v}_{k+1} = \max_{a\in A}\mathbf{R}^a + \gamma \mathbf{P^av}^k</script><p>下图为三种方法的总结：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181028144022645-1891229163.png" alt=""></p><h2 id="动态规划扩展"><a href="#动态规划扩展" class="headerlink" title="动态规划扩展"></a>动态规划扩展</h2><h3 id="异步动态规划（Asynchronous-Dynamic-Programming）"><a href="#异步动态规划（Asynchronous-Dynamic-Programming）" class="headerlink" title="异步动态规划（Asynchronous Dynamic Programming）"></a>异步动态规划（Asynchronous Dynamic Programming）</h3><ul><li>In-place dynamic programming</li><li>Prioritised sweeping</li><li>Real-time dynamic programming</li></ul><h3 id="Full-Width-Backups-vs-Sample-Backups"><a href="#Full-Width-Backups-vs-Sample-Backups" class="headerlink" title="Full-Width Backups vs. Sample Backups"></a>Full-Width Backups vs. Sample Backups</h3><h4 id="Full-Width-Backups"><a href="#Full-Width-Backups" class="headerlink" title="Full-Width Backups"></a>Full-Width Backups</h4><ul><li>DP uses full-width backups（DP is model-based）<ul><li>Every successor state and action is considered</li><li>Using knowledge of the MDP transitions and reward function</li></ul></li><li>DP is effective for medium-sized problems (millions of states)</li><li>For large problems, DP suffers Bellman’s curse of dimensionality（维度灾难）</li></ul><blockquote><p>维度灾难：Number of states n=|S|  grows exponentially with number of state variables</p></blockquote><ul><li>Even one backup can be too expensive</li></ul><h4 id="Sample-Backups"><a href="#Sample-Backups" class="headerlink" title="Sample Backups"></a>Sample Backups</h4><p>后续将要讨论的时序差分方法</p><ul><li>Using sample rewards and sample transitions ⟨S,A,R,S’⟩ </li><li>Instead of reward function R and transition dynamics P</li><li>Advantages:<ul><li>Model-free: no advance knowledge of MDP required</li><li>Breaks the curse of dimensionality through sampling</li><li>Cost of backup is constant, independent of n=|S|</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Model-based 的通用方法——动态规划</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习介绍</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:26:00.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强化学习四元素"><a href="#强化学习四元素" class="headerlink" title="强化学习四元素"></a>强化学习四元素</h2><ul><li>策略（Policy）：环境的感知状态到行动的映射方式。</li><li>反馈（Reward）：环境对智能体行动的反馈。</li><li>价值函数（Value Function）：评估状态的价值函数，状态的价值即从当前状态开始，期望在未来获得的奖赏。</li><li>环境模型（Model）：模拟环境的行为</li></ul><h2 id="强化学习的特点"><a href="#强化学习的特点" class="headerlink" title="强化学习的特点"></a>强化学习的特点</h2><ul><li>起源于动物学习心理学的试错法（trial-and-error），因此符合行为心理学。</li><li>寻求探索（exploration）和采用（exploitation）之间的权衡：强化学习一面要采用（exploitation）已经发现的有效行动，另一方面也要探索（exploration）那些没有被认可的行动，已找到更好的解决方案。</li><li>考虑整个问题而不是子问题。</li><li>通用AI解决方案。</li></ul><h2 id="强化学习-vs-机器学习"><a href="#强化学习-vs-机器学习" class="headerlink" title="强化学习 vs. 机器学习"></a>强化学习 vs. 机器学习</h2><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005205458.png" alt="img"></p><p>强化学习与其他机器学习的不同：</p><ul><li>强化学习更加专注于在线规划，需要在探索（explore 未知领域）和采用（exploit 现有知识）之间找到平衡。</li><li>强化学习不需要监督者，只需要获取环境的反馈。</li><li>反馈是延迟的，不是立即生成的。</li><li>时间在强化学习中很重要，其数据为序列数据，并不满足独立同分布假设（i.i.d）。</li></ul><h2 id="强化学习-vs-监督学习"><a href="#强化学习-vs-监督学习" class="headerlink" title="强化学习 vs. 监督学习"></a>强化学习 vs. 监督学习</h2><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005205751.png" alt="img"></p><p>两者的目标都是学习一个model，而区别在于：</p><p>监督学习：</p><ul><li>Open loop</li><li>Learning from labeled data</li><li>Passive data</li></ul><p>强化学习：</p><ul><li>Closed loop</li><li>Learning from decayed reward</li><li>Explore environment</li></ul><h2 id="强化学习-vs-进化算法"><a href="#强化学习-vs-进化算法" class="headerlink" title="强化学习 vs. 进化算法"></a>强化学习 vs. 进化算法</h2><p>进化算法（Evolutionary Algorithms，简称EA）是通过生物进化优胜略汰，适者生存的启发而发展的一类算法，通过种群不断地迭代达到优化的目标。 </p><p>进化算法最大的优点在于整个优化过程是gradients-free的，其思想可以通过下图表示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005205858.gif" alt=""></p><p>RL和EA虽然都属于优化问题的求解框架，而且两者都需要大量的算力，但是两者有着本质上的区别。</p><p>Sutton在其强化学习介绍一书中也重点谈到了RL与EA的区别</p><ul><li>RL通过与环境交互来进行学习，而EA通过种群迭代来进行学习；</li><li>RL通过最大化累计回报来解决序列问题，而EAs通过最大化适应函数（Fitness Function）来寻求单步最优；</li><li><p>RL对于state过于依赖，而EA在agent不能准确感知环境的状态类问题上也能适用。</p><p>很多研究也尝试通过将EA和RL结合解决优化问题， </p></li></ul><h2 id="强化学习分类"><a href="#强化学习分类" class="headerlink" title="强化学习分类"></a>强化学习分类</h2><p>强化学习分类比较多样：</p><ul><li>按照环境是否已知可以分为Model-based &amp; Model-free；</li><li>按照学习方式可以分为On-Policy &amp; Off-Policy；</li><li>按照学习目标可以分为Value-based &amp; Policy-based。</li></ul><p>下图为根据环境是否已知进行细分的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005210120.png" alt=""></p><h2 id="强化学习相关推荐资料"><a href="#强化学习相关推荐资料" class="headerlink" title="强化学习相关推荐资料"></a>强化学习相关推荐资料</h2><ul><li>Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto：介绍强化学习很全面的一本书籍，相关的电子书及源码见<a href="http://incompleteideas.net/book/the-book.html">这里</a>。</li><li>David Silver在UCL的强化学习视频教程：介绍强化学习的视频教程，基本与Sutton的书籍可以配套学习，Silver来自于Google Deepmind，视频和课件可以从<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html">Silver的主页</a>获取，中文字幕版视频YouTube链接点<a href="https://www.youtube.com/playlist?list=PLjSwXXbVlK6K2enbNmPGjnmB8QBRgCv5s">这里</a>。</li><li>强化学习在阿里的技术演进与业务创新：介绍强化学习在阿里巴巴的落地，可以拓展强化学习应用的业务思路，电子版见<a href="https://pan.baidu.com/s/1jMj1e5zt_g3R7zgWRJ5t2A">这里</a>，密码：yh48。</li><li>Tutorial: Deep Reinforcement Learning：同样来自于Sliver的一个课件，主要针对RL与DL的结合进行介绍，电子版见<a href="https://pan.baidu.com/s/1jLAHZXJqsWg8JVHDBcunvw">这里</a>，密码：9mrp。</li><li>莫烦PYTHON强化学习视频教程：可以通过简短的视频概括地了解强化学习相关内容，适合于入门的同学，视频见<a href="https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/">这里</a>。</li><li>OpenAI Gym：Gym is a toolkit for developing and comparing reinforcement learning algorithms，Gym包含了很多的控制游戏（比如过山车、二级立杆、Atari游戏等），并提供了非常好的接口可以学习，链接见<a href="https://gym.openai.com/docs/">这里</a>。</li><li>Lil’Log：介绍DL和RL的一个优质博客，RL相关包括RL介绍、Policy Gradients算法介绍及Deep RL结合Tensorflow和Gym的源码实现，主页链接见<a href="https://lilianweng.github.io/lil-log/">这里</a>。</li></ul><p>转载自：<a href="https://www.cnblogs.com/maybe2030/p/9862353.html#_label0">[Reinforcement Learning] 强化学习介绍 - Poll的笔记 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">强化学习介绍</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>马尔可夫决策过程</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/</id>
    <published>2021-10-05T15:00:33.000Z</published>
    <updated>2021-10-05T14:25:37.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情节性任务-vs-连续任务"><a href="#情节性任务-vs-连续任务" class="headerlink" title="情节性任务 vs. 连续任务"></a>情节性任务 vs. 连续任务</h2><ul><li>情节性任务（Episodic Tasks），所有的任务可以被可以分解成一系列情节，可以看作为有限步骤的任务。</li><li>连续任务（Continuing Tasks），所有的任务不能分解，可以看作为无限步骤任务。</li></ul><h2 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h2><p>马尔可夫性：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。</p><p>马尔可夫过程即为具有马尔可夫性的过程，即过程的条件概率仅仅与系统的当前状态相关，而与它的过去历史或未来状态都是独立、不相关的。</p><h2 id="马尔可夫奖赏过程"><a href="#马尔可夫奖赏过程" class="headerlink" title="马尔可夫奖赏过程"></a>马尔可夫奖赏过程</h2><p>马尔可夫奖赏过程（Markov Reward Process，MRP）是带有奖赏值的马尔可夫过程，其可以用一个四元组表示 <S,P,R,$\gamma$> </p><ul><li>S 为有限的状态集合；</li><li>P 为状态转移矩阵，$P_{ss^{‘}} = P[S_{t+1} = s^{‘}|S_t = s]$</li><li>R 是奖赏函数；</li><li>$\gamma$为折扣因子（discount factor），其中 $\gamma$∈[0,1]</li></ul><h3 id="奖赏函数"><a href="#奖赏函数" class="headerlink" title="奖赏函数"></a>奖赏函数</h3><p>在 t 时刻的奖赏值 Gt :</p><script type="math/tex; mode=display">G_t = R_{t+1} + \gamma R_{t+2} + ... = \sum_{k=0}^{\infty}\gamma^{k}R_{t+k+1}</script><h3 id="Why-Discount"><a href="#Why-Discount" class="headerlink" title="Why Discount"></a>Why Discount</h3><p>关于Return的计算为什么需要 $\gamma$ 折扣系数:</p><blockquote><ul><li>数学表达的方便</li><li>避免陷入无限循环</li><li>远期利益具有一定的不确定性</li><li>在金融学上，立即的回报相对于延迟的回报能够获得更多的利益</li><li>符合人类更看重眼前利益的特点</li></ul></blockquote><h3 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h3><p>状态 s 的长期价值函数表示为：</p><script type="math/tex; mode=display"> v(s)=E[Gt|St=s]</script><h3 id="Bellman-Equation-for-MRPs"><a href="#Bellman-Equation-for-MRPs" class="headerlink" title="Bellman Equation for MRPs"></a>Bellman Equation for MRPs</h3><script type="math/tex; mode=display">\begin{align}v(s) &= E[G_t|S_t=s]\\&= E[R_{t+1} + \gamma R_{t+2} + ... | S_t = s]\\&= E[R_{t+1} + \gamma (R_{t+2} + \gamma R_{t+3} ... ) | S_t = s]\\&= E[R_{t+1} + \gamma G_{t+1} | S_t = s]\\&= E[R_{t+1} + \gamma v(s_{t+1}) | S_t = s]\end{align}</script><p>下图为MRP的 backup tree 示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005211526.png" alt="img"></p><p>注：backup tree 中的白色圆圈代表状态，黑色圆点对应动作。</p><p>根据上图可以进一步得到：</p><script type="math/tex; mode=display">v(s) = R_s + \gamma \sum_{s' \in S}P_{ss'}v(s')</script><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p>马尔可夫决策过程（Markov Decision Process，MDP）是带有决策的MRP，其可以由一个五元组构成 <S,A,P,R,$\gamma$> 。</p><ul><li>S 为有限的状态集合；</li><li>A 为有限的动作集合；</li><li>P 为状态转移矩阵，$P_{ss^{‘}}^{a} = P[S_{t+1} = s^{‘}|S_t = s,A_t=a]$</li><li>R 是奖赏函数；</li><li>$\gamma$ 为折扣因子（discount factor），其中 $\gamma$∈[0,1] ]</li></ul><p>我们讨论的MDP一般指有限（离散）马尔可夫决策过程。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>策略（Policy）是给定状态下的动作概率分布，即：</p><script type="math/tex; mode=display">\pi(a|s) = P[A_t = a|S_t = a]</script><h2 id="状态价值函数-amp-最优状态价值函数"><a href="#状态价值函数-amp-最优状态价值函数" class="headerlink" title="状态价值函数 &amp; 最优状态价值函数"></a>状态价值函数 &amp; 最优状态价值函数</h2><p>给定策略 π 下状态 s 的状态价值函数（State-Value Function） $v_{\pi}(s)$</p><script type="math/tex; mode=display">v_{\pi}(s) = E_{\pi}[G_t|S_t = s]</script><p>状态 s 的最优状态价值函数（The Optimal State-Value Function）v~∗~(s) </p><script type="math/tex; mode=display">v_{*}(s) = \max_{\pi}v_{\pi}(s)</script><h2 id="动作价值函数-amp-最优动作价值函数"><a href="#动作价值函数-amp-最优动作价值函数" class="headerlink" title="动作价值函数 &amp; 最优动作价值函数"></a>动作价值函数 &amp; 最优动作价值函数</h2><p>给定策略 π，状态 s，采取动作 a 的动作价值函数（Action-Value Function）q~π~(s,a)</p><script type="math/tex; mode=display">q_{\pi}(s, a) = E_{\pi}[G_t|S_t = s, A_t = a]</script><p>状态 s 下采取动作 a 的最优动作价值函数（The Optimal Action-Value Function）q∗(s,a):</p><script type="math/tex; mode=display">q_{*}(s, a) = \max_{\pi}q_{\pi}(s, a)</script><h2 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h2><p>如果策略 π 优于策略 π′：</p><script type="math/tex; mode=display">\pi \ge \pi^{'} \text{ if } v_{\pi}(s) \ge v_{\pi^{'}}(s), \forall{s}</script><p>最优策略 v∗ 满足：</p><ul><li>v∗≥π,∀π</li><li>v~π∗~(s)=v~∗~(s) </li><li>q~π∗~(s,a)=q~∗~(s,a) </li></ul><p>如何找到最优策略？</p><p>可以通过最大化 q~∗~(s,a)  来找到最优策略：</p><script type="math/tex; mode=display">v_{*}(a|s) =\begin{cases}& 1 \text{ if } a=\arg\max_{a \in A}q_{*}(s,a)\\& 0 \text{ otherwise }\end{cases}</script><p><strong>对于MDP而言总存在一个确定的最优策略，而且一旦我们获得了q~∗~(s,a) ，我们就能立即找到最优策略。</strong></p><h2 id="Bellman-Expectation-Equation-for-MDPs"><a href="#Bellman-Expectation-Equation-for-MDPs" class="headerlink" title="Bellman Expectation Equation for MDPs"></a>Bellman Expectation Equation for MDPs</h2><p>我们先看下状态价值函数 v^π^。</p><p>状态 s 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180345098-1901972119.png" alt=""></p><p>根据上图可得：</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A}\pi(a|s)q_{\pi}(s, a)  \qquad (1)</script><p>再来看动作价值函数 q~π~(s,a) </p><p>状态 s，动作 a 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180402049-1747500206.png" alt=""></p><p>因此可得：</p><script type="math/tex; mode=display">q_{\pi}(s,a)=R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{\pi}(s')  \qquad (2)</script><p>进一步细分 backup tree 再来看 v^π^  与 q~π~(s,a)  对应的表示形式。</p><p>细分状态 ss 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180411412-1063042128.png" alt=""></p><p>将式子(2)代入式子(1)可以进一步得到 vπ(s)vπ(s) 的贝尔曼期望方程：</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A} \pi(a | s) \Bigl( R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{\pi}(s') \Bigr)  \qquad (3)</script><p>细分状态 ss，动作 aa 对应的 backup tree 如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180421183-498067530.png" alt=""></p><p>将式子(1)代入式子(2)可以得到 qπ(s,a)的贝尔曼期望方程：</p><script type="math/tex; mode=display">q_{\pi}(s,a)=R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a \Bigl(\sum_{a' \in A}\pi(a'|s')q_{\pi}(s', a') \Bigr)  \qquad (4)</script><h2 id="Bellman-Optimality-Equation-for-MDPs"><a href="#Bellman-Optimality-Equation-for-MDPs" class="headerlink" title="Bellman Optimality Equation for MDPs"></a>Bellman Optimality Equation for MDPs</h2><p>同样我们先看 v~∗~(s)：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180430574-1927151238.png" alt=""></p><p>对应可以写出公式：</p><script type="math/tex; mode=display">v_{*}(s) = \max_{a}q_{*}(s, a)   \qquad (5)</script><p> 再来看q~∗~(s,a)：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180436870-598952431.png" alt=""></p><p>对应公式为：</p><script type="math/tex; mode=display">q_{*}(s, a) =  R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{*}(s') \qquad (6)</script><p>同样的套路获取 v∗(s) 对应的 backup tree 以及贝尔曼最优方程：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180450776-607271585.png" alt=""></p><p>贝尔曼最优方程：</p><script type="math/tex; mode=display">v_{*}(s) = \max_{a} \Bigl( R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a v_{*}(s') \Bigr) \qquad (7)</script><p>q∗(s,a)  对应的 backup tree 以及贝尔曼最优方程：</p><p><img src="https://img2018.cnblogs.com/blog/764050/201810/764050-20181027180500521-1105213902.png" alt=""></p><p>对应的贝尔曼最优方程：</p><script type="math/tex; mode=display">R_s^a + \gamma \sum_{s'\in S}P_{ss'}^a\max_{a}q_{*}(s, a) \qquad (8)</script><h3 id="贝尔曼最优方程特点"><a href="#贝尔曼最优方程特点" class="headerlink" title="贝尔曼最优方程特点"></a>贝尔曼最优方程特点</h3><ul><li>非线性（non-linear）</li><li>通常情况下没有解析解（no closed form solution）</li></ul><h3 id="贝尔曼最优方程解法"><a href="#贝尔曼最优方程解法" class="headerlink" title="贝尔曼最优方程解法"></a>贝尔曼最优方程解法</h3><ul><li>Value Iteration</li><li>Policy Iteration</li><li>Sarsa</li><li>Q-Learning</li></ul><h2 id="MDPs的相关扩展问题"><a href="#MDPs的相关扩展问题" class="headerlink" title="MDPs的相关扩展问题"></a><del>MDPs的相关扩展问题</del></h2><ul><li><del>无限MDPs/连续MDPs</del></li><li><del>部分可观测的MDPs</del></li><li><del>Reward无折扣因子形式的MDPs/平均Reward形式的MDPs</del></li></ul>]]></content>
    
    
    <summary type="html">马尔可夫决策过程</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
  </entry>
  
  <entry>
    <title>WSL踩坑</title>
    <link href="https://changqingaas.github.io/%E8%B8%A9%E5%9D%91/%E8%B8%A9%E5%9D%91/wsl%E8%B8%A9%E5%9D%91/"/>
    <id>https://changqingaas.github.io/%E8%B8%A9%E5%9D%91/%E8%B8%A9%E5%9D%91/wsl%E8%B8%A9%E5%9D%91/</id>
    <published>2021-10-03T15:30:16.000Z</published>
    <updated>2022-01-17T01:14:02.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL踩坑"><a href="#WSL踩坑" class="headerlink" title="WSL踩坑"></a>WSL踩坑</h1><p>大二上学期期末，稀里糊涂装了wsl, 一直用到现在。<br>本来是打算，和OS相关，那就装到C盘把。<br>这么一大意，在大三上装东西的时候出了不少问题。（当时没仔细装，而且也不懂）<br>这次为了装temu的交叉编译环境，装了不少东西，直接把C盘干到2G了，这么下去肯定不行。（Ubuntu20。04的主要文件夹就有至少15G了）<br>于是，我就上网搜，发现别人早就整好了vhdx(一个叫虚拟硬盘的东西，我当时没有做，现在做也来不及了），<br>所以别人的限制硬盘占用的方法，转移到别的位置的办法，我都没办法用了。</p><p>打算卸载重装到D盘。用这个帖子解决问题了：<a href="https://blog.csdn.net/LaughingMei/article/details/109736965">https://blog.csdn.net/LaughingMei/article/details/109736965</a> </p><p>卸载完C盘有16G了。</p><p>比较脑瘫，当时看到的有两种方式，第一种要vhdx，第二种不用</p>]]></content>
    
    
    <summary type="html">稀里糊涂</summary>
    
    
    
    <category term="踩坑" scheme="https://changqingaas.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑" scheme="https://changqingaas.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101</title>
    <link href="https://changqingaas.github.io/CG/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/CG/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-13T11:50:19.000Z</published>
    <updated>2022-02-04T05:51:43.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lecture1-intro"><a href="#Lecture1-intro" class="headerlink" title="Lecture1:  intro"></a>Lecture1:  intro</h2><h3 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h3><p>使用计算机synthesize(合成)  manipulate（操作) 可视化信息</p><h3 id="why-study-computer-graphics"><a href="#why-study-computer-graphics" class="headerlink" title="why study computer graphics?"></a>why study computer graphics?</h3><ul><li>Application<ul><li>video games 电子游戏</li><li>animations 动画</li><li>visualization 可视化</li><li>virtual reality</li><li>augmented reality 增强现实</li><li>digital illustration 数码插画</li><li>simulation 模拟</li><li>graphical user interfaces 图形用户界面</li><li>typography  排版</li></ul></li><li>technical chanllenges </li></ul><h3 id="Course-topics"><a href="#Course-topics" class="headerlink" title="Course topics"></a>Course topics</h3><ul><li><p>Rasterization  光栅化</p><ul><li><p>project geometry primitives (3D triangles / polygons) onto the screen</p><p>将几何图形（3D三角形 / 多边形）投射到屏幕上</p></li><li><p>break projected primitives into fragments (pixels)</p><p>将投影图元分解到片段(像素)</p></li><li><p>gold standard in video games (real-time applications)</p></li></ul></li><li><p>curves and meshes 曲线和栅格</p><ul><li>怎样represent geometry in CG</li></ul></li><li><p>ray tracing 光线追踪</p><ul><li>shoot rays from camera though each pixel<ul><li>calculate intersection and shading 交叉点和阴影</li><li>continue to bounce the rays till they hit light sources</li></ul></li><li>gold standard in animations / movies (offline离线 application)</li></ul></li><li><p>animation simulation</p><ul><li>key frame animation 关键帧动画</li><li>mass-spring system 弹簧振子系统</li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="differences-between-cg-and-cv"><a href="#differences-between-cg-and-cv" class="headerlink" title="differences between cg and cv"></a>differences between cg and cv</h3><p>No clear boundaries</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231736.png" alt="image-20210913210044004"></p><h2 id="Lecture2-review-of-linear-algebra"><a href="#Lecture2-review-of-linear-algebra" class="headerlink" title="Lecture2:  review of linear algebra"></a>Lecture2:  review of linear algebra</h2><h3 id="Graphics’-dependcies"><a href="#Graphics’-dependcies" class="headerlink" title="Graphics’ dependcies"></a>Graphics’ dependcies</h3><ul><li>basic mathematics<ul><li>Linear algebra 线性代数<ul><li>mostly dependent on linear algebra</li><li>vectors（dot products点乘,cross products叉乘<ul><li>An operation like translating or rotating objects  can be matrix-vector multiplication</li></ul></li><li>matrices 矩阵（复数</li></ul></li><li>calculus 微积分</li><li>statistics 统计</li></ul></li><li>basic physics <ul><li>Optics, 光学的</li><li>Mechanics  机械的</li></ul></li><li>misc 杂项<ul><li>Numerical analysis  数值分析</li><li>signal processing 信号处理</li><li>aesthetics 审美</li></ul></li></ul><h3 id="vectors"><a href="#vectors" class="headerlink" title="vectors"></a>vectors</h3><p>noting: 只记了part</p><ul><li><p>unit vector </p><ul><li>单位向量，</li><li>用来代表方向</li></ul></li><li><p>dot  product in graphics</p><ul><li><p>$\vec{a}\cdot\vec{b} = |\vec{a}|\cdot|\vec{b}|cos\theta$ </p></li><li><p>Find angle between two vectors  (e.g. cosine of angle between light source 光源 and surface表面)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231823.png" alt="image-20210913215253056"></p></li><li><p>Finding <strong>projection</strong> of one vector on another</p><ul><li><p>measure how close two directions are</p></li><li><p>decompose分解 a vector </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231937.png" alt="image-20210913215715680" style="zoom:50%;" /></p></li><li><p>determine forward or backward</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231938.png" alt="image-20210913215758162" style="zoom: 50%;" /></p></li></ul></li></ul></li><li><p>cross product in graphics</p><p>​    <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231939.png" alt="image-20210913220439863" style="zoom: 50%;" /></p><ul><li>Direction determined by right-hand rule</li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231940.png" alt="image-20210913220739158"></p><ul><li>Useful in constructing coordinate systems (later)</li><li>Determine left / right</li><li>Determine inside / outside</li></ul></li><li>Orthonormal bases and coordinate frames  正交基底和坐标系<ul><li>Critical issue is transforming between these systems/ bases</li></ul></li></ul><h3 id="matrices"><a href="#matrices" class="headerlink" title="matrices"></a>matrices</h3><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231941.png" alt="image-20210913223344462" style="zoom:50%;" /></p><ul><li>$(AB)^{T} = B^{T}A^{T}$</li><li>$AA^{-1} = A^{-1}A = I$</li><li>$(AB)^{-1} = B^{-1}A^{-1}$</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210913231942.png" alt="image-20210913223854494" style="zoom: 50%;" /></p><p>In Graphics, pervasively used to represent transformations</p><ul><li>translation, rotation,shear剪切,scale缩放</li></ul><h2 id="Lecture-3-Transformation"><a href="#Lecture-3-Transformation" class="headerlink" title="Lecture 3: Transformation"></a>Lecture 3: Transformation</h2><h3 id="why-study-transformation"><a href="#why-study-transformation" class="headerlink" title="why study transformation"></a>why study transformation</h3><ul><li>modeling<ul><li>translation</li><li>rotation</li><li>scaling</li></ul></li><li>viewing<ul><li>3D (projection)</li><li>2D (projection)</li></ul></li></ul><h3 id="2D-transformations"><a href="#2D-transformations" class="headerlink" title="2D transformations:"></a>2D transformations:</h3><ul><li><p>representing transformations using matrices</p></li><li><p>rotation</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914135044.png" alt="image-20210914135044036" style="zoom:50%;" /></p><ul><li>$R_{\theta} = \begin{bmatrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{bmatrix} $</li><li>$R_{-\theta} = \begin{bmatrix} cos\theta &amp; sin\theta \\ -sin\theta &amp; cos\theta \end{bmatrix} = R_{\theta}^{T} = R_{\theta}^{-1}(by \quad definition) $</li><li>正交矩阵： A·A^T^ = E</li><li>默认绕原点旋转</li><li>默认逆时针旋转</li></ul></li><li><p>scale matrix</p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} s_{x} &amp; 0 \\ 0 &amp; s_{y} \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</p></li><li><p>reflection matrix 反射（镜像）矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914124142.png" alt="image-20210914124142211" style="zoom: 50%;" /></p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} -1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</p></li><li><p>shear matrix</p><p>​    <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914134639.png" alt="image-20210914134632720" style="zoom: 50%;" /></p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} -1 &amp; a \\ 0 &amp; 1\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</p><ul><li>Hints:<ul><li>horizontal shift is 0 at y = 0</li><li>horizontal shift is a at y = 1</li><li>vertical shift is always</li></ul></li></ul></li><li><p>Linear transforms </p><ul><li>线性变换：可以用一个矩阵表示的变换</li><li>x’ = ax + by</li><li>y’ = cx + dy</li><li>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$</li></ul></li></ul><h3 id="Homogeneous-coordinates-齐次坐标"><a href="#Homogeneous-coordinates-齐次坐标" class="headerlink" title="Homogeneous coordinates 齐次坐标"></a>Homogeneous coordinates 齐次坐标</h3><ul><li><p>Why homogeneous coordinates  </p><p>for example:  translation</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914135553.png" alt="image-20210914135548707" style="zoom:50%;" /></p><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \end{bmatrix} = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix} + \begin{bmatrix} t_{x} \\ t_{y} \end{bmatrix} $</p><ul><li><p>so, translation is not linear transform!</p></li><li><p>因为平移变换不能直接用一个矩阵表示，必须加一个向量；  </p></li><li><p>add a third coordinates</p><p>引入齐次坐标可以解决问题，让平移也能只用一个矩阵表示</p></li><li><p>2D point = (x,y,1)^T^</p></li><li><p>2D vector = (x,y,0)^T^</p></li><li><p>向量 + 向量，结果齐次项是0，还是向量</p></li><li><p>点 - 点，得到的是一个向量，齐次项也变成0 </p></li><li><p>点 + 向量，表示一个点的移动，结果 还是点 ！</p></li><li><p>点 + 点是什么呢？齐次项变成2。将所有项除以2，齐次项又变为1 。所以点 + 点结果实际上是两个点的中点。</p></li></ul></li><li><p>Affine  transformation 仿射变换</p><ul><li><p>仿射变换：先线性变换再加上一次平移</p></li><li><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \\ 1 \end{bmatrix} = \begin{bmatrix} a &amp; b &amp; t_{x}\\ c &amp; d  &amp; t_{y}  \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\  y \\ 1 \end{bmatrix} $</p></li><li><p>scale </p><p>$ S(s_{x}, s_{y}) = \begin{bmatrix} s_{x} &amp; 0 &amp; 0 \\ 0 &amp; s_{y}  &amp; 0  \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p></li><li><p>rotation </p><p>$ R(\alpha) = \begin{bmatrix} cos\alpha &amp; -sin\alpha &amp; 0 \\ sin\alpha &amp; cos\alpha  &amp; 0  \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p></li><li><p>translation</p><p>$ T(t_{x}, t_{y}) = \begin{bmatrix} 1 &amp; 0 &amp; t_{x} \\ 0 &amp; 1  &amp; t_{y} \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p></li></ul></li><li><p>transform ordering matters</p><ul><li>matrix multiplication is not commutative 可交换的</li></ul></li></ul><h3 id="composing-transforms"><a href="#composing-transforms" class="headerlink" title="composing transforms"></a>composing transforms</h3><ul><li><p>decomposing complex transforms</p><ul><li>translate center to origin</li><li>rotate</li><li>translate back</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914142248.png" alt="image-20210914142248083"></p><p>which means $T(c) · R(\alpha) · T(-c)$</p><ul><li><p>分解：变换可以分解，注意先后顺序是从右到左</p></li><li><p>2D变换矩阵（缩放，旋转，平移变换）</p></li></ul></li><li></li></ul><h2 id="Lecture-4：-Transformation-Cont"><a href="#Lecture-4：-Transformation-Cont" class="headerlink" title="Lecture 4： Transformation Cont"></a>Lecture 4： Transformation Cont</h2><h3 id="3D-transformations"><a href="#3D-transformations" class="headerlink" title="3D transformations"></a>3D transformations</h3><ul><li><p>3D point = (x,y,z,1)^T^</p></li><li><p>3D vector = (x,y,z,0)^T^</p></li><li><p>$\begin{bmatrix} x^{‘} \\ y^{‘} \\ z_{‘} \\ 1 \end{bmatrix} = \begin{bmatrix} a &amp; b &amp; c &amp; t_{x}\\ d &amp; e &amp; f &amp; t_{y}\\g &amp; h &amp; i &amp; t_{z}  \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\ y \\z \\ 1 \end{bmatrix} $</p></li><li><p>三维空间中的齐次变换，最后一行和二维变换类似，是0 0 0 1，平移还是在矩阵最后一列</p></li><li><p>对于仿射变换，是先应用线性变换，再加上平移</p></li><li><p>what is order?</p><ul><li><p>linear transform first or translation first?</p></li><li><p>scale </p><p> $S(s_{x}, s_{y},s_{z}) = \begin{bmatrix} s_{x} &amp; 0 &amp; 0 &amp; 0\\ 0 &amp;  s_{y} &amp; 0 &amp; 0\\0 &amp; 0 &amp;  s_{z} &amp; 0  \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}  $</p></li><li><p>translation</p><p> $T(t_{x}, t_{y}, t_{z}) = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_{x}\\ 0 &amp;  1 &amp; 0 &amp; t_{y} \\0 &amp; 0 &amp;  1 &amp; t_{z}  \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}  $</p></li><li><p>rolation</p><ul><li>rolation around x-, y-,or  z-axis</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914203113.png" alt="image-20210914203043532" style="zoom:50%;" /></p><ul><li>绕哪个轴旋转，哪个坐标就不变</li><li><p>不过𝑅𝑦矩阵稍微不同，其他两个都是右上角𝑠𝑖𝑛是负的，只有他是左下角𝑠𝑖𝑛是负的 因为𝑥叉乘𝑦得到𝑧，𝑧叉乘𝑦得到𝑥，但是𝑧叉乘𝑥得到𝑦（而不是𝑥叉乘𝑧），所以是反的</p></li><li><p>$R_{xyz}(\alpha, \beta, \gamma) = R_{x}(\alpha)R_{y}(\beta)R_{z}(\gamma)$</p></li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914220209.png" alt="image-20210914220208915"></p></li></ul></li></ul><h3 id="Viewing-观测-transformation"><a href="#Viewing-观测-transformation" class="headerlink" title="Viewing (观测) transformation"></a>Viewing (观测) transformation</h3><ul><li><p>View (视图) / Camera transformation  </p><ul><li>Think about how to take a photo <ul><li>Find a good place and arrange people (model transformation) </li><li>Find a good “angle” to put the camera (view transformation)</li><li>Cheese! (projection transformation)<ul><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914224154.png" alt="image-20210914224154439"></li><li>定义相机</li><li>位置</li><li>往哪看</li><li>向上方向</li><li>现实中是移动相机，变换景物</li><li>图形学中，相机不动，永远在原点</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914223830.png" alt="image-20210914223829896" style="zoom:50%;" /></li><li>经过变换，把相机的位置移动到原点，同时保持看到的景物不变</li></ul></li></ul></li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914225726.png" alt="image-20210914225726865"></p></li><li><p>这个从“歪”的坐标轴旋转回正的坐标轴，不太好写。 但是这个变换的逆过程，即：从正的坐标轴旋转到“歪”的坐标轴，是好写的， 于是我们先写从“正”坐标轴变换到“歪”坐标轴的变换矩阵，再求其逆矩阵，就可以得到待求的变换矩阵。 又因为旋转矩阵是正交矩阵，所以他的逆矩阵就只需要转置一下就可以得到了！ 注意，不但相机要做这个变换，其他物体也要做这个变换，因为我们想让相机看到的景物相对不变。 （以上部分个人认为非常巧妙和关键！）</p></li><li><p>Projection (投影) transformation</p><ul><li><p>3D to 2D</p></li><li><p>Orthographic (正交) projection  </p><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914230822.png" alt="image-20210914230821994"></p><ul><li><em>没有近大远小</em></li><li>平行投影<ul><li>首先定义空间中一个立方体，将其translate，使其中心在原点，再scale成标准立方体（边长为2</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915120758.png" alt="image-20210915120758604"></li><li>再次提醒，注意𝑧轴是近大远小 OpenGL等API是反过来的</li></ul></li><li><p>Perspective (透视) projection</p><p> <img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210914230840.png" alt="image-20210914230840011"></p><ul><li><p>更像人眼看到的场景</p></li><li><p>Most common in Computer Graphics, art, visual system </p></li><li><p>Further objects are smaller </p></li><li><p>Parallel lines not parallel; converge to single point</p></li><li>Recall: property of homogeneous coordinates<ul><li>(x, y, z, 1), (kx, ky, kz, k != 0), (xz, yz, z2, z != 0) all represent  the same point (x, y, z) in 3D </li><li>e.g. (1, 0, 0, 1) and (2, 0, 0, 2) both represent (1, 0, 0)</li></ul></li><li>how to do perspective projection<ul><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915122816.png" alt="image-20210915122816233"></li><li>先将frustum远平面，挤压成和近平面一样大（从左图变成右图）</li><li>再做正交投影，投影到近平面</li><li>上述操作过程中几点假设：<ul><li>1）近平面保持不变 </li><li>2）z值保持不变，只是向内收缩</li></ul></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915122907.png" alt="image-20210915122907760"></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915122956.png" alt="image-20210915122956833"></li><li>挤压这一步怎么做？ 上图是从侧面观察frustum 用相似三角形知识可以得到新坐标的表达式，但是第三个分量目前还不知道（这里利用之前讲的那个性质： 齐次坐标，如果我们对点的坐标所有分量同时乘以k，他表示的还是原来那个点！  </li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123123.png" alt="image-20210915123123207"></li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123140.png" alt="image-20210915123140120"></li><li>如何求解第三行<ul><li>任何近平面上的点不会改变（也就是对于任意的(𝑥, 𝑦, 𝑛, 1)，经过这个矩阵变换后，点的位置仍然不变）</li><li>任何远平面上的点，𝑧值不会改变</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123415.png" alt="image-20210915123415483"></li><li>点(𝑥, 𝑦, 𝑧, 1)是可以通过矩阵变换得到(𝑛𝑥, 𝑛𝑦, 𝑢𝑛𝑘𝑛𝑤𝑜𝑛, 𝑧)向量的。 根据上文提到的性质（1），经过这个变换，点实际没有改变 而同时，(𝑥, 𝑦, 𝑧, 1)本身可以写成(𝑥, 𝑦, 𝑛, 1)（为什么把𝑧替换成𝑛？因为近平面的𝑧坐标就是都是𝑛，所以可以做这个替换。）然后同时乘以𝑛， 变成(𝑛𝑥, 𝑛𝑦, 𝑛 ଶ , 𝑛) 经过上面两个推导，可以看出，第三行前两个数一定是0 因为𝑛 ଶ这个分量和𝑥和𝑦都毫无关系，因此前两个数必定是0 这样，我们就解出了第三行前两个数，都是0 接下来求A和B</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123500.png" alt="image-20210915123459854"></li><li>远平面上有一个特殊点，(0, 0, 𝑓)经过变换挤压仍然不变 所以(0, 0, 𝑓)经过变换仍然是(0, 0, 𝑓) 根据近平面我们得到$An + B = n^{2}$,根据远平面的中心点我们得到$Af + B = f^{2}</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123625.png" alt="image-20210915123625508"></li><li>这样我们就能解出A和B了， 这样终于把从透视投影挤压成正交投影的矩阵，解出来了</li><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123651.png" alt="image-20210915123651566"></li></ul></li></ul></li><li><p>思考题</p><ul><li><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/image/20210915123710.png" alt="image-20210915123709902"></li></ul></li></ul></li></ul><h2 id="Lecture05-Rasterization-1-Triangles"><a href="#Lecture05-Rasterization-1-Triangles" class="headerlink" title="Lecture05: Rasterization 1(Triangles)"></a>Lecture05: Rasterization 1(Triangles)</h2><h3 id="Finishing-up-Viewing"><a href="#Finishing-up-Viewing" class="headerlink" title="Finishing up Viewing"></a>Finishing up Viewing</h3><ul><li>Viewport(视口) transformation</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005190732.png" alt="image-20211005190731847" style="zoom: 50%;" /></p><p>上节课把透视投影转化成正交投影 这里引入另外一个概念 Field of View，表示你能看到的角度的范围 注意看上图中红色线的夹角，就是垂直可视角度，他越大，可视角度越大 同理还有水平可视角度</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005190927.png" alt="image-20211005190926969"></p><p>MVP这三个变换之后，所有东西都会停留在一个1，1，1的位于原点的标准立方体中 下一步就要把这立方体画在屏幕上</p><h3 id="Rasterization（光栅化，即把东西花在屏幕上"><a href="#Rasterization（光栅化，即把东西花在屏幕上" class="headerlink" title="Rasterization（光栅化，即把东西花在屏幕上"></a>Rasterization（光栅化，即把东西花在屏幕上</h3><h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><ul><li><p>像素是最小的屏幕单位</p></li><li><p>每个像素有不同的颜色</p></li><li><p>屏幕空间：就是给屏幕定义一个坐标系 比如，可以定义左下角是原点。 </p></li><li><p>实际上像素的中心是(𝑥 + 0.5, 𝑦 + 0.5)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191523.png" alt="image-20211005191523440"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191557.png" alt="image-20211005191556944"></p><p>我们要做的就是把标准立方体空间映射到屏幕这个二维世界中去 𝑧暂时不管 其他两个坐标是[−1, 1] ଶ转换到 [0, 𝑤𝑖𝑑𝑡ℎ] ∗ [0, ℎ𝑒𝑖𝑔ℎ𝑡] 使用上面这个矩阵做变换</p></li></ul><h4 id="Rasterizing-a-triangle"><a href="#Rasterizing-a-triangle" class="headerlink" title="Rasterizing  a triangle"></a>Rasterizing  a triangle</h4><ul><li><p>三角形可以拼接在三维空间中的面，或者二维空间中复杂的图形 </p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191718.png" alt="image-20211005191718242"></p></li><li><p>三角形内部一定是平面的 </p></li><li>给三角形顶点定义不同属性，可以在三角形内部进行插值</li><li>通过采样的方式，来画出三角形<ul><li>采样就是把函数离散化的过程</li><li>可以对时间，面积，方向，体积… 进行采样</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005191941.png" alt="image-20211005191941468"></p><p>定义二值函数：</p><script type="math/tex; mode=display">inside(tri, x,y) = \left\{\begin{array}{rcl}1  &      & {Point(x,y) \ in  \ triangle \ t}\\0  &      & {otherwise}\\\end{array}\right.</script><ul><li><p>这里我们要做的就是给定一个三角形，判断像素中心是否在三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005192820.png" alt="image-20211005192820679"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005192920.png" alt="image-20211005192920137"></p><p>那么，如何判断一个点是否在三角形内？用叉乘！！ 比如对上图，判断Q是否在三角形内部 首先$𝑃1𝑃2 \  X \ 𝑃1𝑄 $，将会得到一个z为正数的向量，也就是结果向量朝向屏幕外的，利 用右手定则，可以得知𝑄在𝑃1𝑃2的左侧（因为如果在右侧，那么结果将会是向量𝑧为负 数，那么结果向量就朝向屏幕内部） 类似的𝑃2𝑃0 𝑋 𝑃2𝑄，得到𝑄在右侧，不对劲！ 𝑃0𝑃1 𝑋 𝑃0𝑄，得到𝑄在左侧</p><p>注意，向量按照一定的顺序去判断，比如我们上面是按照P1, P2, P0去判断的</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005193137.png" alt="image-20211005193137111"></p><p>检查屏幕所有的像素太花时间！ 可以只检查蓝色的包围盒（Bounding box）部分</p><p><img src="https://cdn.jsdelivr.net/gh/ChangQingAAS/for_picgo/img/20211005193213.png" alt="image-20211005193213667"></p><p>也可以每一行设置一个包围盒，进一步减小包围盒 很适用于那种三角形很小，但是包围盒很大的（窄长三角形</p><h2 id="some-words"><a href="#some-words" class="headerlink" title="some words"></a>some words</h2><p>syllabus  教学大纲</p><p>cube  立方体</p><p>canonical 标准的</p><p>aspect ratio 横纵比</p><p>requirements 要求</p><p>submission 提交</p><p>slides 幻灯片</p><p>Bulletin Board System BBS</p><p>Semantic Segmentation 语义切割</p><p>code skeletons 代码框架</p><p>IDE: Integrated Development Environment</p><p>parse 解析</p><p>Academic integrity 学术诚信</p><p>Valentine’s Day 情人节</p><p>brutal 粗暴的</p><p>coordinates 坐标</p><p> Parallelogram law 平行四边形法则</p><p>Triangle law 三角法则</p><p>orthogonal 正交的</p><p> scalar 标量</p><p>decompose 分解</p><p>haunt 出没</p><p>pervasively 普遍地</p><p>multiplication 乘法</p><p>trivial 琐碎的</p>]]></content>
    
    
    <summary type="html">GAMES101:现代计算机图形学入门</summary>
    
    
    
    <category term="CG" scheme="https://changqingaas.github.io/categories/CG/"/>
    
    
    <category term="CG" scheme="https://changqingaas.github.io/tags/CG/"/>
    
  </entry>
  
  <entry>
    <title>墨子平台训练教程</title>
    <link href="https://changqingaas.github.io/MARL/MADRL/%E5%A2%A8%E5%AD%90%E5%B9%B3%E5%8F%B0%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/"/>
    <id>https://changqingaas.github.io/MARL/MADRL/%E5%A2%A8%E5%AD%90%E5%B9%B3%E5%8F%B0%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/</id>
    <published>2021-09-03T15:00:33.000Z</published>
    <updated>2021-09-04T11:34:06.947Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍一下windows版本墨子平台的使用流程：</p><ol><li><h2 id="进入华戍防务-官网-hs-defense-com-下载软件"><a href="#进入华戍防务-官网-hs-defense-com-下载软件" class="headerlink" title="进入华戍防务 官网(hs-defense.com)下载软件"></a>进入<a href="http://www.hs-defense.com/col.jsp?id=105">华戍防务 官网(hs-defense.com)</a>下载软件</h2></li></ol><p>我下载的是<code>墨子·联合作战推演系统（个人版）</code> </p><p><code>墨子·AI开发包</code>主要是一些开发会用到的代码和文档。代码也可以在gitee.com上找到：<a href="https://gitee.com/hs-defense/moziai">moziai: 墨子AI开发包及“子牙”智能体开源代码  </a></p><p><code>竞赛客户端(互联网)</code> 主要是用来军事推演比赛的，与强化学习训练关系不大，可以不下载。</p><p><code>墨子·AI版（Linux)</code> 因为一开始没办法下载，后面断断续续也没有弄出什么效果</p><p>注：</p><ul><li><p>文件采用ftp协议下载，下载链接格式为：ftp: ip/port/文件夹s/文件</p></li><li><p>由于部分浏览器不支持，推荐使用QQ浏览器下载</p></li><li><p>一般点击下载按钮后，会默认让迅雷接管下载</p></li></ul><ol><li><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>​    根据安装手册安装该软件，基本上按照手册进行就可以了</p></li><li><h2 id="启动该软件"><a href="#启动该软件" class="headerlink" title="启动该软件"></a>启动该软件</h2><ol><li>进入安装目录下的\MoziData，右键点击<code>mysql.bat</code>，以管理员身份运行它，随后退出</li><li>进入安装目录下的\MoziServer，运行MoziServer.exe，尽量关掉杀毒软件，最好以管理员身份运行<ul><li>这里大概会遇到一个问题：<code>临时许可码过期，请联系华戍防务重新授权</code>，具体解决方案略</li><li>我在数据库方面也出过问题，不过忘了具体细节了</li></ul></li></ol></li><li><h2 id="运行代码，进行仿真训练"><a href="#运行代码，进行仿真训练" class="headerlink" title="运行代码，进行仿真训练"></a>运行代码，进行仿真训练</h2><ol><li><p>获取代码，在IDE打开代码</p></li><li><p>加载代码所需的scen想定文件</p><ul><li>进入墨子平台，可以在想定一栏下找到<code>加载想定</code>的选项，想定文件是从<code>安装路径\MoziServer\bin\Scenarios\</code>获取的，因此需要把代码包里的scen文件放到这里。</li><li>加载想定文件，选择推演方</li><li>随后可以看到墨子平台上有了具体的想定环境</li><li>如果要更改想定文件，改完之后，需要保存，再重新加载<ul><li>因为训练的每个回合都会刷新环境，如果不保存更改到新scen文件，那么这个更改只能用于一个回合</li></ul></li></ul></li><li><p>运行main.py代码即可看到效果</p><ul><li><p>注：</p><ul><li><p>这里可能需要指定一下 墨子平台的路径，可以执行代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os.environ[&#39;MOZIPATH&#39;] &#x3D; &#39;D:\\MoZiSystem\\Mozi\\MoziServer\\bin&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以在<code>编辑系统环境变量</code>中添加路径</p></li></ul></li></ul></li></ol></li></ol><p>注：Linux版本的墨子平台还在折腾，因为虚拟机比较卡，服务器上又没办法弄出显示界面，还折腾了一堆配置，最近还没弄，如果有结果了，会在这里更新的</p>]]></content>
    
    
    <summary type="html">墨子推演平台强化学习训练教程，主要是写给队友用的</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
    <category term="机器学习" scheme="https://changqingaas.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>收藏的文章</title>
    <link href="https://changqingaas.github.io/MARL/others/%E6%94%B6%E8%97%8F%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://changqingaas.github.io/MARL/others/%E6%94%B6%E8%97%8F%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2021-09-01T14:00:33.000Z</published>
    <updated>2022-02-04T05:54:00.386Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.justlovesmile.top/posts/bfa4054.html">深度学习 | 《深度学习入门之PyTorch》阅读笔记 | Justlovesmile’s BLOG</a></p><p>注： 这本书的github代码已经4年没更新了，只适合速览一下，做个overview, 并不适合手敲学习</p><p><a href="https://blog.justlovesmile.top/posts/43678.html">深度学习 | “花书”，Deep Learning笔记 | Justlovesmile’s BLOG</a></p><p> 注：偏数学</p><p><a href="https://blog.justlovesmile.top/posts/16050.html">大学课程 | 《算法分析与设计》笔记 | Justlovesmile’s BLOG</a></p><p><a href="https://blog.justlovesmile.top/posts/41347.html">大学课程 | 数据库基础 | Justlovesmile’s BLOG</a></p>]]></content>
    
    
    <summary type="html">放在本地的收藏夹不方便分享，所以就放在这里了</summary>
    
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/categories/MARL/"/>
    
    
    <category term="MARL" scheme="https://changqingaas.github.io/tags/MARL/"/>
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>SurviveSJTUManual阅读笔记</title>
    <link href="https://changqingaas.github.io/%E4%B9%A6%E6%91%98/others/SurviveSJTUManual%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://changqingaas.github.io/%E4%B9%A6%E6%91%98/others/SurviveSJTUManual%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-01T14:00:33.000Z</published>
    <updated>2022-02-05T01:54:15.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这本书不是《逃课手册》或者《考前突击宝典》。我希望帮助各位读者做到的，绝不是简单的拿高分、或者顺利毕业。我衷心希望这本书能够带给读者一些新鲜的思考，让同学们能看到人生道路上不同的风景。至少在读过本书之后，各位读者应该能够有勇气、有智慧，去发现并挑战那些比上课更为重要的追求。</p><h2 id="立志篇"><a href="#立志篇" class="headerlink" title="立志篇"></a>立志篇</h2><h3 id="欢迎来到上海交通大学"><a href="#欢迎来到上海交通大学" class="headerlink" title="欢迎来到上海交通大学"></a>欢迎来到上海交通大学</h3><p>在本书的开始，不得不遗憾地告诉大家一个消息。国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。我只是看到了无数充满求知欲、激情、与年轻梦想的同学们，将要把自己的四年青春，充满希望与信任地交给大学来塑造。这使我心中非常不安。</p><p>在当今流水线式的教育体制下，我们就像廉价的零件一样被生产出来。因为数量巨大，没人会对每一个人的教学质量负责。</p><p>领导不会为你负责。对于一个争做世界一流大学的研究型学校，管好科研，管好实验室才是当务之急。相比之下，本科生教学显得无利可图。教授也不会为你负责。拉到足够的经费发表足够的论文，满足学院要求才是生存大计。要说管学生，也肯定先要管好自己实验室的硕士博士，而非那一百多人大课堂里的某个本科生。就算是科研任务不太重的一些任课教师，他们也不会为你负责。</p><p>真正在课堂上口传心授的教学，其质量是不会有人过问的。教学评估会考察实验报告格式是否合格，出勤率是否够，但是绝对不会考察上百人的班上到底有几个听懂了的。</p><h3 id="你想要什么"><a href="#你想要什么" class="headerlink" title="你想要什么"></a>你想要什么</h3><h4 id="认清自己的技术栈"><a href="#认清自己的技术栈" class="headerlink" title="认清自己的技术栈"></a>认清自己的技术栈</h4><p>随着本科、硕士、博士的扩招下，中国开始享受着“工程师红利”，各行业从业人员受教育程度稳步提升，中国制造产业升级也是国家大计之一，但目前我国存在着新增中高端就业岗位数量跟不上大学、研究生毕业生数量增长的问题，与经济增速下滑相叠加，每年都会看到类似“大学生最难就业季”的新闻，交大的出身足以让你在找工作的时候拿到多份offer，但想要去理想的公司以及职位，你需要对自己的技术栈和目标职位的需求技术栈有足够清醒的认知，及时补足短板。你未来可能会用到的能力包括但不限于：</p><ol><li><p>本专业的专业知识，这是你安身立命的根本，对本领域有中长期的判断</p></li><li><p>表达能力，如何去说服你的上司还有顾客理解并接受你的idea和产品</p></li><li><p>相关信息检索、过滤、总结、可视化等的能力</p></li><li><p>交际能力，向别人展现自己的价值，在自己需要帮助的时候也能找到最合适的朋友寻求帮助</p></li><li><p>抗压能力，主要是对逆境的适应力、容忍力、耐力，能较好应对生活工作中的挫折</p></li><li><p>独立思考，在信息过载的当下尽量避免被错误消息带节奏</p></li><li><p>时间管理，以后的日子里你会被生活的柴米油盐和很多工作学习以外的杂事消耗精力，再也不是大学以前父母帮你操办大部分事情了，你需要高效管理利用剩余的时间</p></li></ol><h4 id="本科毕业之后你想做什么"><a href="#本科毕业之后你想做什么" class="headerlink" title="本科毕业之后你想做什么"></a>本科毕业之后你想做什么</h4><p>四年很长，四年也很短，大学里会有一部分同学享受着校园的舒适生活，不知不觉间被温水煮了青蛙（尤其是文社科专业的同学），校园相对稳定安逸的生活在已经成为“社畜”的人看来是非常奢侈的。日后在社会上安身立命的技能多还是在校园中培养，你也需要在恰当的时间点跳出这种舒适生活的幻象为以后工业界/学术界的工作打好基础，如若拖延症到本科晚期才发现四顾茫然不知如何在社会上立足，GPA高的同学或许还能靠保研直博暂缓进入社会的进度条（当然很多同学保研直博也是一开始就定下的目标，并未考虑过直接进入社会），学业不佳的同学或许要再像准备高考一样备战考研了，而近些年考研难度也是在肉眼可见地提升。进入社会之后人生的分支要比学校里多得多，在此也不一一举例，在象牙塔里被保护得久了容易跟现实社会脱节，这些东西要留给你自己去摸索。</p><h4 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h4><p>“懂得很多道理，却依旧过不好这一生”以后阅读这本小册子的人可能千千万，但大家毕业后的境遇会千差万别，这可能是由于同学们认知能力、运气与机遇、执行能力、家里提供的支持等等不同所导致的。</p><h3 id="失败的思维方式"><a href="#失败的思维方式" class="headerlink" title="失败的思维方式"></a>失败的思维方式</h3><h4 id="分数至上"><a href="#分数至上" class="headerlink" title="分数至上"></a>分数至上</h4><p>我们的体制总倾向于用一个量化的分数来概括衡量一个人。</p><p>如果一个人把政策评分作为自己的至高追求，那么他就是这个政策的牺牲品。</p><p>就算你把课本上的内容搞得再烂熟，绝不代表你真正对这门课能有什么理解（相反，那些真正理解的人，却不一定能针对考点答出高分）。</p><p>请务必牢记：大学四年留给你的是你的人生，在你毕业之时，那一串苍白的分数其实就已经作废了。</p><h4 id="被动思维"><a href="#被动思维" class="headerlink" title="被动思维"></a>被动思维</h4><p>无论做什么，我们都需要给自己一个理由。每天迫于生活压力，毫无主见地忙碌着，可称得上人生一大悲哀。</p><p>在迈进大学校门的时候，我们面临的最大问题是：为什么要上课？ </p><p>“怕老师点名”、“为了抄笔记作业”、“记录考试重点” . . . 这些话，充其量只是我们被迫上课的借口，却不能成为我们心悦诚服去上课的理由。</p><p>真正能成为我们上课理由的，只有我们对科学文化知识的渴望。</p><p>如果是否上课对你的考试成绩影响不大；如果我们感兴趣的知识不在学校的课程表上；如果上课学习的效果足够差，效率足够低，以至于通过自习，能够在更短的时间掌握知识；那么，我想你已经有答案了。</p><h3 id="悲壮的学习方式"><a href="#悲壮的学习方式" class="headerlink" title="悲壮的学习方式"></a>悲壮的学习方式</h3><p> 挖空心思研究解题技巧的学生们，与同样挖空心思研究出题技巧的老师们，构成了一个完美的圆环。在二者日复一日的机械劳动中，我只看到纸张、电力，以及粮食不断被浪费，却看不到中华之崛起。</p><p>我无意全盘否定同学们吃苦耐劳的精神，但这份精神充其量只能称为悲壮。我们耗费了大量的时间和精力掌握的那些考点、技巧，在真正的知识殿堂里根本登不上大雅之堂。哪怕我们特征值求得再熟练，积分积得再复杂，中国的载人飞船也不会因此而顺利上天。</p><p>一个真正有志于建造科学大厦的人，是不应抱着一块儿砖头精雕细琢的。</p><p>学习最需要的，不是悲壮的毅力，而是对无限未知的渴求。</p><p>最终来说，学习知识的目的是为后继的知识铺垫，以及培养创造性的思维。所谓有效率的学习，应当是以最高的效率获取知识，服务这两个目标。从现状来看，我们想要把什么都搞扎实的学习习惯，其效率是极端低下的，而在我们通过大量习题，最终扎实掌握的信息里，有效的“知识”却又是如此的少。</p><h3 id="你的身价是多少"><a href="#你的身价是多少" class="headerlink" title="你的身价是多少"></a>你的身价是多少</h3><p> 从本质上说，绝大部分同学们之所以选择大学毕业后再参加工作，是看上了更加体面的薪资待遇——大学毕业之后，我们的劳动会变得更有价值。在此，请不要提及所谓“劳动平等”之类的错误观点。劳动所创造的价值从来都不是均等的，而且不同行业的劳动早已明码标价了。</p><p>作为一名大学生，我们要对自己的能力和将来的身价有一份清醒而客观的期望。在面对各种兼职的时候，我们必须先说服我们的自尊：</p><p>参加这样的工作，我们是不是正在以过于低廉的价格出卖自己的劳动力？</p><p>对于生计无虞的同学们，我们更应该做的不是为了蝇头小利在最底层的劳动中苦苦挣扎，而是应当积极地利用这份时间来提高我们的身价，为今后出卖高价值劳动创造机会。</p><h3 id="正确地浪费剩下的时间"><a href="#正确地浪费剩下的时间" class="headerlink" title="正确地浪费剩下的时间"></a>正确地浪费剩下的时间</h3><p> 如果说，毕业文凭是一项增值服务，那么大学四年就是一笔投资。</p><p>相比宝贵的青春，我们在上学期间所需要的学费和生活开销几乎可以忽略不计。我们真正投下的有价值的筹码，是时间。面对着足以改变你人生轨迹的黄金时间，你是否感到了它的沉重？你又是否想过要如何计划这笔巨额投资？</p><p>如果你是一名乖孩子，每天从早晨开始好好上课，好好做作业，好好预习、复习，直到熄灯时间好好睡觉，过着这种积极健康，平稳中庸的生活，但是缺乏有效自我支配的生活（如果按照学校的规划，你会发现你可以自由支配的业余时间少得可怜）。那么，你这样退守下去，无异于把自己的青春放在保险箱里让他随着时间而凋谢。我们必须牢记这样的黄金规则：</p><p>平庸的生活方式是麻醉药。他只会束缚你，让你没有作为，甚至没有出息地度过大学的四年。</p><p>无论你做的事情是否有意义——哪怕任何事情都不做，时间也会从我们的身边溜走。我们必须一日三省问自己，今天的时间是否过得有价值。</p><p>一般来说，一项任务的价值，取决于它在时间尺度上的作用效率。花同样的功夫，我们应该尽量多做那些对整个人生都产生正面影响的事情，少做对中期的未来产生影响的事情，不做那些只对近期产生影响的事情。当然，产生负面影响的事是最应该避免的。从这个意义上说，花适当的时间锻炼身体能让我们终身受益，值得做；但是即便只花同样时间，我们也不应该打游戏，因为那只能获得转瞬即逝的空虚的精神愉悦。</p><p>其实，何止是体育锻炼与打游戏。我们上课、学习、考试这些事情是否真的值得去做，也都必须经过理性而批判的思考才能做出正确的决定。</p><p>有不少同学是为了 GPA 而上课。这些同学的错误在于，首先他们没有意识到，有许多提升 GPA 的办法比上课更为有效。</p><p>同时，这些同学更没有想过 GPA 本身是否是一件重要的事情。我们很遗憾地承认，由于舆论的导向， GPA 几乎成为了我们大学的一切。在短期，它绝对是重要的。除非你要保研或者转专业，其余的情况下 GPA 绝对不是最重要的因素。 </p><p>如果把目光放得稍微长远些，哪怕只是毕业后一两年， GPA 就会贬得一文不值。我们是不是应该为了这一块“敲门砖”而折衷了我们的远期目标？</p><p>安排时间道理真的很浅显：成功人士往往会津津乐道于他们在校期间锻炼出的专业素养，但几乎没有成熟（甚至不需要成功）的人，喜欢炫耀自己当年高数考了年级第一。</p><p>在另外一些时候，我们会给“上课”找一个更加堂而皇之的理由：学习知识。</p><p>关于大学课堂的教学质量以及课堂所关注的所谓“解题技巧”，我已经不想再作赘述。简而言之，上课中，我们获得有用知识的效率是如此之低，以至于任何一种有效的自习方式都会轻松地获得更大的回报。打比方说，一个学期的英语课，每周四节共计48小时。在课堂上，我们有一半时间要忍受台上同学支离破碎的英语。然而，花同样的时间，一个智力正常的同学完全可以熟练背诵2000个单词（这个数字是根据广大 GRE 考生的备考状况进行的保守估测）。这2000单词足够让你的英语水平整体上一个台阶。敢问，一个学期的英语课，你又能学到什么呢？最多不过是熟练背诵那本来就已经很寒碜的课文而已。当然，英语课只是例子，你会发现你身边几乎充满了更值得谴责的例子，其中不少比英语课更甚。这些事情经常会包括（但不限于）：</p><p>• 学生会议。几乎所有的学生会议，无论是在大礼堂举办的全校大会，还是社团头目临时占用教室举行的小规模会议，都有一个共同点，那就是毫无效率可言。</p><p>• 毫无组织的学生活动。通常在无组织的集体活动中，等人、闲谈总要花半个小时的时间。甚至让人怀疑活动的主题就是等人和闲谈。</p><p>• 费时费力不讨好，但是碍于面子不好推脱的临时工作。学校很多老师或者学生领导，喜欢把人当壮丁使唤。但是你要时刻清醒，你的身份不是临时工。“帮忙救急”和“工作”这两个概念必须区别对待。</p><p>我们应该对计划时间下的工作量有足够认识。小到一小时、一天，大到一个暑假、一个学期，或者是大学四年，制定切实可行的计划，并为不能完成计划自责是最基本的要求。所谓的牛人和大多数庸人的主要差别，一方面在于有没有时间可以利用；再一方面，就是时间的利用率。我们必须时刻保持一种紧迫感，以保证时间不被虚度。只要你能把在校期间的时间正确地加以利用。不需要超人的天分——甚至不需要特别努力，你都有望在你的专业领域里出类拔萃。</p><h3 id="总有更值得做的事情"><a href="#总有更值得做的事情" class="headerlink" title="总有更值得做的事情"></a>总有更值得做的事情</h3><p> 当我们迫于学校的教学计划，被迫选一些看上去比较没用的课程时，总会听到一些充满善意的劝慰：“这些知识多学一些也没有什么不好，没准哪天就能用得到呢！”这种话乍听起来仿佛很有道理，但实际上却是不折不扣的谎言。</p><p>我们之所以拒绝学习那些对自己不是特别有用的知识，是因为这些知识对我们的价值太低。</p><p>事务对我们都会有影响，其价值必须定量，而非定性地讨论。出去义务扫马路可以陶冶你的情操，还可以锻炼身体。坐在家里背单词背一天你可以学会数百个新单词，提升英语水平。按照上面提到的“善意的逻辑”，这两者各有好处，仿佛难以取舍。但是我想在实际操作中，不会有人认为前者对你的益处更大。</p><p>在打着各种华丽口号的诱惑面前，我们要保持清醒，并且时刻告诫自己</p><p>总有更值得做的事。</p><h3 id="做研究的兴趣"><a href="#做研究的兴趣" class="headerlink" title="做研究的兴趣"></a>做研究的兴趣</h3><p> 当你站在巨人的肩膀上，开始进行独立研究的时候，你最需要的，是兴趣。不要说，“有研究经历好出国”，不要说“没什么其他好出路所以选择做研究”。浩然高科技大楼下的白骨告诉我们，没有兴趣的徒劳坚持通常是很危险的。在科研这条道路上，只有对一门学科的喜爱，才能成为你唯一和全部的动力。</p><p>走进一个学科之前，最先应该知道的是该学科的研究对象、研究方法，以及当前研究中的热点难点问题，而不应该被广告一样的花哨演示糊弄住。</p><p>开始搞研究，并不必然意味着你要和学校里一个实验室有行政上的关系。真正扎实的认识应当是从阅读和学习中开始的。你可以试着去看这个学科最新的影印版教科书。（顺便说一下，在绝大多数高新技术领域，对于教科书的选择，我们能接受的下限是外文作者的中文翻译。尝试阅读所谓国内专家的专著只会让你的思维变得更为混乱）如果在大致看完这些书籍之后，你还能保持之前的热情，那么我非常鼓励你尝试进入该方向进行更深入的研究。</p><p>如果去做研究，那么你从一开始就应该期望着自己能够做出影响到其他科研工作者的原创性工作。绝对不要随便跑到研究小组里给人端茶倒水，指望着通过打杂来获得一段所谓的“研究经历”，或者是一篇文章第N作者的署名权。在研究过程中，相关知识不够没关系，数学不好也没关系；但是无论如何，你需要保持一个独立思考的心态。如果有好一点的工作，可以发牛一点的文章；价值略低的工作也有名气小些的出版物可以发表。但归根结底，发表文章需要的是你的原创性思考。至于那些一年上百篇论文的高产教授和一年数十篇论文的高产学生们。我们只能很遗憾地说，他们的工作是不值一提的垃圾，这种人的存在，简直就是丢中国人的脸。</p><h2 id="访谈集"><a href="#访谈集" class="headerlink" title="访谈集"></a>访谈集</h2><h3 id="为了留学而出国"><a href="#为了留学而出国" class="headerlink" title="为了留学而出国"></a>为了留学而出国</h3><h4 id="为什么要出国"><a href="#为什么要出国" class="headerlink" title="为什么要出国?"></a>为什么要出国?</h4><p>我们希望你拥有的是一个“积极”的理由，也就是说，你是为了得到你想要的某样东西而选择出国这条道路，而不是因为你厌倦了当前的生活、想逃避现状而走上这条道路。在出国的问题上，这山看着那山高的心理是极其可怕的。如果在一个对你的血统没有歧视的国度里，在一个竞争并不算激烈、甚至生活上还称得上有保障的社会中，在一个对你来说没有任何语言、文化障碍的环境下，你都算不上一个成功者的话，你有什么资本可以奢望在出国后，自己能够摇身一变，以胜者的姿态生存下来？你又有什么理由不继续失败？你怎么就那么自信地说因为我在国内做不好，所以我出国就能做好？成功的人在不同的地方有不同的成功方式，但是失败的人在不同的地方会有完全相同的失败方法。</p><p>海的那边，一样很残酷。</p><p>某个环境的条件如何如何之好并不是你去到某个环境中的理由，你能从这个环境中获得什么样的成就，才是你前往某个环境的原因。</p><p>对一个人来说，事业上的成功需要很多的要素。那么，你所追求的事业，到底是需要更多知识？更广的人脉？还是实践能力？抑或是其他因素？对于绝大多数人，我们会惊奇地发现，我们并不是那么急迫地需要学术能力来带给自己更好的前途。若真如此，那么国外大学的学术优势对你就是毫无意义。于是，付出大量时间，换取一张文凭就不是一个很合理的选择。用同样的时间，你完全可以积累实践经验，并锻炼更有用的能力。高学历的文凭不是万能的，而青春实却又太过宝贵，是不是真的要下定决心毕业后读书，需要经过每个人的深思熟虑。</p><p>那么，什么样的人需要更多知识呢？当然，我们认为，那些希望继续从事学术研究工作的人。我们不仅鼓励这类人出国，而且我们还要更坚定地反对他们留在国内深造。</p><p>在国内的学术圈里，一方面大家忙于恶性竞争：导师划山头分派系，人际关系极度复杂，各种包括造假、剽窃等学术不端行为屡见不鲜；而另一方面，政府对科研的支持力度也小得可怜：我们怎么能指望一个博士生每个月工资不到800块钱，一边饿着肚子一边做出惊人的研究呢？这诸多的弊端，使得中国高校成为学术研究领域最差的环境之一。想在这样一个几乎没有高水平学术成果的泥潭中拔足前行，需要你付出的代价实在太大太大！这还只是从客观条件来说，而从对你的前途的影响来说，一个学术工作者，在博士阶段如果没有受到国外一流名校的严格训练的话，那么以后从事科研工作是非常困难的，因为在科研领域，做不到最好，就意味着你没有任何用途，你只有做出全世界最前沿最顶尖，别人没有做出来过的东西，才能算是科研。如果你没有在学生阶段受到良好的训练，那么以后你想靠学术研究作为谋生之计，基本没有可能。</p><p>如果你的目标只是出国，读书是代价最高昂，效率最低的下下策（如果你想在美国落地生根，需要的时间往往超过15年）。与外国人或者可以出国的人结婚，或者通过中介办理移民手续，都比读书要容易许多。（尤其是通过与外国人结婚，俗称的“抱白大腿”，可以几乎100%保证你在3年之内成功拿到外国国籍）</p><p>回顾一下，如果你属于以下几类中的一类，那么我们相对比较推荐你出国读书：</p><p>• 以科学研究作为自己事业目标的人。</p><p>• 经过认真考虑的希望通过学习知识来增加自己技术背景的人。</p><p>• 经过非常认真的考虑希望通过出国读书来达到定居国外的目的的人。</p><p>特别需要提醒的是，现在“海归”变“海待”的情况越来越多。而国内的用人单位也越来越理智，不会因为你在海外留过学，就断定你如何出色并加以重用。如果你自己没有就读 Harvard, Yale, Princeton 那种中国老百姓耳熟能详的名校，也没有在能力上真的比国内的同龄人有长足进步，就不要指望有哪个公司会因为一张海外文凭而重用你。更有可能发生的情况是：你出国镀金，回来之后发现你的同学早就已经变成了真金白银，但是人家一看你就知道你只是表面镀金，但肚子里没东西的水货。</p><h4 id="出国读什么学位什么专业"><a href="#出国读什么学位什么专业" class="headerlink" title="出国读什么学位什么专业?"></a>出国读什么学位什么专业?</h4><p>关于读博士，我们一再声明：不想做学术的人请务必不要读博士学位。</p><p>一个事实是，设置博士学位的唯一目的是培养顶尖科研人才。这个学位不考虑你的就业前景，不考虑你精神所能承受的压力，它唯一考虑的，是你在某一个领域做出了多大的开创性贡献。很多大学对培养博士生的期望，就是毕业之后成为专业领域的世界级专家。你在攻读博士学位期间所付出的努力，如果换算成金钱，绝对会比你在那几年拿到的奖学金多太多了！钱绝对不是读博士的原因。</p><p>我们要注意的第二个事实是，在读博士过程中，被导师压迫几乎是理所当然的事情。经常是学生第一个学期过来，老板就扔过来几篇乃至几十篇文章，要你写综述、或者实现文章中提到的研究方法、甚至被要求在这些论文的基础上做进一步改进。而到了后来，老板要求你每个学期都必须发领域顶级的会议或者期刊论文也是家常便饭。自然，与国内不同的是，这里的老板都很懂这一行，只要你有做不出来的东西去和老板交流，老板一定会帮助你。但是如果你天生就不具备独立的科研能力和科研素养，也没有热情和耐心去做，那么你就会天经地义地被博士项目淘汰了。</p><p>关于博士的第三个事实是，当你终于有一天博士生毕业后，你学到的东西往往太过于细化和深入，不能帮助你在工业界找到合适的工作。而去读博士后，继续混迹学术圈，又会是另外一道鬼门关。想继续做教授，那竞争的惨烈程度比博士入学申请更要血腥无数倍。每年有多少博士毕业，但是每个大学又有多少个教职位空缺？所以，如果你不是醉心学术，没有浓厚的兴趣，或者不觉得自己以后会以研究为生，那么读博士之前最好再考虑一下。在美国，很多名校毕业的冷门专业的博士因为在学术界和工业界都不能谋到工作，最后不得不再花上一两年选个护理、会计之类的好就业的专业读硕士然后就业。</p><p>那么读硕士呢？对于那些家里有钱，能自费读硕士的人们，虽然你们不如家里有钱，出去读本科的。在国外读一个硕士，你可以见识到很多人体会到更多的文化以及完全不同的生活方式，还有最重要的，一张烫金文凭和不错的前途。而且，对于还没有下定决心要不要读博士的人来说，你也可以通过一个硕士学位，给自己更多的经历来感受是否真的要做科研，同时读硕士的过程还可以对你的博士申请有很大的推动作用。因此读硕士除了花钱多一点以外，真的是有百利而无一害的事情。</p><p>我们强烈建议家庭能够负担的同学先去读一个硕士看看。当然，如果是没钱读硕士的同学，你也不要太灰心，人生本来就是如此的不公平，一个人的家庭比你多一点钱可以让他读硕士实在不算什么大不了的事，有太多太多的人根本不需要读硕士，甚至根本不需要读书，就可以坐拥万贯家产，一辈子都比你过得好。所以大家只要尽自己能力去努力，好好规划自己的人生，能够过上自己能达到的最好的生活，也就可以了。</p><p>至于专业的选择，这个问题就更简单了。许多盲目性很强的申请者错很容易错误地用“是否容易申请”，“是否好就业”来作为引导他们人生轨迹的风向标。要知道，越好申请的专业，恰好是那些不好就业的专业。相反，那些有光明前途的职业，通常也就意味着惨烈的竞争。比如医学博士 MD (Doctor of Medicine) 和法学博士 JD (Doctor of Jurisprudence) ，这两个专业的学生一毕业就有很高的社会地位和很光明的前途。但是我们几乎没有听说过有大陆应届毕业生被这样的博士项目录取。另外，一些名校的 MBA (Master of Business Administration) 的竞争惨烈度甚至要比博士还要强许多。所以说，不管是申请的难度还是就业的难度，根本不应该 成为左右我们选择专业的理由。</p><p>读什么专业，要看你自己的长处和兴趣。你经过深思熟虑后投身的专业，必须要能让你获得最大程度的智力满足。</p><h4 id="为了申请出国，大学期间需要准备什么"><a href="#为了申请出国，大学期间需要准备什么" class="headerlink" title="为了申请出国，大学期间需要准备什么"></a>为了申请出国，大学期间需要准备什么</h4><p>其实这个问题本身就有严重的误导性，出国不是你的目的，而是你变得更强的手段。你未来的人生规划是什么，那么你大学期间要做的，自然就是为你的人生目标奋斗而准备</p><p>在 GPA 方面我们的建议是，但凡你能做一些比 GPA 更有意义的事情，显然会比死磕 GPA 更有帮助。毕竟不管大家怎么努力，每个专业的第一名永远只有一个人，卷入这种恶性竞争只会让你荒废时间和精力。</p><p>我们应该做什么？做研究！而且要做一流的研究！如果你肯努力，那么做出好的研究成果并非不可能。随着海外院校对中国学校 GPA 含金量的重新认识，研究成果在出国申请过程中的权重日渐增加。它甚至可以扭转你的一切劣势，把你送进最顶尖的名校。这直接导致出国申请的竞争从 GPA ，渐渐地转移到论文上来了。国外大学也发现，与其冒险去招一个可能除了考试什么都不会的人，不如招一个可以实实在在做出研究成果的人。一篇优秀的论文压倒众多 GPA 狂人的例子已成了常见的现象。所以如果你要出国留学，那么提前接触研究是极端有必要的。它不仅在申请学校的竞争中能让你脱颖而出，更且能让你自己思考自己是不是适合做研究，甚至在选校、联系教授阶段，都会带给你非常好的先机。</p><p>当然，既然是出国念书，那么语言方面的准备自然是必不可少的了。我们不应该把对英语的学习当成一个负担。如果你真的想要做有意义的学问，那么你没有任何理由不看英文的著作和论文，没有任何理由不去了解国外的最新科研进展。而很自然地，你的英语能力会随着你在专业方面的努力而不断提高。多读英文原著，多和国外的优秀研究者交流，尽可能地让自己融入到科研的前沿，那么你的英语能力很快会有质的飞跃。当然为了能够出国，你必须得参加几项英语考试，比如 TOEFL 和 GRE 考试。不过，这些都是你到了大二可以慢慢了解和准备的，而且只要你足够的重视和一定的时间，通常都可以得到不错的分数，所以我们不建议你为了它们过分担心。</p><h4 id="警惕出国中介"><a href="#警惕出国中介" class="headerlink" title="警惕出国中介"></a>警惕出国中介</h4><p> 到目前为止，在我接触过的数百申请者中，靠中的“华丽包装”让自身实力得到提升并获得名校认可的案例，一个都没有！如果中介声称，有些人通过他们的服务进入了顶级学校的顶级项目，那我有八成把握认为该事件属于下面两种情况之一：</p><ol><li>中介在撒谎。出于保护客户利益的考虑，中介没有义务向你证明他们去年那个去 Harvard 的客户到底是谁。也就是说，客户这边根本无法证明是不是真的有人在中介的推荐下去了 Harvard 。</li><li>客户是中介聘来的。有的时候，中介宁肯倒贴钱，也会让一些自身条件极为优异的学生成为自己的客户。通常，这些客户的“硬实力”足够强（例如已经发表了世界顶级的论文），不需要什么技巧也有实力冲击全球最顶尖的学校。 </li></ol><p>中介的骗局还不止这些。哪怕你是一个背景和水准都非常一般的同学，他们也会将一些很著名的学校列在合同中，但要注意的是，最近美国经济情况很差，以至于一些听上去颇为华丽的名字（例如常春藤联盟中的某些学校），每年也会发出数额惊人的 Master Program Admission 来支撑财政。此类项目每年要收取极其高昂的学费，并且不提供任何奖学金机会。对于自费项目，拿到 Admission 并不是什么难事，根本不需要所谓的高人给你指点什么特别的“申请技巧”。</p><p>至于“无效退款”的保证，就更是纯粹的噱头了。一个公司每年可能会接待数百客户。就算你的申请一败涂地，连很差的保底学校都没有拿到，到了让他们退款的地步，他们也不过只是损失了百分之一的暴利（中介的边际成本很低，有的完全是在用去年某人的文章，稍作修改就成为你的申请材料，几乎无需额外太多成本。自然，失败也不会有什么损失），但是你失去的却是一年宝贵的时间。</p><p>你愿意将希望寄托在中介身上么？如果连将自己推销给目标学校都全盘需要第三方帮忙，留学的意义在哪里呢？</p><h3 id="做真正的研究"><a href="#做真正的研究" class="headerlink" title="做真正的研究"></a>做真正的研究</h3><h4 id="合理的研究态度"><a href="#合理的研究态度" class="headerlink" title="合理的研究态度"></a>合理的研究态度</h4><p>我们不应该为了 PhD 学位而含辛茹苦地做研究，正如我们不应该为了特长生加分而痛苦地练钢琴、提琴一样。基础知识、研究灵感、交流能力、吃苦耐劳的精神之类的较高要求暂且不说，要想成为一名研究人员，一个人至少不能讨厌研究（相对他所能从事的其他工作而言，不讨厌研究）。</p><p>不少同学之所以进实验室做研究是为了出国。他们甚至明目张胆地说自己不喜欢也不适合做研究。这种为了出国而做研究的想法本末倒置，是非常错误的。出国念书的核心目的，本应是为了争取一个更好的做研究的环境。对于一个不适合做研究的人而言，花五六年甚至更长时间读博士，那就像坐牢一样痛苦！我认识好几名同学，他们在本科的时候信誓旦旦地要投身科学事业，但是真正坐在实验室里，不到一年就坐不住了。最后只拿硕士学位就匆匆走人。我很想告诫这类同学：费尽心思把自己往 PhD 的火坑里推，是一件可悲而且可怕事情</p><h4 id="区分上学与研究"><a href="#区分上学与研究" class="headerlink" title="区分上学与研究"></a>区分上学与研究</h4><p>各位平时上课、学习、考试、升学，仿佛是在挤一条独木桥：考点就那么多，题型就那么几种，学生不需要天分，甚至不需要太多技巧，只要投入足够多的时间，闷着头往前冲，总可以高分过关。而对于一名研究者而言，摆在你面前的是一片开阔的汪洋大海，仅靠毅力闭着眼睛向前冲是很难看到新大陆的。研究中没有辅导书，也没有老师告诉你教学大纲，在脑海中勾勒出一个清晰的知识结构是每名研究人员自己的事。新进入研究领域的学生，必须学会如何自己归纳知识结构。如果有人问及你正在做的工作，你应该能像从 Google Earth 中找自己家一样，把自己的工作在一年、五年、十年、甚至整个世纪的时间尺度下，并且清晰、准确、不带偏见地勾勒出你正在做的工作在整个学科中的位置。可以说，清醒的位置感和准确的方向感，是比雄厚的基础知识更为重要的成功要素。</p><p>在研究中，知道做什么比知道怎样做更为重要。</p><p>没人能保证哥德巴赫猜想一定是对的或是错的，也没人能保证你正在做的研究是否一定会有漂亮的结果。如果知识掌握没什么大问题，做作业通常会带给你一帆风顺但是平淡无奇的感觉，而做研究则是正相反。在绝大部分研究人员的绝大部分时间里，工作经常是没有效果没有方向甚至没有头绪的。但伴随着这长期的压抑，攻克难关所带来的瞬间的欢乐也绝非做出习题可比。</p><p><strong>一个成熟的研究人员必须学会习惯失败。</strong></p><h4 id="知识积累"><a href="#知识积累" class="headerlink" title="知识积累"></a>知识积累</h4><p>知识积累是一个很有技巧并且很注重效率的工作。刚刚进入研究领域的同学们，最大的障碍往往是要面对浩如烟海的文献资料，不知从何处入手。在这个时候，我们首先应该为自己绘制一张关于知识的地图。在这张地图上，我们要标明自己所在领域的研究对象，主流研究方法，研究分支的结构，以及当前存在的最大问题和最新进展。只有搞明白这些事情之后，我们才能朦胧地知道自己是否适合这个学科，自己最欠缺哪方面的知识，以及最重要的，应当按照什么样的顺序去获取知识。</p><p>在进入研究领域的第一步，我不推荐直接读论文，因为论文总是给人一种承前启后的感觉：他们大都是建立在前人理论的基础之上，并且里面所记述的工作通常也并未完结。这些显然不适合一个初学者来阅读。</p><p>我们在研究起步阶段，应该仔细阅读该领域的权威教科书。一般来讲，知识会随着时间而沉淀，在一代代人的努力下变得精炼而富有结构性。一本好的教科书则可以很好地总结记录这样的结构。较新的教科书可以涵盖上个世纪末到本个世纪初的绝大部分科学成果，对当今的研究热点一般也会有较好的介绍。负责任的教科书还会提供翔实的参考文献，并推荐进一步的参考读物。</p><p>对于教科书的选择容不得半点马虎。对于初学者想在短时间评估书籍质量，首先应该咨询学长，让他从他确实读过的书里给你一个合理的推荐。或者，你可以重点关注教材作者的身份，以及教材的应用范围（被哪些名校选为教材）。一个简单的技巧是多关注国内的影印版书籍。因为各大出版社在引进影印版图书时，肯定会做谨慎的评估。经过这样评估甄选出来的教材，通常是广受好评，多次再版，并被诸多国际顶级学府选定为教材的佳作；并且，引进影印版的目的之一就是为了填补国内相关领域的空白。所以在条件允许的情况下，我们鼓励阅读此类书籍——哪怕是对于英文阅读比较吃力的同学也是如此。如果你因为语言问题，正在考虑选择影印版图书的中文译本，那要请你慎重。由于现在很多专业图书译者的水平低劣，职业道德缺失，我们经常可以碰到读得懂英文原文却搞不明白中文译文的情况。</p><p>如果想选择中文书籍进行阅读，那你就要更慎重了。除了极少数专家外，大部分中国学者用中文所撰写的科技类教科书，其质量让人遗憾。而且一般来说，越是前沿的科技，国内教材质量越差。这些书籍摆在身旁查阅尚可容忍。但是他们非常不适合作为初学者的启蒙读物！</p><p>一般教科书上每一个章节都是一个相对独立的研究方向。当我们对框架有了一定认识之后，就可以选择其中的一个或者几个分支定为自己中短期的研究课题。继而开始综述（review）类文章的阅读。所谓综述，其最大的看点在于对于过去知识的总结和回顾——他们记录了关于知识的知识。不少学科都有专门的综述类杂志，例如Annual Review, Nature Review。各大学术索引擎诸如 Google 和 Scopus，也都支持对综述类文章的搜索。另外，综述类文章的参考文献列表也极具参考价值。</p><p>通过阅读综述，我们很容易找到近年来优秀文章。从这些文章开始学习，我们就可以较为全面地了解一个学科的全貌，因为无论从思维方式，解决问题的方法，还是实验设计、数据处理的细节。能被综述类文章大加赞赏的论文，一定有他独到的地方。</p><h4 id="衡量学术价值"><a href="#衡量学术价值" class="headerlink" title="衡量学术价值"></a>衡量学术价值</h4><p>没有老师给你判分，也没有参考答案可以借鉴。在做研究的时候，我们只能靠自己思考来辨别一个理论的学术价值。</p><p>真正能断定一个理论是不是垃圾，有多大价值，要看他会不会被后人记住。真正好的理论往往会引发人们广泛而深刻的探讨，甚至是争论。后来的人们会站在该理论的基础之上做出更为充实的科学贡献。如果在一个学术会议上，你的文章能让大家在上厕所时候还在讨论，我敢说这文章一定是个好理论。如果用量化指标做参照，论文的引用数可以从侧面说明一些问题。当今学术界的顶尖科学家基本上都有几篇引用数（ cite index ）达数千的成名之作。而实际上，学术界比较通用的“影响因子”，也是通过引用数计算得到的。</p><p>但是即使参考引用数这个指标，也仍然存在特例：有些极端功利的作者在意识到引用数的重要性后，通过不必要的“自引”（在自己后来写的文章中引用自己原来的文章）来提高论文引用率。</p><p>除了衡量别人已经发表的文章的学术地位，我们也要学会如何客观地衡量自己未发表理论的价值。下面三条原则可以简单地衡量一个理论的内在价值：</p><p>新颖的好理论必须包含足够新颖的思考。那些你看到题目后就能猜到八九不离十的文章一般不是好文章。所谓科技论文，与实验报告的区别在于：文章的目的是宣扬新思想，报告的目的是记录实验过程。</p><p>简单。我只听说过某个理论复杂得臭名昭著，但却从来没听说过某个理论因复杂而受到赞扬。而实际上，越复杂的理论越有可能是堆砌着补丁的伪装——其内在思想却是肤浅的。为了避免把一个研究问题进行不必要的复杂化，我们必须攥紧 Occam 的剃刀： Entities must not be multiplied beyond necessity</p><p>普适好的理论要有广泛的听众。从这个意义上说，我们不应该把主要研究精力放在某个领域中某个特定子问题的某种特例上  </p><h4 id="一些常见误区"><a href="#一些常见误区" class="headerlink" title="一些常见误区"></a>一些常见误区</h4><p>你给思路，我来实现：有些学生，他们具有不错的基本功，实验动手能力也很强。但是却缺乏独立精神。在身边我每每可以看见这些同学日夜辛勤，但是却从事着低级的，缺乏创造性的工作。这些人可以成为很好的工人，但他们绝对不是称职的研究者。</p><p>虽说任何一个研究小组都必须有人来承担具体的工作，但我们的态度必须鲜明：我们不应因这些机械性工作而满足，更不可能期望“你说方向，我来实现”这样的工作模式。</p><p>如果你真正立志做研究，那么基础知识，尤其是数学方面的知识是非常重要的。但这些知识和上课关系真的不大。哪怕你交大的高数考了100分，充其量证明了你具有很好的应考能力。但是你用应用数学解决科学问题的本领到底有了多少提高呢？不要寄希望于通过上课、做作业就能掌握应用的能力。相比来说，更加直接而且高效的方法是早日进入研究领域，带着问题进行学习和锻炼。</p><p>这个课题太难太简单：很多人会为自己的懒惰寻找各种各样的借口，比如“这个理论太难，一定做不出什么东西”，或者“这个理论太简单，做起来没什么意思”。的确存在很难，或者很简单的理论，我们的取舍也是非常有必要的。但如果一个人习惯性地把新方向要么归为太难，要么归为太简单，这就是一个非常差的研究习惯了，会让他的研究根本无从下手。</p><p>担心自己理论太简单：不得不说，故弄玄虚是现在学术界一个很坏的风气。很多人喜欢把自己的简单理论包装起来，冠以时髦的数学或者物理名词，以为这样就会显得自己很渊博。实际上，这种做法乍一看也许会显得很花哨，但是在时间的考验下，过不了多久就会原形毕露。没意义的复杂包装只会让理论显得更丑陋和拙劣。</p><h3 id="管理者的智慧"><a href="#管理者的智慧" class="headerlink" title="管理者的智慧"></a>管理者的智慧</h3><p>作为管理者，必须要有很强的责任心。这是所有优秀管理行为的出发点。虽然管理者不用（也不应该）事必躬亲，但是管理者承担着比团队其它任何成员都重大的责任。而且我们在学生阶段能接触到的管理工作，基本不存在太多的利益关系。在这种时候，更需要我们用责任心来决定下一步行动。</p><h4 id="培养团队"><a href="#培养团队" class="headerlink" title="培养团队"></a>培养团队</h4><p>凭借个人英雄主义式的单打独斗并不是团队精神所倡导的。过分依靠个人能力会使团队变得不稳定，并且效率低下。作为一名管理者，必须思考如何将团队连接成一个整体。这需要靠全体成员的热情和士气作为纽带。为了有效地培养团队成员对于工作的热情，与你达成一致的目标，为了大家共同的理想去奋斗，这需要两个要素：</p><ol><li>价值观。你们的工作应该是充实而有意义的工作。这需要管理者潜意识中去引导，让团队成员切身感受到肩负重任。别人可以不在乎你们做了什么，但是团队自身应该要有共同的价值观，在工作的过程中体会到团队创造的价值。</li><li>来自团队成员的认可。管理者要在人际上组织好团队，让团队成员间相互信任与敬佩，营造良好的工作环境。管理者应多听每一个来自团队的声音，友善地对待每一位成员。不同管理者的管理手段可以不同，并不是说只有塑造具有亲和力的形象才算是管理上的成功。但至少，管理者不能因为担任管理职务就沾沾自喜，对团队的成员指手画脚。无论是在学校的各级组织，还是在外的公司，成功管理者都会以平和的心态对待他们工作上的每一位同事，并且主动地给予能够给予的帮助。</li></ol><h4 id="重在参与"><a href="#重在参与" class="headerlink" title="重在参与"></a>重在参与</h4><p>校园活动的目的是锻炼我们的能力。自打一开始就不应该期望这种活动能产生什么惊天动地的效果。</p><h4 id="认识设计类课程"><a href="#认识设计类课程" class="headerlink" title="认识设计类课程"></a>认识设计类课程</h4><p>对待课程的态度</p><p>如果你不是第一次参加设计类课程，那你一定知道，把全部精力放在设计课上是对时间的极大浪费。因为缺乏有效的指导，这种课程通常都会变成一次次无的放矢的演练。它无法有效提高设计能力，无法训练思维，也不会让你的设计类手法有什么提高。对于这类课程，希望同学们能牢记三个字——别当真！</p><p>请务必理性分配时间，追求更有效的学习方式，而不要把自己困死在“设计课”的泥沼中！</p><p>对待自己的态度</p><p>有很多同学在设计课上钻进了完美主义的死胡同。设计是工程，设计课更是工程。如果把课堂作业当成艺术的话，我不知道该说你幼稚还是愚蠢。要知道，方案设计永远没有尽头，但<strong>对一门设计课程作业，你的上限是多少小时？</strong>这在一开始就要规划好。绝对不要不计代价地追求所谓“更合理”的设计。</p><p>对待老师的态度</p><p>我们也不应对老师的水平和能力产生病态的崇拜。叫他看一眼你的图纸，他不太可能看得出你的设计理念，也不太可能了解你的设计过程，更不太可能给你一个建议让你觉得醍醐灌顶，胜读十年书。老师不可能对每个人的作品做出什么深入而客观的评价。事实上，影响你分数的，通常还是那些肤浅但容易量化的因素——诸如出勤、态度、书面报告。</p><h4 id="进度控制"><a href="#进度控制" class="headerlink" title="进度控制"></a>进度控制</h4><p>在老师面前控制好进度是取得高分的关键。我们给老师看图，并不是为了获得什么指导，而是要通过交图告诉老师，我有一个积极的态度。</p><p>切忌本着好大喜功，想一鸣惊人的心态，攒很长时间的工作，一次甩给老师。老师会被你那令人眼花缭乱的工作量惊呆么？绝对不会！相反，东西多了看着烦，还容易被挑毛病。老师完全可以轻易地在细枝末节的地方抓二十个莫须有的问题，然后把你的工作贬得一文不值。</p><p>在同等工作量的前提下，明智的进度控制应该是把自己的全部工作平均分配在各次课上提交。即便你已经做完了更多，也必须像说评书一样娓娓道来，说一半藏一半，不要一股脑呈现完。</p><p>因为不是所有同学都有新东西，所以我们更要保证每次上课都有新的东西给老师看，并注意和老师多加“探讨”。只要混个脸熟，你的印象分就会有很大提升。</p><p>在设计的最后阶段，尤其不要进行无谓的修改,不要把时间浪费在徒劳的心理抚慰上。即使老师提出了一些修改要求，你也没必要完全照办。把现有阶段的设计表现清楚，按时交图，这是想拿高分的基本要求。</p><h3 id="小心项目的陷阱"><a href="#小心项目的陷阱" class="headerlink" title="小心项目的陷阱"></a>小心项目的陷阱</h3><p>交大部分老师的科研水平很令人失望，他们自己完全没什么像样的研究。跟着这样的老师做项目，我们通常也很难得到研究素养上的锻炼。如果你因为参与一些低层次但是没有任何锻炼价值的项目而耽误了大量时间，打乱了自己计划的进度，将会是一件非常得不偿失的事情。</p><p>所谓项目不外乎老师的私活，或学校的 PRP ——传说中的本科生研究项目；再不然就是一些带有政治色彩的竞赛项目。总体上说，带本科生项目的老师的水平和责任心都是让人失望的。如果你已经有了充分的思想准备，但仍然还是对某个老师的某个项目有兴趣，那么你必须在决定参加之前，进一步确定该课题是否属于自己的学术兴趣，或者是否对自己的研究有帮助。而你能做出合理判断的前提，必须是你很清楚自己发展的大方向。作为一名学生，不清楚自己的学术兴趣本该是一件极其不正常的现象。</p><p>绝大多数所谓项目，都是极其空泛的。不要寄希望于通过做一些项目“发现”自身的学习兴趣。</p><h4 id="辨别项目的质量"><a href="#辨别项目的质量" class="headerlink" title="辨别项目的质量"></a>辨别项目的质量</h4><p>PRP 项目</p><p>通过 PRP 项目的题目，我们通常就能看出这个项目的质量。没有针对性的课题通常不会意味着高质量的研究成果。很多 PRP 项目，一看题目就知道是非常空洞且好大喜功的。例如《历年世博会建筑场馆的研究》之类。我们必须放弃脑中残存的对老师的盲目崇拜，用我们的独立思考能力想想，这样的题目，在一个学期到一年的业余时间里，以我的水平到底能研究出多少有意义的东西？具体来说，世博会始于1851年，每届场馆数量上百，性质不一，统统放在一起研究，用一个学期时间，你难道能得到一个不是很肤浅的结论么？</p><p>如果题目看不出究竟，我们还可以看研究提纲。一般你在参与一个项目前，可以向导师咨询具体的研究提纲。当然了，因为很多老师本身组织 PRP 就很敷衍，他们自然也拿不出深入思考的提案。最多说两句官腔味道十足的空谈。顺便说一句，如果有老师不断强调这样的观点“因为还没开始研究，于是拿不出一个足够细致足够切实可行的方案”。那么你要特别提高警惕。因为这种话，通常是学术骗子在申请经费想空手套白狼的时候才会说的。</p><p>接下来，我们还可以认真阅读项目的研究方式。很多 PRP 的实质不是研究，而是收集整理资料。我们再拿《历年世博会建筑场馆的研究》举例。2010年的上海世博会是第五十一届，前五十届世博会都不是在中国召开的。我们能对那些远在异国的建筑有多少接触——且不说这里面很多建筑在世博会闭幕后不久就都被拆除。显然老师不会组织境外考察，所以，我们所谓“研究”的手段只剩下上网搜索和读书。整理他人的看法和说法最终形成一份报告，这顶多算是文秘的工作，可绝对算不上“研究”。</p><p>最后，我们还需要关注项目团队的数量和质量。一个导师，要是想做好研究，他一定会认真选择参与者，并有效控制人数。要知道，做研究不是打群架，人数的堆积不会带来任何优势。面对这样巨大的团队，不要说导师还有其他工作，就算是全职来带这一个项目，也不可能给每个人都提供有意义的指导。当然，实际情况是导师通常更忙，所谓的“辅导”，实际效果也会更糟糕。</p><p>老师的“私活”</p><p>说到老师的横向项目，或者通俗点说，“私活”，我们就需要更加慎重了。大多数情况下，你是以听话、廉价、高效的劳动力的身份参与到一个横向项目中来的。你的角色只是一个不拿工资的打工仔——或者稍好些，有微薄的工资。无论如何，任何学生都不要妄想成为项目的合作者。因此，问清楚项目周期和工作任务是决定加入的必须前提。我们必须明白自己头上的工作，究竟在哪个层面对自己有帮助。要知道，老师“私活”的商业性质多于学术性质，甚至可以因商业牺牲学术原则。</p><p>可以的话，再多询问已经在项目组里的同学，听听他们的经历和经验，你会得到很多内幕消息。</p><h4 id="选择导师"><a href="#选择导师" class="headerlink" title="选择导师"></a>选择导师</h4><p>一个可以参考的匿名导师评价网站为<a href="https://mysupervisor.org">导师评价网</a>，不过可惜的是很多老师都缺少评价，想要了解一个老师以下特点，需要跟他手下的在读学生或者已毕业学生联系获取更准确的信息。</p><h5 id="导师类型"><a href="#导师类型" class="headerlink" title="导师类型"></a>导师类型</h5><p>可以简单把高校教授们分为四类，但一部分老师可能同时具有两到三类的特征。</p><ol><li>功成名就的大老板，在国内就是有院士长江杰青千人的title，在国外就是本领域有影响力的学术组织的fellow，在计算机领域即为ACM、IEEE fellow。大老板们往往手下会招聘一些青年教师和博士后帮他管理团队，自己大概率脱离科研一线，主要精力花在与领域内其他大佬social拉经费、项目，维持庞大团队的运转，这样的老师不一定是个好的advisor，但大概率是个好的lab manager。大老板不会亲自带学生尤其是本科生，你会被组内小老板或者博士生指导，如何跟到一个靠谱的小老板需要运气，想要在一个庞大的组里做出吸引大老板的成果也相对难度较高。</li><li>青年教师，也被称为青椒，他们刚在学术界独立出来，拥有了自己的实验室，有了招收硕士和博士生的资格，在当下国内高校全面铺开海外tenure-track非升即走的制度下，他们需要在六年的时间中达到系里副教授的门槛，评价指标包括论文发表、拉到经费数额、开设课程数量等。由于中国高校吸引人才归国的能力稳步提升，近些年来国内顶级高校招聘的助理教授往往都是欧美不错的博士毕业生，他们一般比一些八九十年代土博毕业留校的老师视野更广阔，了解本领域下最前沿的科研脉络，研究的品味相对较好。他们不像大老板们有很多科研以外的杂事需要处理，你能得到更多hands-on的指导，他们的学生是否成功也将与他们自己的命运（能否tenure）紧密相连，他们会尽最大努力帮助你，出成果的速度会快一些，相应的导师传导给学生的压力也会更大，但是助理教授们的起步资源相对有限（拿到青年千人title的会好很多）。</li><li>养老型教授，不管是国内高校老体制下的教授或者海外tenure-track体制下已经拿到终身教职的教授，他们的职位已经非常稳定，会有一部分比例的教授在40岁之后的阶段进入养老阶段，原因可能包括进一步评职称无望干脆开始享受轻松生活、或者事业发展进入平稳期等，他们对发更多文章已经没有很高的欲望，这种导师一般适合只要一纸文凭的学生，期间比较自由，但自制力不强的学生可能毕业时成长很有限。</li><li>创业或者热衷于接工业界横向项目的教授。这类教授有些是想通过接工业界横向项目为自己捞钱，也有一部分是想完成科研成果转化，扩大自己的影响力到工业界扬名立万，他们往往更多精力放在公司上，对学生的指导比较有限。</li></ol><h5 id="人品与指导学生态度"><a href="#人品与指导学生态度" class="headerlink" title="人品与指导学生态度"></a>人品与指导学生态度</h5><p>参与科研项目虽然跟上课是很不一样的过程，但是除了个人的努力之外，老师愿意花费多少精力指导你，给予你多少科研资源（在计算机领域比如提供服务器，在实验学科则是提供良好的实验设备，还包括一些隐形的资源如当遇到导师不熟悉的问题他是否能为你介绍合适的老师协助你解决问题），给你是否靠谱有前途的课题等等都是你很难控制的因素。科研项目也存在较大不确定性，当项目卡住时，问题可能是多方面的：1）课题本身不靠谱。2）提出的解决办法有问题。3）学生在实现细节上出了问题。一个好的导师应该利用自己过往的经验帮助学生解决问题而不是一味批判学生笨，灌类似“你要相信自己一定可以解决这个问题”的鸡汤同样对解决问题帮助很小，如果该条路的确失败风险较大，导师应该及时调整航向避免更大的沉没成本，保护好学生的科研积极性也是导师应该考虑到的问题。为了保证课题平稳推进，青椒应该跟学生有固定的每周一对一meeting，大老板应该跟学生有相对低频率的meeting或者在学生遇到问题主动寻求帮助的时候给予支持。这一点需要自己多接触不同类型的导师，多感受才能知道自己真正适合什么样的指导风格。</p><h5 id="在读和已毕业学生出路"><a href="#在读和已毕业学生出路" class="headerlink" title="在读和已毕业学生出路"></a>在读和已毕业学生出路</h5><p>私以为作为老师，最好的状态是“桃李满天下”，一个老师最大的财富是他培养出来的学生，一个把论文和经费看的比学生更重的老师有较大可能把学生当成他的“学术工具人”。学生毕业后的出路是老师在学界/业界影响力+老师是否用心推荐学生找工作+学生在组内深造期间成长的综合体现，一般不要期望自己能超过组内毕业生出路的上限，多考虑平均值更合理，同时可以观察在读学生平均文章发表情况，第一篇文章发表耗时以及质量等</p><h5 id="实验室文化"><a href="#实验室文化" class="headerlink" title="实验室文化"></a>实验室文化</h5><p>这是一个很抽象的概念，你在适应导师的指导风格的前提下，同时也需要考虑是否适应实验室的一些固定文化比如：</p><ol><li>实验室学生需要打卡吗？每周有固定工作时间限制吗？40小时，60小时还是更多？</li><li>组内学生合作氛围如何？还是每个学生有自己独立的项目要完成。</li><li>实验室会组织一些集体活动如春游秋游吗？</li></ol><h4 id="好老师与坏老师"><a href="#好老师与坏老师" class="headerlink" title="好老师与坏老师"></a>好老师与坏老师</h4><p>在此很难为好老师下一个通用的定义，简单来说一个老师人好且在乎你自己的研究兴趣，支持你自主独立的想法，并且在自己能力范围内为你提供研究的软硬件条件——哪怕这些工作和他的项目并没有直接的关系，若还能做到因材施教那便是非常难得的了，一个好老师在你毕业后依然会是你终身的好朋友。这里可以列举一些经常出现在坏老师身上的特征：</p><ol><li>安排学生为实验室做很多杂活如经费报销、跑项目手续到处找领导盖章签字、取快递、写材料等。</li><li>不将精力用在指导学生完成科研项目而用在训斥学生上，试图通过威胁学生让学生害怕，试图通过夸夸其谈（画饼）让学生信服，不尊重学生的个人意愿和研究兴趣。</li><li>用不合理要求卡学生毕业，组内学生延毕比例较高。</li><li>克扣学生的助研补助到自己腰包。</li><li>自身学术水平一般喜欢瞎指导。</li><li>不尊重学生的私人时间、身体健康和个人隐私。</li><li>把学生当成工具人，压榨学生帮自己完成横向项目赚钱。</li><li>抢学生的一作authorship</li><li>依靠advisor-advisee的不平衡关系对学生实施精神控制等</li></ol><h5 id="碎碎念-1"><a href="#碎碎念-1" class="headerlink" title="碎碎念"></a>碎碎念</h5><p>本科期间参与研究是因材施教的体现，并不意味着好学校的本科生都需要如此，切忌随大流卷入本科生科研低龄化的趋势中去，科研不是本科教育中最重要的组成部分，博士毕业后也只有很小一部分人能终身以科研作为一份工作。本科期间加入靠谱的实验室，参与合适的研究课题，能锻炼同学各方面的能力，如果课题进展顺利最后能有高水平论文发表带来的自信心提升也是跟获得高GPA的乐趣是完全不一样的。即使项目进展不如人意，这也是在试错成本可接受范围内的，记得积极定期与导师保持高效沟通，与导师共享一致的目标，在科研的道路上相互成就</p><h4 id="团队与合作伙伴"><a href="#团队与合作伙伴" class="headerlink" title="团队与合作伙伴"></a>团队与合作伙伴</h4><p>团队协作精神，应当是各展所长、互为补充的高效率工作。我们不能以“团队合作”的名义，迁就或容忍那些低效率、无责任心的合作者。</p><p>我们不能保证每位合作者都和你做项目的初衷一致，我们更不能保证每位合作者都有足够的道德水平。在一个病态的团队中，低效率、抢风头、拈轻怕重的情况会时常出现。这种团队合作变成了勾心斗角的训练。这对正直的人进行严肃的研究来说，是百害而无一利的事情。当然，在这样的团队中，不太可能做出什么成果，反倒甚至会让自己沾染上一些不良的习惯。所以如果你发现你周围的环境就是这样，那么请尽快离开这样的团队。</p><h3 id="保研者说"><a href="#保研者说" class="headerlink" title="保研者说"></a>保研者说</h3><p>路没有好坏之分，只有适不适合之别。不是说工作的人一定有闯劲，也不能说出国的人就一定有更光明的前途。</p><p>有个问题在一开始就要问自己：读研，是一条什么样的道路？</p><h4 id="明确目的"><a href="#明确目的" class="headerlink" title="明确目的"></a>明确目的</h4><p>读研的动机主要有两种：</p><ol><li>需要一个硕士的文凭提高社会地位，方便就业。</li><li>想积累一定的研究经验，为将来出国或者工作做准备。</li></ol><p>这两方面的动机都有它自己的道理。我认为，只要一个动机能激励你积极向上，那这就是正确的动机。但是根据交大的现状，我们做出“读研”这样的决定，还是需要相当的深思熟虑。</p><p>我们先说说“社会需要硕士”这件事。撇开能力不谈，硕士文凭对各专业就业前景的影响可以说是千差万别。所以，抱着这样打算的同学们不要轻信所谓“硕士好就业”这样的谣言。在选择读研之前，一定要真正了解这个行业，认清学历在未来几年的工作中可能起到的作用，比如具体薪金、升职期望等要素。</p><p>如果你是从积累研究经验的角度考虑读研，这种想法我比较认同。有的人可能会以为早一点参加工作也可以积累研究经验，为将来出国做准备。但实际上，公司的环境和学校里面还是有很大差异的。虽然劳动法早就规定了八小时工作制，但是一般研发部门是不会给你朝九晚五的机会的——不加班绝对是小概率事件！在高度紧张的工作中，你是一个出卖劳动力的角色。你的工作统统是上级指派下来的，而你不能选择做什么或不做什么。长此以往，你会发现自己在工作之外的积累少之又少。相比来说，交大的研究生生活，不管如何糟糕，至少不会让你为每天的生计发愁。可以说，学校帮你缓冲掉了许多压力。同时，你也可以利用这几年时间做一些自己喜欢的事情。如果你还想继续提升一下自己的价值，读研是一个不错的选择。</p><p>这里有一点需要强调，每年我们看到保研后都有无数人后悔，我们也能听到工作的人对读研的无不羡慕。这都是围城心态。一些工作的人怀念读书的生活，觉得读研更好，比做打工仔更有前途；但读研的人又觉得还是工作好，可以赚钱和积累经验，也不用和某个讨厌的导师在一起工作。</p><h4 id="硕士之后"><a href="#硕士之后" class="headerlink" title="硕士之后"></a>硕士之后</h4><p>读研，充其量只是一种缓冲——当你不知道做什么好的时候，或者你知道了做什么好但是时间已经不足以让你获得理想的结果的时候，你没有更多的选择，于是才继续读硕士，寄希望于给自己一段可以继续努力的时间。但是，在这段时间里，如果你再不认真思考（很多优秀的人本科时候就做过这些思考了），那么可能你还会浑浑噩噩地留校读个博士。再之后呢？</p><h2 id="生存技巧"><a href="#生存技巧" class="headerlink" title="生存技巧"></a>生存技巧</h2><h3 id="选课原则与选课技巧"><a href="#选课原则与选课技巧" class="headerlink" title="选课原则与选课技巧"></a>选课原则与选课技巧</h3><h4 id="选课选什么"><a href="#选课选什么" class="headerlink" title="选课选什么"></a>选课选什么</h4><p>我们选课并非选课程，而是选上课老师。</p><p>选择正确的老师，仍然是对整门课程最终成绩影响最大的一个因素——甚至要远大于你前半个学期是否认真上课！</p><p>具体来说，我们选一个老师，应该从下面几点情报综合考虑：</p><p>• 点名方式：老师上课是否点名？点名是以什么方式进行的？一般来说，签到、喊到、随堂测验，想蒙混的难度逐渐递增。我们关注是否点名，重点应该看的是这个老师面对学生的态度。有的老师睁一只眼闭一只眼，即使不来上课，也不会太为难学生。而另外一些比较自卑的老师却把学生不来上课当成对自己的奇耻大辱，甚至会想出课前课后点两次名外加数人头这样的手段防止学生翘课。其实，如果老师想不计代价查出谁没来上课，这真的是太简单的一件事情。所以我们重点还是看这个老师的态度，而非他上个学期具体采用了哪种点名手段。</p><p>• 期末考试成绩的比重：对于一门考试分数普遍不高，大多数人没把握拿到90+ 的课程（诸如 A 类的高数、大物），我们要尽量选那些平时成绩（包括作业成绩、小论文成绩之类）占比重比较大的老师。因为经验上说，只要稍微动动脑筋，勤快一点，最多再留意下和研究生助教交流的谈话技巧，平时成绩拿满分绝对要比考试拿满分轻松很多。所以，对于考试难度大的课程，我们的基本策略就是通过选课减小期末考试成绩所占的比重。但是对于一些非常简单的课程，情况就正好相反了。</p><p>• 关于考前透题的误解：关于这一点大家可能存在一些误解。一般情况下，是否透题并不是一个可靠的选老师指标。越是出题的老师，就越会避嫌而对考点三缄其口。相反，没有出题的老师也许会凭经验押题或者是看到考卷后间接地把考点告诉大家。</p><h3 id="突击备考"><a href="#突击备考" class="headerlink" title="突击备考"></a>突击备考</h3><p>从学习知识而言，上课是一件奢侈的事情。对突击复习考试而言，所谓的“慢工出细活”也是奢侈的。如果你认为这门课不重要，请不要在两个星期以前开始复习，因为两个星期足够让你忘掉其中一大半的知识。通常，有效的复习是在3天之内开始的，因人略有差异。我不否认个人之间的IQ存在差异，但是这种差异是如此之小，以至于甚至不能成为左右考试成绩的主导因素。充其量，有些同学可以以笨鸟先飞的名义，把一门课程需要的复习时间从3天延长到5天，不会更多。当然，我们这里说的是针对大多数靠突击有可能能拿高分的课程。</p><h4 id="注意复习范围"><a href="#注意复习范围" class="headerlink" title="注意复习范围"></a>注意复习范围</h4><p>通常老师在复习课上都会把考点和考试范围告诉大家。对考点的正确解读可以让你事半功倍。比如，有一些脸皮比较薄的老师在划考点的时候，不喜欢明目张胆地说“这章不考”，而是会换一种更加委婉的说法，比如“这章的内容主要是介绍性的，有兴趣的同学们可以进一步拓展”。我相信大部分同学对于这样的话都能有正确的理解。至于考点的准确性，我认为我们不应该心中有任何疑问。虽然的确存在过老师说不考的地方真的考了，但是那种事情出现几率非常低。</p><p>我们在考前最后一节课上，一定要毫无保留地相信老师、相信考点，并且，还要相信不同老师考点的交集。</p><h4 id="三天冲刺"><a href="#三天冲刺" class="headerlink" title="三天冲刺"></a>三天冲刺</h4><p>3天之内，你需要准备的：</p><p>• 课本（没错，就是这门课的教材）</p><p>• 上课 PPT ，如果你的老师的PPT只是把教材原样照搬的话</p><p>• 一位懂得这门课程的朋友</p><p>• 平时作业列表</p><p>• 全书考点（或者不考的点）的列表</p><p>首先，请懂得这门课程的朋友吃饭，让他用半小时的时间，用通俗语言，按章节给你介绍这门课是做什么的，每一部分的考点是什么。吃饭结束之后，和他约考试前一天下一次见面的时间。然后翻开教材，看目录，将不需要考的内容划掉。回忆那位朋友的话，想象每一章的标题所代表的内容。以3倍速的速度将书翻一遍，无论看懂不看懂，进一步领会朋友所说的话，如果是理工类课程，争取每章自己总结一个能够说服自己的理论。</p><p>找出平时作业列表，当然了，通常来说你肯定是一道题目也不会做。这很正常，你不必为此感到紧张或绝望，不上课直接做作业本这本身就是让人绝望的。你需要做的是，把作业和答案放在一起，开始扫荡，用半天的时间保证你知道答案的那些数是怎么算出来的。注意：你没有时间一道一道题目去做，把你高中老师告诉你的要扎扎实实的说法抛到脑后吧，扎扎实实你应该好好上课去。</p><p>如果顺利搞明白了作业，你现在大约可以考40分了。你会遇到一些情况，比如作业题目你看不懂，你不知道答案上面那些鬼东西是在说什么。勾上相关的章节。将刚刚勾过的章节逐一以两倍速浏览，注意看公式和黑体字。你会发现你小学套公式，中学套公式，到了大学，还是在套公式。接下来你只需要把你不会的题代到相关章节的相关公式下，做好字母和中文的对应翻译工作。</p><p>现在你不会的题目应该很少了。这会儿开始看 PPT 。注意，不要一开始就看 PPT ，当然，更不要一边看 PPT 一边看 Comic 。知识是书上来的， PPT 是演讲稿，不要因为懒不去翻书。</p><p>有些关键点，看课本看不懂，就去看 PPT （因为教课书在关键点上总喜欢使用脑残体），看 PPT 看不懂（部分 PPT 写的和书一样脑残，而且还有错），就去看课本；再不行还有 Google 。如果在非常关键的知识点遇到了无论如何都不明白的情况，那就赶紧抄起电话，找到你的那个朋友求助。</p><p>在考试之前前一天之内，把所有的公式或者解题步骤都写在一张纸上，用剩下除睡觉之外的时间去熟悉这张纸，根据例题的形式在脑中按照这个套路演练。但是不要试图拿着这张纸作弊——风险太大回报太低不合算；把上面的内容抄到桌子上也不可取——在考试时，你根本不会有机会去把桌面当图书馆查来查去，这样做只会让你心虚，一边惦记这个事儿一边浪费大量时间。考试的时候，尽量不要抄周围同学的，因为你周围的人复习的不一定比你好。</p><p>如果你前面工作做的足够好，那你一定要有信心。题目要么你都会做，要么大家都不会做。关于选择题，请尽量用你的大脑，不要胡猜。</p><h4 id="考试结束后"><a href="#考试结束后" class="headerlink" title="考试结束后"></a>考试结束后</h4><p>一哭二闹三上吊是下下策，只有当其他的手段都无效时，再考虑这样的办法。对于某些老师，你唯一的选择就是考到80+。对于另外一些比较好说话的老师，你可以跟他们谈谈你对课程的理解，以及对这门学科的看法。在谈话中，最佳的切入点是学术。你要尽可能地讨论学术方面的问题，而不是去强调你要出国，你要保研。每个人都有各种各样的私人借口来要求一个好的成绩，但是这些借口并不一定都能成为让老师帮你一把的理由。</p><h4 id="复习箴言"><a href="#复习箴言" class="headerlink" title="复习箴言"></a>复习箴言</h4><p> 有一些课程没有习题，或者说老师布置的作业没有代表性，那你必须需要去购买一本习题集，或者看别人的上课笔记</p><p>做题一定要找有答案的，你没有时间去自己确定你做的每一个答案是否正确。</p><h3 id="旁门左道"><a href="#旁门左道" class="headerlink" title="旁门左道"></a>旁门左道</h3><h4 id="学术灌水"><a href="#学术灌水" class="headerlink" title="学术灌水"></a>学术灌水</h4><p>介绍如何在垃圾学术期刊上灌水的技巧并非我们所鼓励的。在学校里，我们愤怒地发现有同学以为做研究就是灌水。本段的主旨就是要通过消除信息不对称，纠正这种错误思想。我们有必要指出，不论质量地发表论文，并不是什么神秘的事情。只要知道了相关的流程，你能，我能，甚至连机器都能。</p><p>首先，我们要明白，水刊、水会和正经学术期刊会议的差别在于，前者靠发表别人的文章盈利——通常还都是暴利。所谓“核心期刊”的版面费，收你每篇两千块钱就已经是很客气的了。这没什么好奇怪的。学生毕业要靠论文，老师评职称也要靠论文。对于那些没有任何学术水平的混子们，自然也就只能靠“买论文”这种手段确保生存。而我们的现状是，中国的科研队伍中，有相当数量的人都是混子，这一大群人的生存需求促进了水期刊、水会议如雨后的狗尿苔（实在无法用春笋形容它们）般滋生出来。如果你愿意交钱，自然有人愿意接受你的文章——不管你的文章写得多烂。 </p><p>期刊</p><p>在万方数据库上查找相关方向关键词，多找一些期刊，看每个期刊每月能刊登多少篇文章。如果一个月有100篇以上或更多，那想也不要想，这期刊一定是水刊。随便写两笔，直接投就可以了。进一步地，可以通过查找每篇文章作者的信息确认该刊物是否是水刊。有的时候你会发现一些xx学报上的作者都是些没名气小学校的老师/学生，那就更可以放心大胆地投了。要注意，国内有不少“核心期刊”的目录，找到这些目录的差别，可以方便你的投稿。比如：交通大学的核心期刊目录和北大核心期刊目录不同，这时，你可以投不在“北大目录”却在“交大目录”里面的期刊，这样的期刊</p><p>一般稿件相对数量略少。另外是一些小细节：</p><p>• 在致谢里写上牛人，可以给自己撑腰。</p><p>• 有些期刊有页数限制，超过页数就需要加钱，这时读者可以先投稿，中稿后，然后再将文章压缩到最便宜的长度。</p><p>• 能写大老板的名字就加上去，因为一般的期刊都不是盲审。</p><p>• 文章投出去后，不要死等。记得经常和编辑电话交流感情（仅限于那些水刊，正常刊物或者牛刊物的话，编辑都很忙，通常没功夫理你）。要让糟糕杂志的编辑觉得自己很受重视，很有成就感。</p><p>• 参考文献多引用你要投的期刊上的论文。</p><p>会议</p><p>近年来，由于供求关系的压力，很多杂牌会议也不断在国内涌现。举办学术会议，通常比办杂志，更加有利可图。除了拿注册费赚钱之外，更有人觉得通过组织会议能够提升自己的“声望”。有人图名，有人图利，还不怎么费事（会议组织期间，真正跑腿的还是主办教授手下的研究生们），何乐而不为！甚至我认识某个会议的组织者还说过这样的话：“其实我们不会怎么审文章，就是在审稿截止日前随便看看，没什么大问题就直接接收了。”</p><p>对于这些会议，你只要老老实实地按照规定格式提交，别说内容烂，甚至没有内容也一样能中。毫不夸张地说，读者只要使用前文介绍过的 SCI Generator ，投稿到上述的会议，您的论文大抵会被接收。</p><p>只要你想灌水，把你写的中文课程设计的报告提炼一下，翻译出主要内容，再根会议指定的论文模板排排版。一定可以被某些IEEE XXXX 国际会议接收。</p>]]></content>
    
    
    <summary type="html">SurviveSJTUManual阅读笔记。第一次看完觉得挺好的，清理收藏夹时，又读了一遍，并整理出了一些笔记</summary>
    
    
    
    <category term="书摘" scheme="https://changqingaas.github.io/categories/%E4%B9%A6%E6%91%98/"/>
    
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>什么是node.js</title>
    <link href="https://changqingaas.github.io/js/js/%E4%BB%80%E4%B9%88%E6%98%AFnode.js/"/>
    <id>https://changqingaas.github.io/js/js/%E4%BB%80%E4%B9%88%E6%98%AFnode.js/</id>
    <published>2021-08-31T08:56:30.000Z</published>
    <updated>2021-08-31T01:09:23.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js简介"><a href="#node-js简介" class="headerlink" title="node.js简介"></a>node.js简介</h1><ul><li><p>node.js是运行在服务端的JavaScript,是一个事件驱动I\O服务端JavaScript环境</p></li><li><p>查看版本</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>node版本管理工具nvm</p></li></ul><h1 id="Node-js应用"><a href="#Node-js应用" class="headerlink" title="Node.js应用"></a>Node.js应用</h1><ul><li>Node.js应用的构成：<ul><li>引入required模块</li><li>创建服务器</li><li>接收请求与相应请求</li></ul></li></ul><h2 id="创建Node-js应用"><a href="#创建Node-js应用" class="headerlink" title="创建Node.js应用"></a>创建Node.js应用</h2><ul><li><p>步骤一：引入required模块</p><ul><li>使用require指令来载入http模块，并将实例化的HTTP复制给变量http，实例如下：  <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>步骤二： 创建服务器</p><ul><li>创建一个server.js的文件：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">,</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span>response</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 发送http头部</span>    <span class="token comment">//HTTP状态值：200：OK</span>    <span class="token comment">//内容类型：text/plain</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token string">'Content-Type'</span><span class="token operator">:</span>'text<span class="token operator">/</span>plain<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//发送响应数据 “Hello World"</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//终端打印如下信息</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server running at http://127.0.0.1:8888/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用node命令执行以上代码</p>  <pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">node server.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>访问<a href="http://127.0.0.1:8888">http://127.0.0.1:8888</a></p></li></ul></li></ul><h2 id="npm使用介绍"><a href="#npm使用介绍" class="headerlink" title="npm使用介绍"></a>npm使用介绍</h2><ul><li><p>查看npm版本</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>升级版本</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm install npm -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装包</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm install &lt;Module Name&gt; # 本地安装npm install &lt;Module Name&gt; -g # 全局安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看安装信息</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm list -g # 查看全局安装的模块npm ist &lt;Module Name&gt;# 查看某个模块的版本号npm ls# 查看当前目录下的包信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>卸载模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm un &lt;Module Name&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>更新模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm update &lt;Module Name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>搜索模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">npm search &lt;Module Name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建模块</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$npm init# 会自动生成package.json$npm adduser # 在npm资源库中注册用户Username:XXXXPassword:XXXXEmail:XXXX$npm publish# 发布模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h2><ul><li><p>REPL(Read Eval Print Loop:交互式解释器)，Node自带交互式解释器，可以执行读取,执行,打印,循环等任务</p></li><li><p>在Node的REPL中可以执行：</p><ul><li>简单的表达式计算</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$node&gt;1 + 45&gt; 5 &#x2F; 22.5&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用变量</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node&gt; 1+45&gt; 5&#x2F;22.5&gt; x&#x3D;1010&gt; var y&#x3D;10undefined&gt; x+y20&gt; console.log(&quot;Hello World!&quot;)Hello World!undefined&gt;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>多行表达式</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node&gt; do &#123;... x++;... console.log(&quot;x:&quot;+x);... &#125;while(x&lt;5);x:1x:2x:3x:4x:5undefined&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>下划线变量<strong>[使用下划线(_)获取上一个表达式的运算结果]</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node&gt; var x&#x3D;10;undefined&gt; y&#x3D;10;10&gt; x+y20&gt; var sum&#x3D;_undefined&gt; console.log(sum)20undefined&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>两次ctrl+c停止REPL</p><h2 id="Node-js的回调函数"><a href="#Node-js的回调函数" class="headerlink" title="Node.js的回调函数"></a>Node.js的回调函数</h2><ul><li><p>Node.js异步编程的直接体现就是回调</p></li><li><p>阻塞代码实例</p><ul><li><p>创建一个文件 input.txt ，内容如下：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建 main.js 文件, 代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"程序执行结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>以上代码执行结果如下：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node main.jsHello World！程序执行结束!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>非阻塞代码实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"程序执行结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码执行结果如下：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ node main.js程序执行结束!Hello World!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p></li><li><p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">学习node.js</summary>
    
    
    
    <category term="js" scheme="https://changqingaas.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>How-to-be-a-good-programmer</title>
    <link href="https://changqingaas.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/others/To-be-a-good-programmer/"/>
    <id>https://changqingaas.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/others/To-be-a-good-programmer/</id>
    <published>2021-08-29T12:30:16.000Z</published>
    <updated>2022-01-17T01:18:37.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实例驱动学习"><a href="#实例驱动学习" class="headerlink" title="实例驱动学习"></a>实例驱动学习</h2><p>在知识爆炸的年代, 想成为一个好的程序员, 要具备这样一个精神:</p><p><strong>开发者精神</strong></p><blockquote><p>开发者精神是指, 从学习编程第一天起, 你的目标, 你所做的事, 永远不是以<code>要学会XX</code>为目标, 而是以<code>开发出XX</code>为目标, 深刻意识到你学习的一切, 最终是为了你的开发而服务的。</p></blockquote><p>而开发者精神的反面则是<code>学生气</code>:</p><p><strong>学生气</strong></p><blockquote><p>从学习编程的第一天起, 就把自己当学生, 上课听讲记笔记为第一位, 记忆知识点为第一位, 买教材读教材为第一位, 追求<code>学会XX</code>, 而不是<code>用它开发出XX</code>。</p></blockquote><p>我们举个例子， 假如你要学习Java，<code>学生气</code>的学生行为模式:</p><pre><code>读教材, 听课, 记笔记, 追求把这个语言的每个知识点都记得很清楚, 追求一种&quot;内功&quot;的修炼, 在这个过程中, 从来不想着用它去&quot;创造&quot;什么. 在学习的第一天起, 他给自己定下了一个目标:&quot;我这个学期一定要把这个语言的基础打牢, 最后在考试中取得高分, 并且为以后的学习提供更坚实的基础.&quot;</code></pre><p>那么具有<code>开发者精神</code>的人会这样做:</p><pre><code>先大体了解一下Java语言在哪些领域比较强势, 做一个简单的调研, 得出了Java在Web领域很强势这一个信号, 于是在学习Java的第一天起, 他就给自己定下了一个目标: &quot;我要在半年内通过学习Java, 运用Java做出一个中小型的, 基于Web的企业管理后台&quot;</code></pre><p>这两种人, 起点都一样, 都是<code>完全不会Java</code>, 但是最后的结果往往是, 后者无论是知识熟练度还是实用性都会超过前者, 而且整个学习过程会有源源不断地动力.</p><p><code>夯实基础</code>这个目标, 其实是空洞的, 什么叫做夯实? 什么叫做基础? 而且就算你真的夯实了基础, 你也极有可能陷入一种<code>虚无感</code>中, 因为你的所有知识, 都会遗忘.</p><p>这就是为什么很多计算机专业学生很爱问的一个问题:</p><pre><code>&quot;学了这么多知识, 忘了怎么办?&quot;</code></pre><p>如果你具备<code>开发者精神</code>, 那么你根本不会理会这个问题, 因为, 你开发出的东西, 你做出的产品, 它就是永久存在在这个世界上的, 你的成就感来源于真实的, 具体的, 可持久延续的项目中, 而不是来源于”我学会了什么”.</p><p>我们一定要明白:</p><pre><code>一切不谈成就感, 不谈反馈的学习劝导, 都是在耍流氓</code></pre><p>既然我们想获得反馈, 那么一个很现实的建议就是, 在Github上创建你的第一个开源代码仓库, 长期地, 稳定地commit, 当然, 至于这个仓库到底是干啥的, 这个因人而异, 有可能是你自己开发的一个VScode插件, 有可能是你自己写的读书笔记, 在这个不断地commit的过程中, 感受你的代码仓库不断增长不断完善的过程中, 你会获得一个比较持久的反馈和成就感, 一旦有了反馈和成就感, 那么你的学习动力就会一直保持, 也可以从学习中获得快乐.</p><p><strong>记住, 你不是学生, 你是开发者.</strong></p><h2 id="知识输入与输出"><a href="#知识输入与输出" class="headerlink" title="知识输入与输出"></a>知识输入与输出</h2><p>当你学习一个东西的时候, 如果学完马上用语言讲给别人听, 你会学的更好, 而且会发现新问题.</p><p>很多学习理论都指出, 知识的学习, 输入固然重要, 输出更为重要.</p><p>输入就是学习别人的知识, 输出就是把自己学会的知识用文字, 语言的形式表达出来, 很多人的学习, 只有输入, 没有输出, 这样的学习肯定是不行的.</p><p>几乎所有优秀的程序员, 都有撰写技术文章的习惯, 很多时候, 并不是他们什么都懂, 而是他们刚学会了什么, 然后就围绕着这个刚学会的东西, 用自己的语言讲出来, 久而久之, 就会被别人觉得是大牛, 但是他和你的区别, 有可能仅仅是是否输出的区别.</p><p>建议所有计算机学习者, 都要有写技术文章/读书笔记的习惯, 可以发表在自己的个人主页, 其他平台上, 攥写技术文章也可以很好地增加面试官对你的好感.</p><p>写技术文章的时候, 最好用<code>MarkDown</code>哦, 程序员是不需要用<code>Word</code>这种东西的, 我们的内容是要方便发表在网站上, <code>Word</code>不能直接在网站里显示, 而<code>MarkDown</code>可以轻易地转换成<code>html</code>格式文件, 在浏览器中显示.</p><h2 id="代码风格篇"><a href="#代码风格篇" class="headerlink" title="代码风格篇"></a>代码风格篇</h2><p>现在几乎所有主流语言都有相应的代码风格检查工具, 一般已IDE或Editor的插件或扩展形式给出</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式并不是针对任何一种语言, 而是一种用编程语言描述现实世界问题广泛采用的各种模式, 比如, 观察者模式, 工厂模式, 依赖注入模式等.</p><p>好的设计模式, 是好代码的保证, 只有先学会了设计模式, 才能在软件设计中游刃有余, 而且更现实的问题是, 现在很多框架, 比如Spring, Angular等, 都充斥了大量的设计模式, 比如<code>Factory Pattern</code>, <code>Dependency Injection Pattern</code>, 你必须理解这些设计模式, 你才能理解这个框架.</p><p>个人认为设计模式没有必要买本教材, 结合视频和技术文章, 就足以理解和运用.</p><h3 id="小习惯"><a href="#小习惯" class="headerlink" title="小习惯"></a>小习惯</h3><ol><li>不要嫌变量名长, 最好可以直接通过变量名推测变量的作用.</li><li>重复出现的代码, 封装成独立的类或函数.</li><li>提前降低代码的耦合度, 不同作用, 不同类别的代码, 不要混在一起, 最好分成独立的文件</li><li>将代码进行业务分层, 比如在Web开发中, 有数据层, 服务层, DTO层, Controller层, 渲染层等, 只有将层次分开了, 才能获得足够的可拓展性, 不然代码多了你就全乱了.</li><li>用良好的设计模式去”设计”软件, 在执行一些算法的时候, 可以想一想它的时空复杂度, 想一想怎么可以让它执行地更快.</li></ol><h2 id="如何管理自己的电脑"><a href="#如何管理自己的电脑" class="headerlink" title="如何管理自己的电脑"></a>如何管理自己的电脑</h2><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p>为了更好的管理我们的各种应用包，最好使用包管理工具来进行各种包，软件的安装和使用, 方便进行卸载, 更新, 安装, 无需打开浏览器即可完成一系列操作.</p><blockquote><p>linux : apt-get (ubuntu distro)<br>    osx : brew<br>    windows: Chocolatey</p></blockquote><p>另外, windows平台上的包管理工具, 在国内的网络环境下经常慢的感人, 所以<code>Chocolatey</code>可能使用体验并不好.  推荐使用今年微软新发布的 <code>WSL2</code>, 这个东西不是那种传统的虚拟机, 有了它你可以像操作linux系统那样操作windows系统, 而且支持 <code>docker</code>, 甚至我推荐以后大家所有命令都可以在<code>WSL2</code>里执行.</p><h3 id="容器-Docker"><a href="#容器-Docker" class="headerlink" title="容器 - Docker"></a>容器 - Docker</h3><p>为了更方便的进行开发环境配置，我推荐所有计算机学生尽早了解和使用Docker。</p><p>Docker 就是为了解决复杂的环境配置问题而生的。</p><p>它将你的软件和软件所依赖的所有环境打包成一个镜像(Image), 该镜像可以在任何一台装有docker 的电脑上运行, 和操作系统无关, 也就是docker 把运行环境和你的操作系统隔离开来了，中间隔了一层docker engine 。</p><p>写过不少代码的你一定见过这种现象：你的代码在自己电脑上能运行，但是在别人电脑上就会报错，无法运行，原因很简单，任何软件的运行都需要环境。</p><p>比如，jar包的运行需要jre ，python脚本的运行需要python 解释器安装在电脑上，以后你可能还需要运行一些服务，比如数据库mysql server , redis , rabbitmq , 随着软件运行环境复杂度的增加, 你的软件运行条件也变得苛刻，如果你想把本地的应用部署到服务器上，那事更多，需要的环境得一个个地装到你的linux服务器上，如何彻底解决这个问题？</p><p>只需在你的电脑中安装docker , 你就可以毫无后顾之忧。</p><p>所有的环境，服务，软件都是以Image 的形式打包的，Image 中包含了运行你软件的所有东西，比如你的软件是个python 脚本, 并且使用了第三方库flask，那这个Image 中就包含了python ,也就是它的base image , 也同时包含了flask, 这样的话任何一个装有docker的电脑都可以运行你的image。</p>]]></content>
    
    
    <summary type="html">记住, 你不是学生, 你是开发者.</summary>
    
    
    
    <category term="碎碎念" scheme="https://changqingaas.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="Advice" scheme="https://changqingaas.github.io/tags/Advice/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="https://changqingaas.github.io/%E7%88%AC%E8%99%AB/Python/Python%E7%88%AC%E8%99%AB/"/>
    <id>https://changqingaas.github.io/%E7%88%AC%E8%99%AB/Python/Python%E7%88%AC%E8%99%AB/</id>
    <published>2021-08-27T06:25:32.000Z</published>
    <updated>2022-02-04T05:46:45.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬虫概念"><a href="#爬虫概念" class="headerlink" title="爬虫概念"></a>爬虫概念</h1><h2 id="1-robots协议"><a href="#1-robots协议" class="headerlink" title="1.robots协议"></a>1.robots协议</h2><p>也叫robots.txt，是存放在网站根目录下的文本文件，用来告诉搜索引擎该网站哪些内容是不应该被抓取的，哪些是可以抓取的。</p><p>如<a href="https://www.csdn.net/robots.txt">https://www.csdn.net/robots.txt</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">User-agent: *Disallow: &#x2F;scriptsDisallow: &#x2F;publicDisallow: &#x2F;css&#x2F;Disallow: &#x2F;images&#x2F;Disallow: &#x2F;content&#x2F;Disallow: &#x2F;ui&#x2F;Disallow: &#x2F;js&#x2F;Disallow: &#x2F;scripts&#x2F;Disallow: &#x2F;article_preview.html*Disallow: &#x2F;tag&#x2F;Disallow: &#x2F;*?*Disallow: &#x2F;link&#x2F;Sitemap: https:&#x2F;&#x2F;www.csdn.net&#x2F;sitemap-aggpage-index.xmlSitemap: https:&#x2F;&#x2F;www.csdn.net&#x2F;article&#x2F;sitemap.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-常见的反爬虫措施"><a href="#2-常见的反爬虫措施" class="headerlink" title="2.常见的反爬虫措施"></a>2.常见的反爬虫措施</h2><h4 id="1-请求头校验"><a href="#1-请求头校验" class="headerlink" title="1.请求头校验"></a>1.请求头校验</h4><p>一般网站会对请求头进行校验，比如Host，UA，Content-Type字段等，模拟请求的时候，这些常见的请求头最好是带上。</p><h4 id="2-IP访问次数控制"><a href="#2-IP访问次数控制" class="headerlink" title="2.IP访问次数控制"></a>2.IP访问次数控制</h4><p>同一个IP地址短时间内大量发起请求，会引起IP限制，解决方法是用代理IP，或者构建自己的代理IP池。</p><h4 id="3-接口请求频率限制"><a href="#3-接口请求频率限制" class="headerlink" title="3.接口请求频率限制"></a>3.接口请求频率限制</h4><p>有的网站会控制接口访问的频率，比如有些查询接口，控制两三秒访问一次。</p><h4 id="4-接口访问次数限制"><a href="#4-接口访问次数限制" class="headerlink" title="4.接口访问次数限制"></a>4.接口访问次数限制</h4><p>每天限制某个IP或账号访问接口的次数，达到上限后出现二次验证或者直接封账号/IP.比如登录接口</p><h4 id="5-行为认证"><a href="#5-行为认证" class="headerlink" title="5.行为认证"></a>5.行为认证</h4><p>请求次数过多会出现人工认证，如图片验证码，滑动认证，点击认证等，可以对接打码平台。</p><h4 id="6，自动化环境检测"><a href="#6，自动化环境检测" class="headerlink" title="6，自动化环境检测"></a>6，自动化环境检测</h4><p>selenium自动化工具有的网站会检测出来，大部分可以通过下面两种方式跳过检测,下面两种方式无法处理的话，还可以尝试把页面改为移动端页面(手机模式)，最后还有一种方法就是代理服务器拦截修改js代码，把检测selenium的js修改掉。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">options &#x3D; webdriver.ChromeOptions()# 躲避部分网站selenium检测options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])options.add_experimental_option(&quot;useAutomationExtension&quot;, False)driver &#x3D; webdriver.Chrome(executable_path&#x3D;chromedriver_path, options&#x3D;options)# 躲避部分网站selenium检测script &#x3D; &quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;);&quot;driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: script&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于移动端appium的检测，可以尝试替换为uiautomator2实现自动化</p><h4 id="7-数据动态加载"><a href="#7-数据动态加载" class="headerlink" title="7.数据动态加载"></a>7.数据动态加载</h4><p>有的数据不是通过html页面的接口请求返回的，抓包分析请求，找到正确的数据接口。</p><h4 id="8-请求参数加密"><a href="#8-请求参数加密" class="headerlink" title="8.请求参数加密"></a>8.请求参数加密</h4><p>网易云音乐的post请求的请求体就是前端经过js加密后计算得到的，需要逆向js代码</p><h4 id="9-返回数据加密"><a href="#9-返回数据加密" class="headerlink" title="9.返回数据加密"></a>9.返回数据加密</h4><p>需要逆向js代码，分析如何解密。还有一种像大众点评的评论，需要通过定位去找到文本。</p><h4 id="10-动态更新cookies"><a href="#10-动态更新cookies" class="headerlink" title="10.动态更新cookies"></a>10.动态更新cookies</h4><p>华为手机云服务，每次请求接口都会重新设置cookies，并且请求头参数也需要跟着cookies一起变化</p><h1 id="Python爬虫之requests库"><a href="#Python爬虫之requests库" class="headerlink" title="Python爬虫之requests库"></a>Python爬虫之requests库</h1><h2 id="一-发送请求"><a href="#一-发送请求" class="headerlink" title="一.发送请求"></a>一.发送请求</h2><p>requests提供了http的所有基本请求方式：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsr &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;)r &#x3D; requests.put(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;put&quot;)r &#x3D; requests.delete(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;delete&quot;)r &#x3D; requests.head(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;)r &#x3D; requests.options(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>基本get请求中参数的传递：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># requests允许使用params关键字参数，以字典的形式来提供get请求url中的参数。payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;r &#x3D; requests.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;, params&#x3D;payload)print(r.url)  # http:&#x2F;&#x2F;httpbin.org&#x2F;get?key2&#x3D;value2&amp;key1&#x3D;value1# 字典中的value还可以以列表的形式传入payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: [&#39;value2&#39;, &#39;value3&#39;]&#125;r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, params&#x3D;payload)print(r.url)http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;value1&amp;key2&#x3D;value2&amp;key2&#x3D;value3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加请求头headers<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;some&#x2F;endpoint&#39;headers &#x3D; &#123;&#39;user-agent&#39;: &#39;my-app&#x2F;0.0.1&#39;&#125;r &#x3D; requests.get(url, headers&#x3D;headers)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>Post请求<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;, data&#x3D;payload)print(r.text)# 可以为 data 参数传入一个元组列表# 在表单中多个元素使用同一 key 的时候，这种方式尤其有效：payload &#x3D; ((&#39;key1&#39;, &#39;value1&#39;), (&#39;key1&#39;, &#39;value2&#39;))r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;, data&#x3D;payload)print(r.text)&#123;  ...  &quot;form&quot;: &#123;    &quot;key1&quot;: [      &quot;value1&quot;,      &quot;value2&quot;    ]  &#125;,  ...&#125;# post的为json对象url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;some&#x2F;endpoint&#39;payload &#x3D; &#123;&#39;some&#39;: &#39;data&#39;&#125;r &#x3D; requests.post(url, json&#x3D;payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>超时设置：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">requests.get(&#39;http:&#x2F;&#x2F;github.com&#39;, timeout&#x3D;0.001)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二-响应内容"><a href="#二-响应内容" class="headerlink" title="二.响应内容"></a>二.响应内容</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsr &#x3D; requests.get(&#39;https:&#x2F;&#x2F;github.com&#x2F;timeline.json&#39;)r.encoding&#x3D;&#39;utf-8&#39;r.text# [&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https:&#x2F;&#x2F;github.com&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网页乱码问题:<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查看网页编码print(res.apparent_encoding)# 设置编码res.encoding &#x3D; &#39;GB2312&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>二进制响应内容(r.content)<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import Imagefrom io import BytesIO#BytesIO用于操作内存中的二进制数据img&#x3D;Image.open(BytesIO(r.content))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>JSON响应内容（r.json()）<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsr &#x3D; requests.get(&#39;https:&#x2F;&#x2F;github.com&#x2F;timeline.json&#39;)r.json()# [&#123;u&#39;repository&#39;: &#123;u&#39;open_issues&#39;: 0, u&#39;url&#39;: &#39;https:&#x2F;&#x2F;github.com&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>响应状态码（r.status_code）<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)r.status_code200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>响应头(r.headers)<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">r.headers&#123;    &#39;content-encoding&#39;: &#39;gzip&#39;,    &#39;transfer-encoding&#39;: &#39;chunked&#39;,    &#39;connection&#39;: &#39;close&#39;,    &#39;server&#39;: &#39;nginx&#x2F;1.0.4&#39;,    &#39;x-runtime&#39;: &#39;148ms&#39;,    &#39;etag&#39;: &#39;&quot;e1ca502697e5c9317743dc078f67693f&quot;&#39;,    &#39;content-type&#39;: &#39;application&#x2F;json&#39;&#125;r.headers[&#39;Content-Type&#39;]&#39;application&#x2F;json&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="三-Cookies"><a href="#三-Cookies" class="headerlink" title="三.Cookies"></a>三.Cookies</h2><p>如果某个响应中包含一些 cookie，你可以快速访问它们：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; &#39;http:&#x2F;&#x2F;example.com&#x2F;some&#x2F;cookie&#x2F;setting&#x2F;url&#39;r &#x3D; requests.get(url)r.cookies[&#39;example_cookie_name&#39;]# &#39;example_cookie_value&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>要想发送你的cookies到服务器，可以使用 cookies 参数：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;cookies &#x3D; dict(cookies_are&#x3D;&#39;working&#39;)r &#x3D; requests.get(url, cookies&#x3D;cookies)r.text# &#39;&#123;&quot;cookies&quot;: &#123;&quot;cookies_are&quot;: &quot;working&quot;&#125;&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="四-会话"><a href="#四-会话" class="headerlink" title="四.会话"></a>四.会话</h2><p>requests.Session()这样可以在会话中保留状态，保持cookie等<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestss &#x3D; requests.Session()s.headers.update(&#123;&#39;x-test&#39;: &#39;true&#39;&#125;)r &#x3D; s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;headers&#39;, headers&#x3D;&#123;&#39;x-test2&#39;: &#39;true&#39;&#125;)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="五-代理"><a href="#五-代理" class="headerlink" title="五.代理"></a>五.代理</h2><p>如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"># http代理import requestsproxies &#x3D; &#123;  &quot;https&quot;: &quot;http:&#x2F;&#x2F;41.118.132.69:4433&quot;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;, proxies&#x3D;proxies)# socks代理proxies &#x3D; &#123;    &#39;http&#39;: &#39;socks5:&#x2F;&#x2F;user:pass@host:port&#39;,    &#39;https&#39;: &#39;socks5:&#x2F;&#x2F;user:pass@host:port&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="六-Prepared-Request"><a href="#六-Prepared-Request" class="headerlink" title="六.Prepared Request"></a>六.Prepared Request</h2><p>构造requests.Request对象，将Request对象作为参数传入requests.Session()对象的prepare_request()方法中，最后通过Session对象的send()方法发送请求。<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfrom requests import Requesturl &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;# 创建Session对象s &#x3D; requests.Session()# 构造Request对象req &#x3D; Request(&#39;GET&#39;,url)# 将Request对象转换成 PreparedRequest对象prepped &#x3D; s.prepare_request(req)# 利用Session对象的send()方法，发送PreparedRequest对象res &#x3D; s.send(prepped)print(res.text)print(type(prepped))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h1 id="Python爬虫之BeautifulSoup"><a href="#Python爬虫之BeautifulSoup" class="headerlink" title="Python爬虫之BeautifulSoup"></a>Python爬虫之BeautifulSoup</h1><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">html_doc &#x3D; &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p class&#x3D;&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt; and&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; class&#x3D;&quot;sister bro&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;;and they lived at the bottom of a well.&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt;&quot;&quot;&quot;soup &#x3D; BeautifulSoup(html_doc, &#39;html.parser&#39;)print(soup.prettify())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="find-all-name-attrs-recursive-string-kwargs"><a href="#find-all-name-attrs-recursive-string-kwargs" class="headerlink" title="find_all(name , attrs , recursive , string , **kwargs)"></a>find_all(name , attrs , recursive , string , **kwargs)</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查找所有的a标签res &#x3D; soup.find_all(&#39;a&#39;)# # 查找所有的a标签和p标签res &#x3D; soup.find_all([&#39;a&#39;, &#39;p&#39;])# 查找class&#x3D;title的p标签res &#x3D; soup.find_all(&#39;p&#39;, &#39;title&#39;)# 指定属性查找  可支持字符串，正则表达式，或者函数# 指定id查找元素res &#x3D; soup.find_all(id&#x3D;&quot;link1&quot;)# 指定href查找 [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;]res &#x3D; soup.find_all(href&#x3D;re.compile(&#39;elsie&#39;))# 指定多个属性查找res &#x3D; soup.find_all(id&#x3D;&#39;link1&#39;, href&#x3D;re.compile(&#39;elsie&#39;))# 指定多个属性查找 attrs参数res &#x3D; soup.find_all(attrs&#x3D;&#123;&#39;id&#39;: &#39;link1&#39;, &#39;href&#39;: re.compile(&#39;elsie&#39;)&#125;)# 通过css搜索res &#x3D; soup.find_all(class_&#x3D;&quot;sister bro&quot;)# 通过函数过滤,查找类名长度大于6的元素res &#x3D; soup.find_all(class_&#x3D;lambda x: x is not None and len(x) &gt; 6)# recursive参数，如果只想搜索直接子节点  recursive&#x3D;Falseres &#x3D; soup.find_all(&#39;title&#39;, recursive&#x3D;False)# find_all() 方法的返回结果是值包含一个元素的列表# 而find()方法直接返回第一个结果，没有则返回None.res &#x3D; soup.find(&#39;a&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 类查找res &#x3D; soup.select(&#39;.sister&#39;)# ID查找res &#x3D; soup.select(&#39;#link1&#39;)res &#x3D; soup.select(&#39;a#link1&#39;)# 通过是否存在某个属性查找res &#x3D; soup.select(&#39;a[href]&#39;)# 指定属性值查找res &#x3D; soup.select(&#39;a[href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot;]&#39;)# 查找返回第一个元素res &#x3D; soup.select_one(&#39;a[href]&#39;)# 获取元素的属性值res &#x3D; soup.select_one(&#39;a[href]&#39;).get(&#39;href&#39;)# 获取元素的文本res &#x3D; soup.select_one(&#39;a[href]&#39;).text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Selenium自动化"><a href="#Selenium自动化" class="headerlink" title="Selenium自动化"></a>Selenium自动化</h1><h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1.基础操作"></a>1.基础操作</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium import webdriverimport timefrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # 谷歌浏览器驱动    chromedriver_path &#x3D; &#39;chromedriver72.exe&#39;    options &#x3D; webdriver.ChromeOptions()    # 躲避部分网站selenium检测    options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])    options.add_experimental_option(&quot;useAutomationExtension&quot;, False)    driver &#x3D; webdriver.Chrome(executable_path&#x3D;chromedriver_path, options&#x3D;options)    # 躲避部分网站selenium检测    script &#x3D; &quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;);&quot;    driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: script&#125;)    # 浏览器最大化    driver.maximize_window()    url &#x3D; &#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;    driver.get(url)    # 显式等待    wait &#x3D; WebDriverWait(driver, 20, 1)    # 在主页输入框搜索requests，并点击搜索    input_ &#x3D; wait.until(EC.presence_of_element_located((By.ID, &#39;id-search-field&#39;)))    input_.send_keys(&#39;requests&#39;)    time.sleep(1)    btn &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@title&#x3D;&quot;Submit this Search&quot;]&#39;)    btn.click()    time.sleep(10)    driver.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h2><h4 id="查找单个元素"><a href="#查找单个元素" class="headerlink" title="查找单个元素"></a>查找单个元素</h4><p>最常用的定位元素的两个方法是通过Xpath和id来定位。</p><ul><li>find_element_by_id</li><li>find_element_by_xpath</li></ul><h4 id="查找多个元素"><a href="#查找多个元素" class="headerlink" title="查找多个元素"></a>查找多个元素</h4><ul><li>find_elements_by_xpath</li><li>find_elements_by_name</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过xpath查找元素driver.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@title&#x3D;&quot;Submit this Search&quot;]&#39;)# 通过id查找元素driver.find_element_by_id(&#39;id-search-field&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取元素内部内容"><a href="#获取元素内部内容" class="headerlink" title="获取元素内部内容"></a>获取元素内部内容</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">text &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;ISDCaptcha&quot;]&#x2F;div[2]&#x2F;div&#39;).get_attribute(&#39;innerHTML&#39;)if &#39;请绘制图中手势&#39; in text:    print(&#39;出现行为认证&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取元素指定属性的属性值"><a href="#获取元素指定属性的属性值" class="headerlink" title="获取元素指定属性的属性值"></a>获取元素指定属性的属性值</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;find-step3-phone&quot;]&#39;).get_attribute(&#39;style&#39;)driver.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;imgVerifyCodeP&quot;]&#39;).get_attribute(&#39;src&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="切换到指定iframe"><a href="#切换到指定iframe" class="headerlink" title="切换到指定iframe"></a>切换到指定iframe</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过id或者名称driver.switch_to.frame(&quot;iframeLoginIfm&quot;)driver.switch_to.frame(0)frame &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;loginDiv&quot;]&#x2F;iframe&#39;)driver.switch_to.frame(frame)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="切换到指定窗口"><a href="#切换到指定窗口" class="headerlink" title="切换到指定窗口"></a>切换到指定窗口</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver.switch_to.window(browser.window_handles[1])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="切换到alert弹窗"><a href="#切换到alert弹窗" class="headerlink" title="切换到alert弹窗"></a>切换到alert弹窗</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">text &#x3D; driver.switch_to.alert.textif &#39;图片验证码输入错误&#39; in text:    print(&#39;图片验证码识别错误&#39;)    driver.switch_to.alert.accept()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-元素交互"><a href="#3-元素交互" class="headerlink" title="3.元素交互"></a>3.元素交互</h2><h4 id="按钮点击"><a href="#按钮点击" class="headerlink" title="按钮点击"></a>按钮点击</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">btn &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div[@role&#x3D;&quot;button&quot;]&#x2F;div&#x2F;span&#x2F;span&#39;)btn.click()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="执行js代码"><a href="#执行js代码" class="headerlink" title="执行js代码"></a>执行js代码</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">style_ &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;passport-login-pop&quot;]&#39;).get_attribute(&#39;style&#39;)style_ &#x3D; style_.replace(&#39;display: none;&#39;, &#39;&#39;)if not style_:    style_ &#x3D; &#39;left: 259px; top: 212px; z-index: 60001;&#39;js &#x3D; &#39;document.getElementById(&quot;passport-login-pop&quot;).setAttribute(&quot;style&quot;,&quot;&#123;&#125;&quot;);&#39;.format(style_)driver.execute_script(js)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="表单输入"><a href="#表单输入" class="headerlink" title="表单输入"></a>表单输入</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">input_ &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;session[password]&quot; and @dir&#x3D;&quot;auto&quot;]&#39;)input_.send_keys(&#39;123qwe&#39;)from selenium.webdriver.common.keys import Keysinput_.send_keys(Keys.BACK_SPACE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver.execute_script(&quot;&quot;&quot;                (function () &#123;                    var y &#x3D; document.body.scrollTop;                    var step &#x3D; 100;                    window.scroll(0, y);                    function f() &#123;                        if (y &lt; document.body.scrollHeight) &#123;                            y +&#x3D; step;                            window.scroll(0, y);                            setTimeout(f, 50);                        &#125;                        else &#123;                            window.scroll(0, y);                            document.title +&#x3D; &quot;scroll-done&quot;;                        &#125;                    &#125;                    setTimeout(f, 1000);                &#125;)();                &quot;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模拟拖动"><a href="#模拟拖动" class="headerlink" title="模拟拖动"></a>模拟拖动</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium.webdriver.common.action_chains import ActionChainsdef get_track(self, distance):    track &#x3D; []    current &#x3D; 0    mid &#x3D; distance * 3 &#x2F; 4    t &#x3D; 0.2    v &#x3D; 0    while current &lt; distance:        if current &lt; mid:            a &#x3D; 2        else:            a &#x3D; -3        v0 &#x3D; v        v &#x3D; v0 + a * t        move &#x3D; v0 * t + 1 &#x2F; 2 * a * t * t        current +&#x3D; move        track.append(round(move))    return track# 模拟拖动btn &#x3D; wait.until(EC.presence_of_element_located((By.XPATH, xpath_)))track &#x3D; get_track(500)action &#x3D; ActionChains(browser)action.click_and_hold(btn).perform()action.reset_actions()for i in track:    action.move_by_offset(xoffset&#x3D;i, yoffset&#x3D;0).perform()    action.reset_actions()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-等待"><a href="#4-等待" class="headerlink" title="4.等待"></a>4.等待</h2><h4 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 显式等待wait &#x3D; WebDriverWait(driver, 20, 1)input_ &#x3D; wait.until(EC.presence_of_element_located((By.ID, &#39;id-search-field&#39;)))input_.send_keys(&#39;requests&#39;)time.sleep(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium import webdriverdriver &#x3D; webdriver.Chrome()# 隐式等待driver.implicitly_wait(10)driver.get(&#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;)logo &#x3D; driver.find_element_by_id(&#39;zh-top-link-logo&#39;)print(logo)driver.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-其他操作"><a href="#5-其他操作" class="headerlink" title="5.其他操作"></a>5.其他操作</h2><h4 id="解决页面加载时间过长问题"><a href="#解决页面加载时间过长问题" class="headerlink" title="解决页面加载时间过长问题"></a>解决页面加载时间过长问题</h4><p>有时候页面有些静态文件加载比较耗时，selenium可以不需要等待页面全部加载完全在去查找元素<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">options &#x3D; webdriver.ChromeOptions()# 解决页面加载阻塞问题options.set_capability(&#39;pageLoadStrategy&#39;, &#39;none&#39;)driver &#x3D; webdriver.Chrome(executable_path&#x3D;self.chromedriver_path, options&#x3D;options)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">options.add_argument(&quot;user-agent&#x3D;&#123;&#125;&quot;.format(&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.100 Safari&#x2F;537.36&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">socks5 &#x3D; &quot;socks5:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&quot;.format(socks5_proxy_ip, socks5_proxy_port)options.add_argument(&quot;--proxy-server&#x3D;&#123;&#125;&quot;.format(socks5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="捕捉F12控制台中所有请求记录"><a href="#捕捉F12控制台中所有请求记录" class="headerlink" title="捕捉F12控制台中所有请求记录"></a>捕捉F12控制台中所有请求记录</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesd &#x3D; DesiredCapabilities.CHROMEd[&#39;loggingPrefs&#39;] &#x3D; &#123;&#39;performance&#39;: &#39;ALL&#39;&#125;d[&#39;goog:chromeOptions&#39;] &#x3D; &#123;    &#39;perfLoggingPrefs&#39;: &#123;        &#39;enableNetwork&#39;: True,    &#125;,    &#39;w3c&#39;: False,&#125;options.add_experimental_option(&#39;perfLoggingPrefs&#39;, &#123;&#39;enableNetwork&#39;: True&#125;)options.add_experimental_option(&#39;w3c&#39;, False)driver &#x3D; webdriver.Chrome(executable_path&#x3D;self.chromedriver_path, options&#x3D;options, desired_capabilities&#x3D;d)# 保存loglog_list &#x3D; []for entry in driver.get_log(&#39;performance&#39;):    log_list.append(entry)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="屏幕截图-可以截取图片验证码加以识别"><a href="#屏幕截图-可以截取图片验证码加以识别" class="headerlink" title="屏幕截图,可以截取图片验证码加以识别"></a>屏幕截图,可以截取图片验证码加以识别</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import win32conimport win32guiimport win32printfrom win32api import GetSystemMetricsfrom PIL import Imagedef get_real_resolution():    &quot;&quot;&quot;获取真实的分辨率&quot;&quot;&quot;    hDC &#x3D; win32gui.GetDC(0)    # 横向分辨率    w &#x3D; win32print.GetDeviceCaps(hDC, win32con.DESKTOPHORZRES)    # 纵向分辨率    h &#x3D; win32print.GetDeviceCaps(hDC, win32con.DESKTOPVERTRES)    return w, hdef get_screen_size():    &quot;&quot;&quot;获取缩放后的分辨率&quot;&quot;&quot;    w &#x3D; GetSystemMetrics(0)    h &#x3D; GetSystemMetrics(1)    return w, hreal_resolution &#x3D; get_real_resolution()screen_size &#x3D; get_screen_size()screen_scale_rate &#x3D; round(real_resolution[0] &#x2F; screen_size[0], 2)pic_name &#x3D; &#39;***.png&#39;driver.save_screenshot(pic_name)# 找到图片验证码元素element &#x3D; driver.find_element_by_xpath(xpath_)left &#x3D; element.location[&#39;x&#39;] * screen_scale_ratetop &#x3D; element.location[&#39;y&#39;] * screen_scale_rateright &#x3D; (element.location[&#39;x&#39;] + element.size[&#39;width&#39;]) * screen_scale_ratebottom &#x3D; (element.location[&#39;y&#39;] + element.size[&#39;height&#39;]) * screen_scale_rateim &#x3D; Image.open(pic_name)# 裁剪图片im &#x3D; im.crop((left, top, right, bottom))im.save(pic_name)# 把图片转成base64,利用打码平台接口识别with open(pic_name, &#39;rb&#39;) as f:    code_img_base64 &#x3D; base64.b64encode(f.read()).decode()os.remove(pic_name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="xpath解析"><a href="#xpath解析" class="headerlink" title="xpath解析"></a>xpath解析</h1><ul><li>// :从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</li><li>/ : 匹配当前目录下的直接子节点。</li><li>.. : 匹配当前节点的父节点。</li><li>@：选取属性。</li><li>//* : 选取文档中所有元素</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">text &#x3D; &quot;&quot;&quot;            &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;            &lt;bookstore&gt;            &lt;book&gt;              &lt;title lang&#x3D;&quot;eng&quot;&gt;Harry Potter&lt;&#x2F;title&gt;              &lt;price&gt;29.99&lt;&#x2F;price&gt;            &lt;&#x2F;book&gt;            &lt;book&gt;              &lt;title lang&#x3D;&quot;cn&quot;&gt;Learning XML&lt;&#x2F;title&gt;              &lt;price&gt;39.95&lt;&#x2F;price&gt;              &lt;aa lang&#x3D;&quot;cn eng aa bb&quot; name&#x3D;&quot;cc&quot;&gt;Learning XML&lt;&#x2F;aa&gt;            &lt;&#x2F;book&gt;            &lt;&#x2F;bookstore&gt;&quot;&quot;&quot;from lxml import etreehtml &#x3D; etree.HTML(text)# print(etree.tostring(html).decode(&#39;utf-8&#39;))# 选取所有指定的节点res &#x3D; html.xpath(&#39;&#x2F;&#x2F;book&#39;)# 获取指定节点的所有直接子节点res &#x3D; html.xpath(&#39;&#x2F;&#x2F;book&#x2F;aa&#39;)# 获取指定节点的父节点res &#x3D; html.xpath(&quot;&#x2F;&#x2F;aa&#x2F;..&quot;)# 通过属性匹配选择节点res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title[@lang&#x3D;&quot;cn&quot;]&#39;)# 获取文本值res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title[@lang&#x3D;&quot;cn&quot;]&#x2F;text()&#39;)res &#x3D; html.xpath(&#39;&#x2F;&#x2F;price&#x2F;text()&#39;)# 获取属性值 [&#39;eng&#39;, &#39;cn&#39;]res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title&#x2F;@lang&#39;)# 属性多值匹配res &#x3D; html.xpath(&#39;&#x2F;&#x2F;aa[contains(@lang,&quot;aa&quot;)]&#39;)# 对于属性值有多个的节点，不用contains函数的话，匹配到的是空[]res &#x3D; html.xpath(&#39;&#x2F;&#x2F;aa[@lang&#x3D;&quot;aa&quot;]&#39;)# 文本匹配res &#x3D; html.xpath(&#39;&#x2F;&#x2F;title[contains(text(), &quot;XML&quot;)]&#39;)# 运算符res &#x3D; html.xpath(&#39;&#x2F;&#x2F;aa[contains(@lang,&quot;aa&quot;) and @name&#x3D;&quot;cc&quot;]&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python爬虫—代理池维护"><a href="#Python爬虫—代理池维护" class="headerlink" title="Python爬虫—代理池维护"></a>Python爬虫—代理池维护</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><ol><li>去代理网站上爬取大量代理IP，并将其存储在redis数据库。</li><li>定时获取redis中的所有代理IP，检测每一个代理IP是否可用。</li><li>通过flask，对外提供获取代理IP的接口，如果想要使用代理池中的代理IP，只需要访问我们提供的接口即可。<br><strong>现在网上免费代理IP网站越来越少，而且免费的代理质量非常不稳定，本文只是提供构建代理IP池的一种思路，实战的话还是要想办法获取优质的代理。</strong></li></ol><h2 id="代理池系统具体实现思路"><a href="#代理池系统具体实现思路" class="headerlink" title="代理池系统具体实现思路"></a>代理池系统具体实现思路</h2><p><img src="../pic/spiders/proxypool.png" alt=""></p><h2 id="代理池完整代码"><a href="#代理池完整代码" class="headerlink" title="代理池完整代码"></a><a href="agent_pool">代理池完整代码</a></h2><h4 id="agent-pool-py-整体流程"><a href="#agent-pool-py-整体流程" class="headerlink" title="agent_pool.py 整体流程"></a>agent_pool.py 整体流程</h4><p>存储模块：主要实现的功能是，去一些免费代理网站爬取大量的代理IP，并存储至redis数据库中。redis的Sorted Set结构是一个有序集合，我们会对每一个爬取到的代理IP<br>设置一个初始化的优先级10，Sorted Set也是通过这个优先级来进行排序的。&lt;/br&gt;</p><ul><li>Getter:爬取代理网站的免费代理IP，存入redis</li><li>Tester:从redis中取出代理，测试代理是否可用，并调整代理IP的优先级</li><li>Controller:启动Getter()与Tester()</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Crawler import Crawlerfrom RedisClient import RedisClientimport tracebackimport timeimport requestsimport multiprocessingfrom concurrent import futuresFULL_COUNT &#x3D; 2000class Getter(object):    # 爬取代理网站的免费代理IP，存入redis    def __init__(self):        self.redis_client &#x3D; RedisClient()        self.crawler &#x3D; Crawler()    def is_full(self):        # 判断代理池是否满了        return self.redis_client.get_proxy_count() &gt;&#x3D; FULL_COUNT    def run(self):        # 将爬取到的代理存入redis        if not self.is_full():            proxys &#x3D; self.crawler.get_crawler_proxy()            for proxy in proxys:                self.redis_client.add(proxy)class Tester(object):    # 从redis中取出代理，测试代理是否可用，并调整代理IP的优先级    def __init__(self, test_url):        self.redisdb &#x3D; RedisClient()        # 用来测试代理是否可用的地址        self.test_url &#x3D; test_url    def test_proxy(self, proxy):        try:            if isinstance(proxy, bytes):                proxy &#x3D; proxy.decode(&#39;utf-8&#39;)            proxies &#x3D; &#123;                &#39;http&#39;: &#39;http:&#x2F;&#x2F;&#39; + proxy,                &#39;https&#39;: &#39;https:&#x2F;&#x2F;&#39; + proxy            &#125;            print(&#39;正在检测:&#123;&#125;&#39;.format(proxy))            res &#x3D; requests.get(self.test_url, proxies&#x3D;proxies, timeout&#x3D;10)            if res.status_code &#x3D;&#x3D; 200:                return True, proxy            else:                return False, proxy                # 代理不可用，就降低其优先级        except Exception as e:            return False, proxy            # print(&#39;代理检测异常:&#123;&#125;  &#123;&#125;&#39;.format(proxy, e))            self.redisdb.decrease(proxy)            print(&#39;代理不可用:&#123;&#125;&#39;.format(proxy))    def run(self):        print(&#39;启动检测模块......&#39;)        try:            # 获取redis中所有爬取到的代理            proxies &#x3D; self.redisdb.get_all_proxy()            for i in range(0, len(proxies), 50):                test_proxies &#x3D; proxies[i:i+50]                workers &#x3D; len(test_proxies)                with futures.ThreadPoolExecutor(workers) as executor:                    tasks_res &#x3D; executor.map(self.test_proxy, test_proxies)                    for res, proxy in tasks_res:                        if not res:                            # 代理不可用，就降低其优先级                            self.redisdb.decrease(proxy)                            print(&#39;代理不可用:&#123;&#125;&#39;.format(proxy))                        else:                            # 代理可用,将其优先级置为最大                            self.redisdb.max(proxy)                            print(&#39;代理可用:&#123;&#125;&#39;.format(proxy))        except Exception as e:            print(traceback.format_exc())            print(&#39;检测模块出错！！！&#39;)class Controller(object):    def control_get(self):        # 获取功能：爬取代理网站，将代理存储到redis        getter &#x3D; Getter()        while True:            try:                getter.run()            except:                print(traceback.format_exc())            time.sleep(30)    def control_test(self):        # 检测功能，检测redis中的代理是否可用        tester &#x3D; Tester(test_url&#x3D;&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)        while True:            try:                tester.run()            except:                print(traceback.format_exc())            time.sleep(30)    def run(self):        print(&#39;代理池开始运行了......&#39;)        # 两个进程        get &#x3D; multiprocessing.Process(target&#x3D;self.control_get)        get.start()        test &#x3D; multiprocessing.Process(target&#x3D;self.control_test)        test.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    control &#x3D; Controller()    control.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="WebAPI-to-get-proxy-py-通过flask向外提供获取代理IP的接口"><a href="#WebAPI-to-get-proxy-py-通过flask向外提供获取代理IP的接口" class="headerlink" title="WebAPI_to_get_proxy.py 通过flask向外提供获取代理IP的接口"></a>WebAPI_to_get_proxy.py 通过flask向外提供获取代理IP的接口</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, gimport RedisClient&quot;&quot;&quot;    对外提供web接口，通过提供的web接口，来获取redis中的代理    g是上下文对象，处理请求时，用于临时存储的对象，每次请求都会重设这个变量。比如：我们可以获取一些临时请求的用户信息。&quot;&quot;&quot;app &#x3D; Flask(__name__)@app.route(&#39;&#x2F;&#39;)def index():    return &#39;&lt;h2&gt;欢迎来到daacheng代理池系统&lt;&#x2F;h2&gt;&#39;def get():    if not hasattr(g, &#39;redis&#39;):        g.redis &#x3D; RedisClient.RedisClient()    return g.redis@app.route(&#39;&#x2F;random&#39;)def get_random_proxy():    # 从代理池中返回一个代理    redisdb &#x3D; get()    return redisdb.get_proxy()@app.route(&#39;&#x2F;count&#39;)def count():    # 查询代理池中代理的个数    redisdb &#x3D; get()    return str(redisdb.get_proxy_count())@app.route(&#39;&#x2F;all&#39;)def get_all():    # 查询代理池中代理的个数    redisdb &#x3D; get()    return str(redisdb.get_all_proxy())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;5000)    app.debug &#x3D; True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">爬虫概念，requests库,BeautifulSoup库，selenium自动化，xpath解析，代理池维护</summary>
    
    
    
    <category term="爬虫" scheme="https://changqingaas.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>jupyter_notebook常用插件介绍</title>
    <link href="https://changqingaas.github.io/others/jupyter-notebook/jupyter-notebook%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://changqingaas.github.io/others/jupyter-notebook/jupyter-notebook%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-08-12T11:08:12.000Z</published>
    <updated>2021-08-12T11:24:49.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jupyter-NbExtensions-Configurator"><a href="#Jupyter-NbExtensions-Configurator" class="headerlink" title="Jupyter NbExtensions Configurator"></a>Jupyter NbExtensions Configurator</h2><p>Jupyter NbExtensions Configurator 是Jupyter Notebook的一个扩展工具，它提供了一系列标签，只需勾选相应插件就能自动载入。里面的插件能帮助减少工作量，书写更优雅的代码和更好的展示结构。</p><h3 id="安装Jupyter-NbExtensions-Configurator"><a href="#安装Jupyter-NbExtensions-Configurator" class="headerlink" title="安装Jupyter NbExtensions Configurator"></a>安装Jupyter NbExtensions Configurator</h3><p>用pip安装（conda应该同理）</p><p>Note:最好在关了jupyter的时候安装，不过问题不大</p><pre class="line-numbers language-none"><code class="language-none">pip install jupyter_nbextensions_configurator --userpip install jupyter_contrib_nbextensions --userjupyter contrib nbextension install --userjupyter nbextensions_configurator enable --user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装完毕，进入Jupyter Notebook，在主界面会多出一个NbExtensions的标签，里面有很多插件可供选择，示意图如下：</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925203501494-1338913967.png" alt="img"></p><p> 下面会重点介绍几个插件的用法，其余的不详细介绍，有兴趣的可以到官网（<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html）自行了解。">https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html）自行了解。</a></p><h3 id="Hinterland"><a href="#Hinterland" class="headerlink" title="Hinterland"></a>Hinterland</h3><p>勾选此插件为代码单元格中的每次按键启用“代码自动补全”菜单，而不是仅用Tab键时启用。</p><h3 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h3><p>这个插件会根据Markdown的标题层次形成一个目录，可以通过点击目录，直接定位到对应代码位置，在长代码文件中能起到导航的作用。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925205908910-259935432.png" alt="img"></p><p> 开启插件后，会在工具栏多出一个按钮，可通过点击按钮选择是否开启（如上图），官方示例如下</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925205346881-634502374.gif" alt="img"></p><h3 id="Snippets-Menu"><a href="#Snippets-Menu" class="headerlink" title="Snippets Menu"></a>Snippets Menu</h3><p>向Jupyter笔记本添加可定制的菜单项，以插入代码片段、样板文件和示例。</p><p>勾选此插件后，会多出一个Snippets的菜单项，菜单里包含多个模块的示例，通过简单的点击就能生成示例代码，可根据自己的需求稍作修改即可运行，减少代码工作量。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925210916560-990218179.png" alt="img"></p><h3 id="Codefolding"><a href="#Codefolding" class="headerlink" title="Codefolding"></a>Codefolding</h3><p>这个扩展将代码折叠功能从CodeMirror添加到codecell。</p><p>在编辑模式下，单击边距中的三角形(codecell的左边缘)或键入代码折叠热键(默认为Alt+F)，折叠代码。在命令模式下，折叠热键与编解码器的第一行有关。</p><p>折叠前：</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925211705294-581239589.png" alt="img"></p><p>折叠后是这样：</p><p> <img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925211802722-968013526.png" alt="img"></p><p>或者是这样：</p><p> <img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925211812161-1047071957.png" alt="img"></p><h3 id="Scratchpad-没添加"><a href="#Scratchpad-没添加" class="headerlink" title="Scratchpad(没添加)"></a>Scratchpad(没添加)</h3><p>为Jupyter Notebook提供一个草稿cell，方便随时测试输出。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925213326635-1759656941.gif" alt="img"></p><h3 id="Notify（没添加"><a href="#Notify（没添加" class="headerlink" title="Notify（没添加"></a>Notify（没添加</h3><p>在内核繁忙一段时间后再次空闲时显示一个浏览器通知——繁忙0、5、10或30秒后可配置。</p><p>这个插件功能在你需要长时间跑一个代码时可启用，无需在页面等待，程序运行完成后，会弹出通知。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925214041517-1148926022.png" alt="img"></p><h3 id="Collapsible-Headings"><a href="#Collapsible-Headings" class="headerlink" title="Collapsible Headings"></a>Collapsible Headings</h3><p>允许notebook有可折叠的部分，以标题分开。</p><p>任何标记标题单元格(即以1-6 #字符开头的单元格)在呈现后都是可折叠的。</p><p>标题的折叠/扩展状态存储在单元格元数据中，并在笔记本加载时重新加载。</p><p><img src="https://img2018.cnblogs.com/blog/1814900/201909/1814900-20190925214559004-2102669271.png" alt="img"></p><h3 id="Variableinspector（没添加"><a href="#Variableinspector（没添加" class="headerlink" title="Variableinspector（没添加"></a>Variableinspector（没添加</h3><p>Variableinspector（变量检查器）显示我们在Notebook中创建的所有变量的名称，以及它们的类型、大小、形状和值。如下图所示：</p><p><img src="https://pic3.zhimg.com/v2-afebf774b1d9e9869b78c218c57e319e_r.jpg" alt="img"></p><p>这个工具对于从RStudio迁移来的项目来说是非常宝贵的。或是当我们不想继续打印df.shape、无法回忆x的类型时，Variableinspector将变得非常有用。</p><p>如果有其他用到的插件会继续添加</p>]]></content>
    
    
    <summary type="html">记录一下自己用的插件，以免忘记</summary>
    
    
    
    
  </entry>
  
</feed>
