<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"changqingaas.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="《Go语言圣经》阅读笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go语言圣经》阅读笔记">
<meta property="og:url" content="https://changqingaas.github.io/%E4%B9%A6%E6%91%98/Go/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/index.html">
<meta property="og:site_name" content="常青的小屋">
<meta property="og:description" content="《Go语言圣经》阅读笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://docs.hacknode.org/gopl-zh/images/ch3-04.png">
<meta property="og:image" content="https://docs.hacknode.org/gopl-zh/images/ch4-01.png">
<meta property="og:image" content="https://docs.hacknode.org/gopl-zh/images/ch7-05.png">
<meta property="og:image" content="https://docs.hacknode.org/gopl-zh/images/ch8-01.png">
<meta property="og:image" content="https://docs.hacknode.org/gopl-zh/images/ch11-02.png">
<meta property="article:published_time" content="2022-05-10T14:00:33.000Z">
<meta property="article:modified_time" content="2022-10-24T02:57:36.000Z">
<meta property="article:author" content="常青">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://docs.hacknode.org/gopl-zh/images/ch3-04.png">


<link rel="canonical" href="https://changqingaas.github.io/%E4%B9%A6%E6%91%98/Go/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://changqingaas.github.io/%E4%B9%A6%E6%91%98/Go/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/","path":"书摘/Go/go语言圣经/","title":"《Go语言圣经》阅读笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《Go语言圣经》阅读笔记 | 常青的小屋</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="常青的小屋" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
     

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">常青的小屋</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">劫回落山的太阳</p>
     
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--个人简介-->
      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE"><span class="nav-text">Go语言项目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-text">入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C"><span class="nav-text">寻找重复的行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GIF%E5%8A%A8%E7%94%BB"><span class="nav-text">GIF动画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E8%8E%B7%E5%8F%96URL"><span class="nav-text">1.5. 获取URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6"><span class="nav-text">1.6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-Web%E6%9C%8D%E5%8A%A1"><span class="nav-text">1.8 Web服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E6%9C%AC%E7%AB%A0%E8%A6%81%E7%82%B9"><span class="nav-text">1.8 本章要点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">2.程序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%8F%98%E9%87%8F"><span class="nav-text">2.3 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%B5%8B%E5%80%BC"><span class="nav-text">2.4 赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7"><span class="nav-text">2.4.2. 可赋值性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.5 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-text">2.6. 包和文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">2.7 作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">第三章　基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%95%B4%E5%9E%8B"><span class="nav-text">3.1 整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">3.2 浮点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%A4%8D%E6%95%B0"><span class="nav-text">3.3 复数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="nav-text">3.4 布尔型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.5 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9D%A2%E5%80%BC"><span class="nav-text">3.5.1. 字符串面值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-Unicode"><span class="nav-text">3.5.2 Unicode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="nav-text">3.5. 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9D%A2%E5%80%BC-1"><span class="nav-text">3.5.1. 字符串面值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-Unicode-1"><span class="nav-text">3.5.2. Unicode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-UTF-8"><span class="nav-text">3.5.3. UTF-8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CByte%E5%88%87%E7%89%87"><span class="nav-text">3.5.4 字符串和Byte切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.5.5. 字符串和数字的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%B8%B8%E9%87%8F"><span class="nav-text">3.6 常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-iota-%E5%B8%B8%E9%87%8F%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">3.6.1 iota 常量生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-text">3.6.2. 无类型常量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">第四章　复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%95%B0%E7%BB%84"><span class="nav-text">4.1. 数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Slice"><span class="nav-text">4.2 Slice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-append%E5%87%BD%E6%95%B0"><span class="nav-text">4.2.1. append函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Map"><span class="nav-text">4.3. Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">4.4 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-text">4.4.1. 结构体字面值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83"><span class="nav-text">4.4.2. 结构体比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98"><span class="nav-text">4.4.3. 结构体嵌入和匿名成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-JSON"><span class="nav-text">4.5. JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E6%9D%BF"><span class="nav-text">4.6. 文本和HTML模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="nav-text">第五章　函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-text">5.1. 函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E9%80%92%E5%BD%92"><span class="nav-text">5.2. 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">5.3. 多返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E9%94%99%E8%AF%AF"><span class="nav-text">5.4. 错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-text">5.4.1. 错误处理策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE%E9%94%99%E8%AF%AF%EF%BC%88EOF%EF%BC%89"><span class="nav-text">5.4.2. 文件结尾错误（EOF）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%87%BD%E6%95%B0%E5%80%BC"><span class="nav-text">5.5. 函数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-text">5.6. 匿名函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1-%E8%AD%A6%E5%91%8A%EF%BC%9A%E6%8D%95%E8%8E%B7%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F"><span class="nav-text">5.6.1. 警告：捕获迭代变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-text">5.7. 可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-Deferred%E5%87%BD%E6%95%B0"><span class="nav-text">5.8. Deferred函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-Panic%E5%BC%82%E5%B8%B8"><span class="nav-text">5.9. Panic异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-Recover%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text">5.10. Recover捕获异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%96%B9%E6%B3%95"><span class="nav-text">第六章　方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E"><span class="nav-text">6.1. 方法声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">6.2. 基于指针对象的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-Nil%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%B3%95%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.2.1. Nil也是一个合法的接收器类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.3. 通过嵌入结构体来扩展类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E6%96%B9%E6%B3%95%E5%80%BC%E5%92%8C%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">6.4. 方法值和方法表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E7%A4%BA%E4%BE%8B-Bit%E6%95%B0%E7%BB%84"><span class="nav-text">6.5. 示例: Bit数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E5%B0%81%E8%A3%85"><span class="nav-text">6.6. 封装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="nav-text">第七章　接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A"><span class="nav-text">7.1. 接口约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.2 接口类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">7.3 实现接口的条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-flag-Value%E6%8E%A5%E5%8F%A3"><span class="nav-text">7.4. flag.Value接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-text">7.5. 接口值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-%E8%AD%A6%E5%91%8A%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AFnil%E6%8E%A5%E5%8F%A3"><span class="nav-text">7.5.1. 警告：一个包含nil指针的接口不是nil接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-sort-Interface%E6%8E%A5%E5%8F%A3"><span class="nav-text">7.6. sort.Interface接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-text">7.10. 类型断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-11-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.11. 基于类型断言区别错误类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-12-%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AF%A2%E9%97%AE%E8%A1%8C%E4%B8%BA"><span class="nav-text">7.12. 通过类型断言询问行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-13-%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF"><span class="nav-text">7.13. 类型分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#goto%E8%AF%AD%E5%8F%A5"><span class="nav-text">goto语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break%E8%AF%AD%E5%8F%A5"><span class="nav-text">break语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-15-%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="nav-text">7.15. 一些建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-Goroutines%E5%92%8CChannels"><span class="nav-text">第八章　Goroutines和Channels</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-Goroutines"><span class="nav-text">8.1. Goroutines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84Clock%E6%9C%8D%E5%8A%A1"><span class="nav-text">8.2. 示例: 并发的Clock服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84Echo%E6%9C%8D%E5%8A%A1"><span class="nav-text">8.3. 示例: 并发的Echo服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-Channels"><span class="nav-text">8.4. Channels</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84Channels"><span class="nav-text">8.4.1. 不带缓存的Channels</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-2-%E4%B8%B2%E8%81%94%E7%9A%84Channels%EF%BC%88Pipeline%EF%BC%89"><span class="nav-text">8.4.2. 串联的Channels（Pipeline）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-3-%E5%8D%95%E6%96%B9%E5%90%91%E7%9A%84Channel"><span class="nav-text">8.4.3. 单方向的Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-4-%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84Channels"><span class="nav-text">8.4.4. 带缓存的Channels</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-9-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA"><span class="nav-text">8.9. 并发的退出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="nav-text">第九章　基于共享变量的并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">9.1 竞态条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-sync-Mutex%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">9.2. sync.Mutex互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-sync-RWMutex%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-text">9.3. sync.RWMutex读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="nav-text">9.4. 内存同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-sync-Once%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">9.5. sync.Once惰性初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%B5%8B"><span class="nav-text">9.6. 竞争条件检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8-Goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-text">9.8. Goroutines和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-1-%E5%8A%A8%E6%80%81%E6%A0%88"><span class="nav-text">9.8.1. 动态栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-2-Goroutine%E8%B0%83%E5%BA%A6"><span class="nav-text">9.8.2. Goroutine调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-3-GOMAXPROCS"><span class="nav-text">9.8.3. GOMAXPROCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-4-Goroutine%E6%B2%A1%E6%9C%89ID%E5%8F%B7"><span class="nav-text">9.8.4. Goroutine没有ID号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E5%8C%85"><span class="nav-text">10 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E5%8C%85%E7%AE%80%E4%BB%8B"><span class="nav-text">10.1 包简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84"><span class="nav-text">10.2. 导入路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-%E5%8C%85%E5%A3%B0%E6%98%8E"><span class="nav-text">10.3. 包声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-%E5%AF%BC%E5%85%A5%E5%A3%B0%E6%98%8E"><span class="nav-text">10.4. 导入声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-%E5%8C%85%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5"><span class="nav-text">10.5. 包的匿名导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-%E5%8C%85%E5%92%8C%E5%91%BD%E5%90%8D"><span class="nav-text">10.6. 包和命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-7-%E5%B7%A5%E5%85%B7"><span class="nav-text">10.7. 工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-1-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="nav-text">10.7.1. 工作区结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-2-%E4%B8%8B%E8%BD%BD%E5%8C%85"><span class="nav-text">10.7.2. 下载包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-3-%E6%9E%84%E5%BB%BA%E5%8C%85"><span class="nav-text">10.7.3. 构建包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-4-%E5%8C%85%E6%96%87%E6%A1%A3"><span class="nav-text">10.7.4. 包文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-5-%E5%86%85%E9%83%A8%E5%8C%85"><span class="nav-text">10.7.5. 内部包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-6-%E6%9F%A5%E8%AF%A2%E5%8C%85"><span class="nav-text">10.7.6. 查询包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%B5%8B%E8%AF%95"><span class="nav-text">第十一章　测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-go-test"><span class="nav-text">11.1 go test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-text">11.2 测试函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95"><span class="nav-text">11.2.1. 随机测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="nav-text">11.2.2. 测试一个命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="nav-text">11.2.3. 白盒测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-4-%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95%E5%8C%85"><span class="nav-text">11.2.4. 外部测试包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-5-%E7%BC%96%E5%86%99%E6%9C%89%E6%95%88%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">11.2.5. 编写有效的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-6-%E9%81%BF%E5%85%8D%E8%84%86%E5%BC%B1%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">11.2.6. 避免脆弱的测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-text">11.3. 测试覆盖率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-text">11.4. 基准测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-%E5%89%96%E6%9E%90"><span class="nav-text">11.5. 剖析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8F%8D%E5%B0%84"><span class="nav-text">第十二章　反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84"><span class="nav-text">12.1. 为何需要反射?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-reflect-Type%E5%92%8Creflect-Value"><span class="nav-text">12.2. reflect.Type和reflect.Value</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%BA%95%E5%B1%82%E7%BC%96%E7%A8%8B"><span class="nav-text">第十三章　底层编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-unsafe-Sizeof-Alignof-%E5%92%8C-Offsetof"><span class="nav-text">13.1. unsafe.Sizeof, Alignof 和 Offsetof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-%E9%80%9A%E8%BF%87cgo%E8%B0%83%E7%94%A8C%E4%BB%A3%E7%A0%81"><span class="nav-text">13.4. 通过cgo调用C代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-%E5%87%A0%E7%82%B9%E5%BF%A0%E5%91%8A"><span class="nav-text">13.5. 几点忠告</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->
      <!--/个人简介-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="常青"
      src="/images/1.jpeg">
  <p class="site-author-name" itemprop="name">常青</p>
  <div class="site-description" itemprop="description">行则将至</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ChangQingAAS" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChangQingAAS" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wanghongyang@tju.edu.cn" title="E-Mail → mailto:wanghongyang@tju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title">
      
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://aidn.jp/mikutap/" title="https:&#x2F;&#x2F;aidn.jp&#x2F;mikutap&#x2F;" rel="noopener" target="_blank">解压玩具</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://thispersondoesnotexist.com/" title="https:&#x2F;&#x2F;thispersondoesnotexist.com&#x2F;" rel="noopener" target="_blank">他者凝视</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://thisartworkdoesnotexist.com/" title="https:&#x2F;&#x2F;thisartworkdoesnotexist.com&#x2F;" rel="noopener" target="_blank">网络抽象</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jiuge.thunlp.org/index.html" title="http:&#x2F;&#x2F;jiuge.thunlp.org&#x2F;index.html" rel="noopener" target="_blank">读诗远足</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1333904985&height=66&autostart="false"></iframe>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://changqingaas.github.io/%E4%B9%A6%E6%91%98/Go/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpeg">
      <meta itemprop="name" content="常青">
      <meta itemprop="description" content="行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="常青的小屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Go语言圣经》阅读笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-10 22:00:33" itemprop="dateCreated datePublished" datetime="2022-05-10T22:00:33+08:00">2022-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-10-24 10:57:36" itemprop="dateModified" datetime="2022-10-24T10:57:36+08:00">2022-10-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A6%E6%91%98/" itemprop="url" rel="index"><span itemprop="name">书摘</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>92k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:24</span>
    </span>
</div>

            <div class="post-description">《Go语言圣经》阅读笔记</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了解决在21世纪多核和网络化环境下越来越复杂的编程问题而发明了Go语言</p>
<p>纵观这几年来的发展趋势，Go语言已经成为云计算、云存储时代最重要的基础编程语言。</p>
<p>Go语言中和并发编程相关的特性是全新的也是有效的，同时对数据抽象和面向对象编程的支持也很灵活。 Go语言同时还集成了自动垃圾收集技术用于更好地管理内存。</p>
<p>Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。 但是Go语言确实是一个通用的编程语言，它也可以用在图形图像驱动编程、移动应用程序开发 和机器学习等诸多领域。目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。</p>
<h2 id="Go语言项目"><a href="#Go语言项目" class="headerlink" title="Go语言项目"></a>Go语言项目</h2><p>正如<a target="_blank" rel="noopener" href="http://genius.cat-v.org/rob-pike/">Rob Pike</a>所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。</p>
<p>Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。</p>
<p>Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。</p>
<p>由于现代计算机是一个并行的机器，Go语言提供了基于CSP（顺序通信进程）的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>Go语言的代码通过<strong>包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条<code>package</code>声明语句开始，这个例子里就是<code>package main</code>, 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p>Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如<code>fmt</code>包，就含有格式化输出、接收输入的函数。<code>Println</code>是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。</p>
<p><code>main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在<code>main</code>里的<code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。</p>
<p>必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go语言编译过程没有警告信息，争议特性之一）。</p>
<p>Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字<code>break</code>、<code>continue</code>、<code>fallthrough</code>或<code>return</code>中的一个、运算符和分隔符<code>++</code>、<code>--</code>、<code>)</code>、<code>]</code>或<code>&#125;</code>中的一个）举个例子, 函数的左括号<code>&#123;</code>必须和<code>func</code>函数声明在同一行上, 且位于末尾，不能独占一行，而在表达式<code>x + y</code>中，可在<code>+</code>后换行，不能在<code>+</code>前换行（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）</p>
<p>Go语言在代码格式上采取了很强硬的态度。<code>gofmt</code>工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且<code>go</code>工具中的<code>fmt</code>子命令会对指定包, 否则默认为当前目录, 中所有.go源文件应用<code>gofmt</code>命令。 这样可以做多种自动源码转换，</p>
<p>很多文本编辑器都可以配置为保存文件时自动执行<code>gofmt</code>，这样你的源代码总会被恰当地格式化。还有个相关的工具，<code>goimports</code>，可以根据代码需要, 自动地添加或删除<code>import</code>声明。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    var s, sep string
    for i :&#x3D; 1; i &lt; len(os.Args); i++ &#123;
        s +&#x3D; sep + os.Args[i]
        sep &#x3D; &quot; &quot;
    &#125;
    fmt.Println(s)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果变量没有显式初始化，则被隐式地赋予其类型的<em>零值</em>（zero value），数值类型是0，字符串类型是空字符串””。这个例子里，声明把s和sep隐式地初始化成空字符串。</p>
<p>++和—都只能放在变量名后面，因此<code>--i</code>非法</p>
<p>Go语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">for initialization; condition; post &#123;
    &#x2F;&#x2F; zero or more statements
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><em>initialization</em>语句是可选的，在循环开始前执行。<em>initalization</em>如果存在，必须是一条<em>简单语句</em>（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。<code>condition</code>是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为<code>true</code>则执行循环体语句。<code>post</code>语句在循环体执行结束后执行，之后再次对<code>condition</code>求值。<code>condition</code>值为<code>false</code>时，循环结束。</p>
<p>for循环的这三个部分每个都可以省略，如果省略<code>initialization</code>和<code>post</code>，分号也可以省略：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; a traditional &quot;while&quot; loop
for condition &#123;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果连<code>condition</code>也省略了，像下面这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; a traditional infinite loop
for &#123;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条<code>break</code>或<code>return</code>语句。</p>
<p><code>for</code>循环的另一种形式, 在某种数据类型的区间（range）上遍历，如字符串或切片。<code>echo</code>的第二版本展示了这种形式：</p>
<p><em>gopl.io/ch1/echo2</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Echo2 prints its command-line arguments.
package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    s, sep :&#x3D; &quot;&quot;, &quot;&quot;
    for _, arg :&#x3D; range os.Args[1:] &#123;
        s +&#x3D; sep + arg
        sep &#x3D; &quot; &quot;
    &#125;
    fmt.Println(s)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每次循环迭代，<code>range</code>产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但<code>range</code>的语法要求, 要处理元素, 必须处理索引。一种思路是把索引赋值给一个临时变量, 如<code>temp</code>, 然后忽略它的值，但Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。Go语言中这种情况的解决方法是用<code>空标识符</code>（blank identifier），即<code>_</code>（也就是下划线）。</p>
<p>声明一个变量有好几种方式，下面这些都等价：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s :&#x3D; &quot;&quot;
var s string
var s &#x3D; &quot;&quot;
var s string &#x3D; &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为””。第三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余, 但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p>
<p>如前文所述，每次循环迭代字符串s的内容都会更新。<code>+=</code>连接原字符串、空格和下个参数，产生新字符串, 并把它赋值给<code>s</code>。<code>s</code>原来的内容已经不再使用，将在适当时机对它进行垃圾回收。</p>
<p>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用<code>strings</code>包的<code>Join</code>函数：</p>
<p><em>gopl.io/ch1/echo3</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    fmt.Println(strings.Join(os.Args[1:], &quot; &quot;))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用<code>Println</code>为我们格式化输出。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(os.Args[1:])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这条语句的输出结果跟<code>strings.Join</code>得到的结果很像，只是被放到了一对方括号里。切片都会被打印成这种格式。</p>
<h2 id="寻找重复的行"><a href="#寻找重复的行" class="headerlink" title="寻找重复的行"></a>寻找重复的行</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() &#123;
	counts :&#x3D; make(map[string]int)
	input :&#x3D; bufio.NewScanner(os.Stdin)
	for input.Scan() &#123;
        line :&#x3D; input.Text()
		counts[line]++
	&#125;
	for line, n :&#x3D; range counts &#123;
		if n &gt; 1 &#123;
			fmt.Println(&quot;%d\t%s\t&quot;, n, line)
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了打印结果，我们使用了基于<code>range</code>的循环，并在<code>counts</code>这个<code>map</code>上迭代。跟之前类似，每次迭代得到两个结果，键和其在<code>map</code>中对应的值。<code>map</code>的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化。这种设计是有意为之的，因为能防止程序依赖特定遍历顺序，而这是无法保证的。</p>
<p>继续来看<code>bufio</code>包，它使处理输入和输出方便又高效。<code>Scanner</code>类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。</p>
<p>程序使用短变量声明创建<code>bufio.Scanner</code>类型的变量<code>input</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">input :&#x3D; bufio.NewScanner(os.Stdin)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该变量从程序的标准输入中读取内容。每次调用<code>input.Scan()</code>，即读入下一行，并移除行末的换行符；读取的内容可以调用<code>input.Text()</code>得到。<code>Scan</code>函数在读到一行时返回<code>true</code>，不再有输入时返回<code>false</code>。</p>
<p>多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。<code>dup</code>程序的下个版本读取标准输入或是使用<code>os.Open</code>打开各个具名文件，并操作它们。</p>
<p><em>gopl.io/ch1/dup2</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Dup2 prints the count and text of lines that appear more than once
&#x2F;&#x2F; in the input.  It reads from stdin or from a list of named files.
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    counts :&#x3D; make(map[string]int)
    files :&#x3D; os.Args[1:]
    if len(files) &#x3D;&#x3D; 0 &#123;
        countLines(os.Stdin, counts)
    &#125; else &#123;
        for _, arg :&#x3D; range files &#123;
            f, err :&#x3D; os.Open(arg)
            if err !&#x3D; nil &#123;
                fmt.Fprintf(os.Stderr, &quot;dup2: %v\n&quot;, err)
                continue
            &#125;
            countLines(f, counts)
            f.Close()
        &#125;
    &#125;
    for line, n :&#x3D; range counts &#123;
        if n &gt; 1 &#123;
            fmt.Printf(&quot;%d\t%s\n&quot;, n, line)
        &#125;
    &#125;
&#125;

func countLines(f *os.File, counts map[string]int) &#123;
    input :&#x3D; bufio.NewScanner(f)
    for input.Scan() &#123;
        counts[input.Text()]++
    &#125;
    &#x2F;&#x2F; NOTE: ignoring potential errors from input.Err()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。（译注：最好还是遵循一定的规范）</p>
<p><code>dup</code>的前两个版本以”流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。</p>
<p>这个例子引入了<code>ReadFile</code>函数（来自于<code>io/ioutil</code>包），其读取指定文件的全部内容，<code>strings.Split</code>函数把字符串分割成子串的切片。（<code>Split</code>的作用与前文提到的<code>strings.Join</code>相反。）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;io&#x2F;ioutil&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func main() &#123;
    counts :&#x3D; make(map[string]int)
    for _, filename :&#x3D; range os.Args[1:] &#123;
        data, err :&#x3D; ioutil.ReadFile(filename)
        if err !&#x3D; nil &#123;
            fmt.Fprintf(os.Stderr, &quot;dup3: %v\n&quot;, err)
            continue
        &#125;
        for _, line :&#x3D; range strings.Split(string(data), &quot;\n&quot;) &#123;
            counts[line]++
        &#125;
    &#125;
    for line, n :&#x3D; range counts &#123;
        if n &gt; 1 &#123;
            fmt.Printf(&quot;%d\t%s\n&quot;, n, line)
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ReadFile</code>函数返回一个字节切片（byte slice），必须把它转换为<code>string</code>，才能用<code>strings.Split</code>分割。</p>
<p>实现上，<code>bufio.Scanner</code>、<code>ioutil.ReadFile</code>和<code>ioutil.WriteFile</code>都使用<code>*os.File</code>的<code>Read</code>和<code>Write</code>方法，但是，大多数程序员很少需要直接调用那些低级（lower-level）函数。高级（higher-level）函数，像<code>bufio</code>和<code>io/ioutil</code>包中所提供的那些，用起来要容易点。</p>
<h2 id="GIF动画"><a href="#GIF动画" class="headerlink" title="GIF动画"></a>GIF动画</h2><p>当我们import了一个包路径包含有多个单词的package时，比如image/color（image和color两个单词），通常我们只需要用最后那个单词表示这个包就可以。所以当我们写color.White时，这个变量指向的是image/color包里的变量 </p>
<p>这个程序里的常量声明给出了一系列的常量值，常量是指在程序编译后运行时始终都不会变化的值，比如圈数、帧数、延迟值。常量声明和变量声明一般都会出现在包级别，所以这些常量在整个包中都是可以共享的，或者你也可以把常量声明定义在函数体内部，那么这种常量就只能在函数体内用。</p>
<h2 id="1-5-获取URL"><a href="#1-5-获取URL" class="headerlink" title="1.5. 获取URL"></a>1.5. 获取URL</h2><p>Go语言在net这个强大package的帮助下提供了一系列的package来做这件事情，使用这些包可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。在这些情景下，Go语言原生的并发特性（在第八章中会介绍）显得尤其好用。</p>
<h2 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;io&#x2F;ioutil&quot;
    &quot;net&#x2F;http&quot;
    &quot;os&quot;
    &quot;time&quot;
)

func main() &#123;
    start :&#x3D; time.Now()
    ch :&#x3D; make(chan string)
    for _, url :&#x3D; range os.Args[1:] &#123;
        go fetch(url, ch) &#x2F;&#x2F; start a goroutine
    &#125;
    for range os.Args[1:] &#123;
        fmt.Println(&lt;-ch) &#x2F;&#x2F; receive from channel ch
    &#125;
    fmt.Printf(&quot;%.2fs elapsed\n&quot;, time.Since(start).Seconds())
&#125;

func fetch(url string, ch chan&lt;- string) &#123;
    start :&#x3D; time.Now()
    resp, err :&#x3D; http.Get(url)
    if err !&#x3D; nil &#123;
        ch &lt;- fmt.Sprint(err) &#x2F;&#x2F; send to channel ch
        return
    &#125;
    nbytes, err :&#x3D; io.Copy(ioutil.Discard, resp.Body)
    resp.Body.Close() &#x2F;&#x2F; don&#39;t leak resources
    if err !&#x3D; nil &#123;
        ch &lt;- fmt.Sprintf(&quot;while reading %s: %v&quot;, url, err)
        return
    &#125;
    secs :&#x3D; time.Since(start).Seconds()
    ch &lt;- fmt.Sprintf(&quot;%.2fs  %7d  %s&quot;, secs, nbytes, url)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。</p>
<p>当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine从这个channel里接收或者写入值，这样两个goroutine才会继续执行channel操作之后的逻辑。在这个例子中，每一个fetch函数在执行时都会往channel里发送一个值(ch &lt;- expression)，主函数负责接收这些值(&lt;-ch)。这个程序中我们用main函数来接收所有fetch函数传回的字符串，可以避免在goroutine异步执行还没有完成时main函数提前退出。</p>
<h2 id="1-8-Web服务"><a href="#1-8-Web服务" class="headerlink" title="1.8 Web服务"></a>1.8 Web服务</h2><p>o语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a target="_blank" rel="noopener" href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是URL.Path = “hello”。</p>
<p><em>gopl.io/ch1/server1</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Server1 is a minimal &quot;echo&quot; server.
package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&#x2F;http&quot;
)

func main() &#123;
    http.HandleFunc(&quot;&#x2F;&quot;, handler) &#x2F;&#x2F; each request calls handler
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
&#125;

&#x2F;&#x2F; handler echoes the Path component of the request URL r.
func handler(w http.ResponseWriter, r *http.Request) &#123;
    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, r.URL.Path)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们只用了八九行代码就实现了一个Web服务程序，这都是多亏了标准库里的方法已经帮我们完成了大量工作。main函数将所有发送到/路径下的请求和handler函数关联起来，/开头的请求其实就是所有发送到当前站点上的请求，服务监听8000端口。发送到这个服务的“请求”是一个http.Request类型的对象，这个对象中包含了请求中的一系列相关字段，其中就包括我们需要的URL。当请求到达服务器时，这个请求会被传给handler函数来处理，这个函数会将/hello这个路径从请求的URL中解析出来，然后把其发送到响应中，这里我们用的是标准输出流的fmt.Fprintf。Web服务会在第7.7节中做更详细的阐述。</p>
<p>让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。</p>
<pre class="line-numbers language-none"><code class="language-none">$ go run src&#x2F;gopl.io&#x2F;ch1&#x2F;server1&#x2F;main.go &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在可以通过命令行来发送客户端请求了：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000
URL.Path &#x3D; &quot;&#x2F;&quot;
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;help
URL.Path &#x3D; &quot;&#x2F;help&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以直接在浏览器里访问这个URL，然后得到返回结果</p>
<p>在这个服务的基础上叠加特性是很容易的。一种比较实用的修改是为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算；对URL的请求结果会包含各种URL被访问的总次数，直接对/count这个URL的访问要除外。</p>
<p><em>gopl.io/ch1/server2</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Server2 is a minimal &quot;echo&quot; and counter server.
package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&#x2F;http&quot;
    &quot;sync&quot;
)

var mu sync.Mutex
var count int

func main() &#123;
    http.HandleFunc(&quot;&#x2F;&quot;, handler)
    http.HandleFunc(&quot;&#x2F;count&quot;, counter)
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
&#125;

&#x2F;&#x2F; handler echoes the Path component of the requested URL.
func handler(w http.ResponseWriter, r *http.Request) &#123;
    mu.Lock()
    count++
    mu.Unlock()
    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, r.URL.Path)
&#125;

&#x2F;&#x2F; counter echoes the number of calls so far.
func counter(w http.ResponseWriter, r *http.Request) &#123;
    mu.Lock()
    fmt.Fprintf(w, &quot;Count %d\n&quot;, count)
    mu.Unlock()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个服务器有两个请求处理函数，根据请求的url不同会调用不同的函数：对/count这个url的请求会调用到counter这个函数，其它的url都会调用默认的处理函数。如果你的请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。在这些代码的背后，服务器每一次接收请求处理时都会另起一个goroutine，这样服务器就可以同一时间处理多个请求。然而在并发情况下，假如真的有两个请求同一时刻去更新count，那么这个值可能并不会被正确地增加；这个程序可能会引发一个严重的bug：竞态条件（参见9.1）。为了避免这个问题，我们必须保证每次修改变量的最多只能有一个goroutine，这也就是代码里的mu.Lock()和mu.Unlock()调用将修改count的所有行为包在中间的目的。第九章中我们会进一步讲解共享变量。</p>
<p>Go语言的接口机制会在第7章中讲解，为了在这里简单说明接口能做什么，让我们简单地将这里的web服务器和之前写的lissajous函数结合起来，这样GIF动画可以被写到HTTP的客户端，而不是之前的标准输出流。只要在web服务器的代码里加入下面这几行。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">handler :&#x3D; func(w http.ResponseWriter, r *http.Request) &#123;
    lissajous(w)
&#125;
http.HandleFunc(&quot;&#x2F;&quot;, handler)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者另一种等价形式：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">http.HandleFunc(&quot;&#x2F;&quot;, func(w http.ResponseWriter, r *http.Request) &#123;
    lissajous(w)
&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="1-8-本章要点"><a href="#1-8-本章要点" class="headerlink" title="1.8 本章要点"></a>1.8 本章要点</h2><p>Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。</p>
<p><strong>指针：</strong> Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，&amp;操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。</p>
<p><strong>方法和接口：</strong> 方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。在第六章我们会详细地讲方法。接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。第七章中会详细说明这些内容。</p>
<h1 id="2-程序结构"><a href="#2-程序结构" class="headerlink" title="2.程序结构"></a>2.程序结构</h1><h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>
<p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>
<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var global *int

func f() &#123;
    var x int
    x &#x3D; 1
    global &#x3D; &amp;x
&#125;

func g() &#123;
    y :&#x3D; new(int)
    *y &#x3D; 1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，<strong>这个x局部变量从函数f中逃逸了</strong>。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，<code>逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响</code>。</p>
<p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p>
<h2 id="2-4-赋值"><a href="#2-4-赋值" class="headerlink" title="2.4 赋值"></a>2.4 赋值</h2><p>在稍后我们将看到的三个操作都是类似的用法。如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup
v, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion
v, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>译注：map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值
v &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常
v &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）

_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值
_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值
_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-4-2-可赋值性"><a href="#2-4-2-可赋值性" class="headerlink" title="2.4.2. 可赋值性"></a>2.4.2. 可赋值性</h3><p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p>
<p>可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p>
<p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，</p>
<h2 id="2-5-类型"><a href="#2-5-类型" class="headerlink" title="2.5 类型"></a>2.5 类型</h2><p><em>gopl.io/ch2/tempconv0</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import &quot;fmt&quot;

type Celsius float64    &#x2F;&#x2F; 摄氏温度
type Fahrenheit float64 &#x2F;&#x2F; 华氏温度

const (
    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度
    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度
    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度
)

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;

func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；<strong>因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型</strong>。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p>
<p><strong>对于每一个类型T，都有一个对应的类型转换操作T(x)*</strong>，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。<strong>只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身</strong>。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。</p>
<p>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，在下一章我们会看到这样的例子。这类转换可能改变值的表现。例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为<code>[]byte</code>类型的slice将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（译注: <strong>错误只会发生在编译阶段*</strong>）。</p>
<p>比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var c Celsius
var f Fahrenheit
fmt.Println(c &#x3D;&#x3D; 0)          &#x2F;&#x2F; &quot;true&quot;
fmt.Println(f &gt;&#x3D; 0)          &#x2F;&#x2F; &quot;true&quot;
fmt.Println(c &#x3D;&#x3D; f)          &#x2F;&#x2F; compile error: type mismatch
fmt.Println(c &#x3D;&#x3D; Celsius(f)) &#x2F;&#x2F; &quot;true&quot;!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印，我们将在7.1节讲述。</p>
<h2 id="2-6-包和文件"><a href="#2-6-包和文件" class="headerlink" title="2.6. 包和文件"></a>2.6. 包和文件</h2><p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；</p>
<p>每个包都对应一个独立的名字空间。</p>
<p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>
<p>在每个源文件的包声明前紧跟着的注释是包注释（§10.7.4）。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。</p>
<p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</p>
<p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了</p>
<h2 id="2-7-作用域"><a href="#2-7-作用域" class="headerlink" title="2.7 作用域"></a>2.7 作用域</h2><p>个人认为，只要代码不重名名就不用考虑这些问题</p>
<h1 id="第三章-基础数据类型"><a href="#第三章-基础数据类型" class="headerlink" title="第三章　基础数据类型"></a>第三章　基础数据类型</h1><p>虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。</p>
<h2 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h2><p>Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p>
<p>这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型</p>
<p>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>
<p>还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</p>
<p>不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。</p>
<p>在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此<code>-5%3</code>和<code>-5%-3</code>结果都是-2。除法运算符<code>/</code>的行为则依赖于操作数是否全为整数，比如<code>5.0/4.0</code>的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。</p>
<p>对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型。许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">f :&#x3D; 3.141 &#x2F;&#x2F; a float64
i :&#x3D; int(f)
fmt.Println(f, i) &#x2F;&#x2F; &quot;3.141 3&quot;
f &#x3D; 1.99
fmt.Println(int(f)) &#x2F;&#x2F; &quot;1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h2><h2 id="3-3-复数"><a href="#3-3-复数" class="headerlink" title="3.3 复数"></a>3.3 复数</h2><h2 id="3-4-布尔型"><a href="#3-4-布尔型" class="headerlink" title="3.4 布尔型"></a>3.4 布尔型</h2><h2 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h2><p>一个字符串是一个不可改变的字节序列。</p>
<p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。</p>
<h3 id="3-5-1-字符串面值"><a href="#3-5-1-字符串面值" class="headerlink" title="3.5.1. 字符串面值"></a>3.5.1. 字符串面值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">const GoUsage &#x3D; &#96;Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-5-2-Unicode"><a href="#3-5-2-Unicode" class="headerlink" title="3.5.2 Unicode"></a>3.5.2 Unicode</h3><p>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思。 </p>
<h2 id="3-5-字符串-1"><a href="#3-5-字符串-1" class="headerlink" title="3.5. 字符串"></a>3.5. 字符串</h2><p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列，我们稍后会详细讨论这个问题。</p>
<p>内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i&lt; len(s)条件约束。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s :&#x3D; &quot;hello, world&quot;
fmt.Println(len(s))     &#x2F;&#x2F; &quot;12&quot;
fmt.Println(s[0], s[7]) &#x2F;&#x2F; &quot;104 119&quot; (&#39;h&#39; and &#39;w&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果试图访问超出字符串索引范围的字节将会导致panic异常：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">c :&#x3D; s[len(s)] &#x2F;&#x2F; panic: index out of range<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。我们先简单说下字符的工作方式。</p>
<p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(s[0:5]) &#x2F;&#x2F; &quot;hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同样，如果索引超出字符串范围或者j小于i的话将导致panic异常。</p>
<p>不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(s[:5]) &#x2F;&#x2F; &quot;hello&quot;
fmt.Println(s[7:]) &#x2F;&#x2F; &quot;world&quot;
fmt.Println(s[:])  &#x2F;&#x2F; &quot;hello, world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中+操作符将两个字符串连接构造一个新字符串：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(&quot;goodbye&quot; + s[5:]) &#x2F;&#x2F; &quot;goodbye, world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>字符串可以用==和&lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。</p>
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s :&#x3D; &quot;left foot&quot;
t :&#x3D; s
s +&#x3D; &quot;, right foot&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这并不会导致原始的字符串值被改变，但是变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(s) &#x2F;&#x2F; &quot;left foot, right foot&quot;
fmt.Println(t) &#x2F;&#x2F; &quot;left foot&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s[0] &#x3D; &#39;L&#39; &#x2F;&#x2F; compile error: cannot assign to s[0]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。 图3.4演示了一个字符串和两个子串共享相同的底层数据。</p>
<h3 id="3-5-1-字符串面值-1"><a href="#3-5-1-字符串面值-1" class="headerlink" title="3.5.1. 字符串面值"></a>3.5.1. 字符串面值</h3><p>字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可：</p>
<pre class="line-numbers language-none"><code class="language-none">&quot;Hello, 世界&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://docs.hacknode.org/gopl-zh/images/ch3-04.png" alt="img"></p>
<p>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。</p>
<p>在一个双引号包含的字符串面值中，可以用以反斜杠<code>\</code>开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：</p>
<pre class="line-numbers language-none"><code class="language-none">\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\&#39;      单引号 (只用在 &#39;\&#39;&#39; 形式的rune符号面值中)
\&quot;      双引号 (只用在 &quot;...&quot; 形式的字符串面值中)
\\      反斜杠<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以通过十六进制或八进制转义在字符串面值中包含任意的字节。一个十六进制的转义形式是<code>\xhh</code>，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是<code>\ooo</code>，包含三个八进制的o数字（0到7），但是不能超过<code>\377</code>（译注：对应一个字节的范围，十进制为255）。每一个单一的字节表达一个特定的值。稍后我们将看到如何将一个Unicode码点写到字符串面值中。</p>
<p>一个原生的字符串面值形式是<code>...</code>，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写<code>字符的，可以用八进制或十六进制转义或+&quot;</code>“连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。</p>
<p>原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const GoUsage &#x3D; &#96;Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-5-2-Unicode-1"><a href="#3-5-2-Unicode-1" class="headerlink" title="3.5.2. Unicode"></a>3.5.2. Unicode</h3><p>在很久以前，世界还是比较简单的，起码计算机世界就只有一个ASCII字符集：美国信息交换标准代码。ASCII，更准确地说是美国的ASCII，使用7bit来表示128个字符：包含英文字母的大小写、数字、各种标点符号和设备控制符。对于早期的计算机程序来说，这些就足够了，但是这也导致了世界上很多其他地区的用户无法直接使用自己的符号系统。随着互联网的发展，混合多种语言的数据变得很常见（译注：比如本身的英文原文或中文翻译都包含了ASCII、中文、日文等多种语言字符）。如何有效处理这些包含了各种语言的丰富多样的文本数据呢？</p>
<p>答案就是使用Unicode（ <a target="_blank" rel="noopener" href="http://unicode.org/">http://unicode.org</a> ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。</p>
<p>在第八版本的Unicode标准里收集了超过120,000个字符，涵盖超过100多种语言。这些在计算机程序和数据中是如何体现的呢？通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思。</p>
<p>我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样大小的32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间，因为大多数计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节就能表示。而且即使是常用的字符也远少于65,536个，也就是说用16bit编码方式就能表达常用字符。但是，还有其它更好的编码方法吗？</p>
<h3 id="3-5-3-UTF-8"><a href="#3-5-3-UTF-8" class="headerlink" title="3.5.3. UTF-8"></a>3.5.3. UTF-8</h3><p>UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，，现在已经是Unicode的标准。</p>
<p>FIXME：这部分讲了一些UTF-8的相关知识，但是我没记。</p>
<h3 id="3-5-4-字符串和Byte切片"><a href="#3-5-4-字符串和Byte切片" class="headerlink" title="3.5.4 字符串和Byte切片"></a>3.5.4 字符串和Byte切片</h3><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
<p>因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效</p>
<p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>
<h3 id="3-5-5-字符串和数字的转换"><a href="#3-5-5-字符串和数字的转换" class="headerlink" title="3.5.5. 字符串和数字的转换"></a>3.5.5. 字符串和数字的转换</h3><p>将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x :&#x3D; 123
y :&#x3D; fmt.Sprintf(&quot;%d&quot;, x)
fmt.Println(y, strconv.Itoa(x)) &#x2F;&#x2F; &quot;123 123&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>FormatInt和FormatUint函数可以用不同的进制来格式化数字：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(strconv.FormatInt(int64(x), 2)) &#x2F;&#x2F; &quot;1111011&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x, err :&#x3D; strconv.Atoi(&quot;123&quot;)             &#x2F;&#x2F; x is an int
y, err :&#x3D; strconv.ParseInt(&quot;123&quot;, 10, 64) &#x2F;&#x2F; base 10, up to 64 bits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。</p>
<p>有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。</p>
<h2 id="3-6-常量"><a href="#3-6-常量" class="headerlink" title="3.6 常量"></a>3.6 常量</h2><p>所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量</p>
<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const (
    a &#x3D; 1
    b
    c &#x3D; 2
    d
)

fmt.Println(a, b, c, d) &#x2F;&#x2F; &quot;1 1 2 2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是iota常量生成器语法。</p>
<h3 id="3-6-1-iota-常量生成器"><a href="#3-6-1-iota-常量生成器" class="headerlink" title="3.6.1 iota 常量生成器"></a>3.6.1 iota 常量生成器</h3><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p>
<p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Weekday int

const (
    Sunday Weekday &#x3D; iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>周日将对应0，周一为1，如此等等。</p>
<p>我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Flags uint

const (
    FlagUp Flags &#x3D; 1 &lt;&lt; iota &#x2F;&#x2F; is up
    FlagBroadcast            &#x2F;&#x2F; supports broadcast access capability
    FlagLoopback             &#x2F;&#x2F; is a loopback interface
    FlagPointToPoint         &#x2F;&#x2F; belongs to a point-to-point link
    FlagMulticast            &#x2F;&#x2F; supports multicast access capability
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>随着iota的递增，每个常量对应表达式1 &lt;&lt; iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值 </p>
<p><em>Go语言并没有计算幂的运算符。</em></p>
<h3 id="3-6-2-无类型常量"><a href="#3-6-2-无类型常量" class="headerlink" title="3.6.2. 无类型常量"></a>3.6.2. 无类型常量</h3><p>另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var x float32 &#x3D; math.Pi
var y float64 &#x3D; math.Pi
var z complex128 &#x3D; math.Pi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换 </p>
<p>对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var f float64 &#x3D; 3 + 0i &#x2F;&#x2F; untyped complex -&gt; float64
f &#x3D; 2                  &#x2F;&#x2F; untyped integer -&gt; float64
f &#x3D; 1e123              &#x2F;&#x2F; untyped floating-point -&gt; float64
f &#x3D; &#39;a&#39;                &#x2F;&#x2F; untyped rune -&gt; float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的语句相当于:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var f float64 &#x3D; float64(3 + 0i)
f &#x3D; float64(2)
f &#x3D; float64(1e123)
f &#x3D; float64(&#39;a&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">i :&#x3D; 0      &#x2F;&#x2F; untyped integer;        implicit int(0)
r :&#x3D; &#39;\000&#39; &#x2F;&#x2F; untyped rune;           implicit rune(&#39;\000&#39;)
f :&#x3D; 0.0    &#x2F;&#x2F; untyped floating-point; implicit float64(0.0)
c :&#x3D; 0i     &#x2F;&#x2F; untyped complex;        implicit complex128(0i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。</p>
<h1 id="第四章-复合数据类型"><a href="#第四章-复合数据类型" class="headerlink" title="第四章　复合数据类型"></a>第四章　复合数据类型</h1><p>数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。</p>
<h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1. 数组"></a>4.1. 数组</h2><p>因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列</p>
<p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">q :&#x3D; [...]int&#123;1, 2, 3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。</p>
<p>虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。</p>
<h2 id="4-2-Slice"><a href="#4-2-Slice" class="headerlink" title="4.2 Slice"></a>4.2 Slice</h2><p>一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p>
<p><img src="https://docs.hacknode.org/gopl-zh/images/ch4-01.png" alt="img"></p>
<p>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大：</p>
<p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名（§2.3.2）。</p>
<p>要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。</p>
<p>为何slice不直接支持比较运算符呢？这方面有两个原因。第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身。虽然有很多办法处理这种情形，但是没有一个是简单有效的。</p>
<p>第二个原因，因为slice的元素是间接引用的，一个固定的slice值(译注：指slice本身的值，不是元素的值)在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。而例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性(译注：例如slice扩容，就会导致其本身的值/地址变化)。而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，== 相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的==操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。</p>
<p>slice唯一合法的比较操作是和nil比较，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if summer &#x3D;&#x3D; nil &#123; &#x2F;* ... *&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样；例如reverse(nil)也是安全的。</p>
<p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">make([]T, len)
make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。</p>
<h3 id="4-2-1-append函数"><a href="#4-2-1-append函数" class="headerlink" title="4.2.1. append函数"></a>4.2.1. append函数</h3><p>内置的append函数用于向slice追加元素：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var runes []rune
for _, r :&#x3D; range &quot;Hello, 世界&quot; &#123;
    runes &#x3D; append(runes, r)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。</p>
<p>slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type IntSlice struct &#123;
    ptr      *int
    len, cap int
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="4-3-Map"><a href="#4-3-Map" class="headerlink" title="4.3. Map"></a>4.3. Map</h2><p>它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p>
<p>其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法</p>
<p>如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ages[&quot;bob&quot;] &#x3D; ages[&quot;bob&quot;] + 1 &#x2F;&#x2F; happy birthday!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>
<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。下面是常见的处理方式：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import &quot;sort&quot;

var names []string
for name :&#x3D; range ages &#123;
    names &#x3D; append(names, name)
&#125;
sort.Strings(names)
for _, name :&#x3D; range names &#123;
    fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name])
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>map类型的零值是nil，也就是没有引用任何哈希表。map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var ages map[string]int
fmt.Println(ages &#x3D;&#x3D; nil)    &#x2F;&#x2F; &quot;true&quot;
fmt.Println(len(ages) &#x3D;&#x3D; 0) &#x2F;&#x2F; &quot;true&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是向一个nil值的map存入元素将导致一个panic异常：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ages[&quot;carol&quot;] &#x3D; 21 &#x2F;&#x2F; panic: assignment to entry in nil map<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在向map存数据前必须先创建map。</p>
<p>有时候可能需要知道对应的元素是否真的是在map之中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">age, ok :&#x3D; ages[&quot;bob&quot;]
if !ok &#123; 
    &#x2F;* &quot;bob&quot; is not a key in this map; age &#x3D;&#x3D; 0. *&#x2F; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会经常看到将这两个结合起来使用，像这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if age, ok :&#x3D; ages[&quot;bob&quot;]; !ok &#123; &#x2F;* ... *&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Map的value类型也可以是一个聚合类型，比如是一个map或slice。在下面的代码中，图graph的key类型是一个字符串，value类型map[string]bool代表一个字符串集合。从概念上讲，graph将一个字符串类型的key映射到一组相关的字符串集合，它们指向新的graph的key。</p>
<p><em>gopl.io/ch4/graph</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var graph &#x3D; make(map[string]map[string]bool)

func addEdge(from, to string) &#123;
    edges :&#x3D; graph[from]
    if edges &#x3D;&#x3D; nil &#123;
        edges &#x3D; make(map[string]bool)
        graph[from] &#x3D; edges
    &#125;
    edges[to] &#x3D; true
&#125;

func hasEdge(from, to string) bool &#123;
    return graph[from][to]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中addEdge函数惰性初始化map是一个惯用方式，也就是说在每个值首次作为key时才初始化。addEdge函数显示了如何让map的零值也能正常工作；即使from到to的边不存在，graph[from][to]依然可以返回一个有意义的结果。</p>
<h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><p>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p>
<p>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）</p>
<p>但是S类型的结构体可以包含<code>*S</code>指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</p>
<p>如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings
&#x2F;&#x2F; ...
if _, ok :&#x3D; seen[s]; !ok &#123;
    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;
    &#x2F;&#x2F; ...first time seeing s...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-4-1-结构体字面值"><a href="#4-4-1-结构体字面值" class="headerlink" title="4.4.1. 结构体字面值"></a>4.4.1. 结构体字面值</h3><p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，</p>
<p>如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">pp :&#x3D; &amp;Point&#123;1, 2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它和下面的语句是等价的</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">pp :&#x3D; new(Point)
*pp &#x3D; Point&#123;1, 2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不过&amp;Point{1, 2}写法可以直接在表达式中使用，比如一个函数调用。</p>
<h3 id="4-4-2-结构体比较"><a href="#4-4-2-结构体比较" class="headerlink" title="4.4.2. 结构体比较"></a>4.4.2. 结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。</p>
<p>等比较运算符==将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Point struct&#123; X, Y int &#125;

p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;2, 1&#125;
fmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;
fmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-4-3-结构体嵌入和匿名成员"><a href="#4-4-3-结构体嵌入和匿名成员" class="headerlink" title="4.4.3. 结构体嵌入和匿名成员"></a>4.4.3. 结构体嵌入和匿名成员</h3><p>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Circle struct &#123;
    Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle
    Spokes int
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var w Wheel
w.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8
w.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8
w.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">w &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields
w &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</strong></p>
<h2 id="4-5-JSON"><a href="#4-5-JSON" class="headerlink" title="4.5. JSON"></a>4.5. JSON</h2><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。</p>
<p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持（译注：Protocol Buffers的支持由 github.com/golang/protobuf 包提供）</p>
<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是<code>\Uhhhh</code>转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。</p>
<p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p>
<p>其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为结构体成员Tag所导致的。一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Year  int  &#96;json:&quot;released&quot;&#96;
Color bool &#96;json:&quot;color,omitempty&quot;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里false为零值）。</p>
<h2 id="4-6-文本和HTML模板"><a href="#4-6-文本和HTML模板" class="headerlink" title="4.6. 文本和HTML模板"></a>4.6. 文本和HTML模板</h2><p>前面的例子，只是最简单的格式化，使用Printf是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由text/template和html/template等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。</p>
<p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:
&#123;&#123;range .Items&#125;&#125;----------------------------------------
Number: &#123;&#123;.Number&#125;&#125;
User:   &#123;&#123;.User.Login&#125;&#125;
Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;
Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days
&#123;&#123;end&#125;&#125;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个模板先打印匹配到的issue总数，然后打印每个issue的编号、创建用户、标题还有存在的时间。对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。当前值“.”最初被初始化为调用模板时的参数，在当前例子中对应github.IssuesSearchResult类型的变量。模板中<code>&#123;&#123;.TotalCount&#125;&#125;</code>对应action将展开为结构体中TotalCount成员以默认的方式打印的值。模板中<code>&#123;&#123;range .Items&#125;&#125;</code>和<code>&#123;&#123;end&#125;&#125;</code>对应一个循环action，因此它们直接的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。</p>
<p>在一个action中，<code>|</code>操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。对于Age部分，第二个动作是一个叫daysAgo的函数，通过time.Since函数将CreatedAt成员转换为过去的时间长度：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func daysAgo(t time.Time) int &#123;
    return int(time.Since(t).Hours() &#x2F; 24)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>这部分的模板特性是其他语言里没有的</strong></p>
<h1 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章　函数"></a>第五章　函数</h1><h2 id="5-1-函数声明"><a href="#5-1-函数声明" class="headerlink" title="5.1. 函数声明"></a>5.1. 函数声明</h2><p>我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：即下文的_符号)可以强调某个参数未被使用。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func add(x int, y int) int   &#123;return x + y&#125;
func sub(x, y int) (z int)   &#123; z &#x3D; x - y; return&#125;
func first(x int, _ int) int &#123; return x &#125;
func zero(int, int) int      &#123; return 0 &#125;

fmt.Printf(&quot;%T\n&quot;, add)   &#x2F;&#x2F; &quot;func(int, int) int&quot;
fmt.Printf(&quot;%T\n&quot;, sub)   &#x2F;&#x2F; &quot;func(int, int) int&quot;
fmt.Printf(&quot;%T\n&quot;, first) &#x2F;&#x2F; &quot;func(int, int) int&quot;
fmt.Printf(&quot;%T\n&quot;, zero)  &#x2F;&#x2F; &quot;func(int, int) int&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</p>
<p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package math

func Sin(x float64) float &#x2F;&#x2F;implemented in assembly language<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="5-2-递归"><a href="#5-2-递归" class="headerlink" title="5.2. 递归"></a>5.2. 递归</h2><p>golang.org/x/… 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。</p>
<p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。</p>
<h2 id="5-3-多返回值"><a href="#5-3-多返回值" class="headerlink" title="5.3. 多返回值"></a>5.3. 多返回值</h2><p>虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。</p>
<p>虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。</p>
<p>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; CountWordsAndImages does an HTTP GET request for the HTML
&#x2F;&#x2F; document url and returns the number of words and images in it.
func CountWordsAndImages(url string) (words, images int, err error) &#123;
    resp, err :&#x3D; http.Get(url)
    if err !&#x3D; nil &#123;
        return
    &#125;
    doc, err :&#x3D; html.Parse(resp.Body)
    resp.Body.Close()
    if err !&#x3D; nil &#123;
        err &#x3D; fmt.Errorf(&quot;parsing HTML: %s&quot;, err)
        return
    &#125;
    words, images &#x3D; countWordsAndImages(doc)
    return
&#125;
func countWordsAndImages(n *html.Node) (words, images int) &#123; &#x2F;* ... *&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照返回值列表的次序，返回所有的返回值，在上面的例子中，每一个return语句等价于：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">return words, images, err<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words，image，nil。基于以上原因，不宜过度使用bare return。</p>
<h2 id="5-4-错误"><a href="#5-4-错误" class="headerlink" title="5.4. 错误"></a>5.4. 错误</h2><p>panic是来自被调用函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生panic异常。</p>
<p>对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。</p>
<p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p>
<p>对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。</p>
<p>通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p>
<p>内置的error是接口类型。我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型,我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p>
<p>通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined),这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。</p>
<p>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。对于Go的异常机制我们将在5.9介绍。</p>
<p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</p>
<p>正因此，Go使用控制流机制（如if和return）处理错误，这使得编码人员能更多的关注错误处理。</p>
<h3 id="5-4-1-错误处理策略"><a href="#5-4-1-错误处理策略" class="headerlink" title="5.4.1. 错误处理策略"></a>5.4.1. 错误处理策略</h3><p>常用的五种方式</p>
<p>首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">resp, err :&#x3D; http.Get(url)
if err !&#x3D; nil&#123;
    return nil, err
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，</p>
<p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息（译者注：grep是一种文本搜索工具）。</p>
<p>以os包为例，os包确保文件操作（如os.Open、Read、Write、Close）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。</p>
<p>一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息， </p>
<p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; (In function main.)
if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
    fmt.Fprintf(os.Stderr, &quot;Site is down: %v\n&quot;, err)
    os.Exit(1)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
    log.Fatalf(&quot;Site is down: %v\n&quot;, err)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。</p>
<pre class="line-numbers language-none"><code class="language-none">2006&#x2F;01&#x2F;02 15:04:05 Site is down: no such domain:
bad.gopl.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if err :&#x3D; Ping(); err !&#x3D; nil &#123;
    log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>或者标准错误流输出错误信息。</p>
<p>第五种，也是最后一种策略：我们可以直接忽略掉错误。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)
if err !&#x3D; nil &#123;
    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)
&#125;
&#x2F;&#x2F; ...use temp dir…
os.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。</p>
<p><strong>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。*</strong></p>
<h3 id="5-4-2-文件结尾错误（EOF）"><a href="#5-4-2-文件结尾错误（EOF）" class="headerlink" title="5.4.2. 文件结尾错误（EOF）"></a>5.4.2. 文件结尾错误（EOF）</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">in :&#x3D; bufio.NewReader(os.Stdin)
for &#123;
    r, _, err :&#x3D; in.ReadRune()
    if err &#x3D;&#x3D; io.EOF &#123;
        break &#x2F;&#x2F; finished reading
    &#125;
    if err !&#x3D; nil &#123;
        return fmt.Errorf(&quot;read failed:%v&quot;, err)
    &#125;
    &#x2F;&#x2F; ...use r…
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的错误信息。  </p>
<h2 id="5-5-函数值"><a href="#5-5-函数值" class="headerlink" title="5.5. 函数值"></a>5.5. 函数值</h2><p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p>
<p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var f func(int) int
f(3) &#x2F;&#x2F; 此处f的值为nil, 会引起panic错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>函数值可以与nil比较：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var f func(int) int
if f !&#x3D; nil &#123;
    f(3)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是函数值之间是不可比较的，也不能用函数值作为map的key。</p>
<h2 id="5-6-匿名函数"><a href="#5-6-匿名函数" class="headerlink" title="5.6. 匿名函数"></a>5.6. 匿名函数</h2><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。</p>
<p>函数字面量允许我们在使用函数时，再定义它。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">strings.Map(func(r rune) rune &#123; return r + 1 &#125;, &quot;HAL-9000&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</p>
<p><em>gopl.io/ch5/squares</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; squares返回一个匿名函数。
&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int &#123;
    var x int
    return func() int &#123;
        x++
        return x * x
    &#125;
&#125;

func main() &#123;
    f :&#x3D; squares()
    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。</p>
<p>在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</p>
<p>通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p>
<h3 id="5-6-1-警告：捕获迭代变量"><a href="#5-6-1-警告：捕获迭代变量" class="headerlink" title="5.6.1. 警告：捕获迭代变量"></a>5.6.1. 警告：捕获迭代变量</h3><h2 id="5-7-可变参数"><a href="#5-7-可变参数" class="headerlink" title="5.7. 可变参数"></a>5.7. 可变参数</h2><p>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。</p>
<p><em>gopl.io/ch5/sum</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func sum(vals...int) int &#123;
    total :&#x3D; 0
    for _, val :&#x3D; range vals &#123;
        total +&#x3D; val
    &#125;
    return total
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">values :&#x3D; []int&#123;1, 2, 3, 4&#125;
fmt.Println(sum(values...)) &#x2F;&#x2F; &quot;10&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>虽然在可变参数函数内部，…int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func f(...int) &#123;&#125;
func g([]int) &#123;&#125;
fmt.Printf(&quot;%T\n&quot;, f) &#x2F;&#x2F; &quot;func(...int)&quot;
fmt.Printf(&quot;%T\n&quot;, g) &#x2F;&#x2F; &quot;func([]int)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可变参数函数经常被用于格式化字符串。</p>
<p>函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func errorf(linenum int, format string, args ...interface&#123;&#125;) &#123;
    fmt.Fprintf(os.Stderr, &quot;Line %d: &quot;, linenum)
    fmt.Fprintf(os.Stderr, format, args...)
    fmt.Fprintln(os.Stderr)
&#125;
linenum, name :&#x3D; 12, &quot;count&quot;
errorf(linenum, &quot;undefined: %s&quot;, name) &#x2F;&#x2F; &quot;Line 12: undefined: count&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>interface{}表示函数的最后一个参数可以接收任意类型 </p>
<h2 id="5-8-Deferred函数"><a href="#5-8-Deferred函数" class="headerlink" title="5.8. Deferred函数"></a>5.8. Deferred函数</h2><p>你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</p>
<p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。 </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package ioutil
func ReadFile(filename string) ([]byte, error) &#123;
    f, err :&#x3D; os.Open(filename)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    defer f.Close()
    return ReadAll(f)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或是处理互斥锁（9.2章）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var mu sync.Mutex
var m &#x3D; make(map[string]int)
func lookup(key string) int &#123;
    mu.Lock()
    defer mu.Unlock()
    return m[key]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。</p>
<p>下例中的bigSlowOperation函数，直接调用trace记录函数的被调情况。bigSlowOperation被调时，trace会返回一个函数值，该函数值会在bigSlowOperation退出时被调用。通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，如例子中的start。需要注意一点：<strong>不要忘记defer语句后的圆括号</strong>，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。</p>
<p><em>gopl.io/ch5/trace</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func bigSlowOperation() &#123;
    defer trace(&quot;bigSlowOperation&quot;)() &#x2F;&#x2F; don&#39;t forget the extra parentheses
    &#x2F;&#x2F; ...lots of work…
    time.Sleep(10 * time.Second) &#x2F;&#x2F; simulate slow operation by sleeping
&#125;
func trace(msg string) func() &#123;
    start :&#x3D; time.Now()
    log.Printf(&quot;enter %s&quot;, msg)
    return func() &#123; 
        log.Printf(&quot;exit %s (%s)&quot;, msg,time.Since(start)) 
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 通过os.Create打开文件进行写入，在关闭文件时，我们没有对f.close采用defer机制，因为这会产生一些微妙的错误。许多文件系统，尤其是NFS，写入文件时发生的错误会被延迟到文件关闭时反馈。如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。如果io.Copy和f.close都失败了，我们倾向于将io.Copy的错误信息反馈给调用者，因为它先于f.close发生，更有可能接近问题的本质。</p>
<h2 id="5-9-Panic异常"><a href="#5-9-Panic异常" class="headerlink" title="5.9. Panic异常"></a>5.9. Panic异常</h2><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p>
<p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息</p>
<p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">switch s :&#x3D; suit(drawCard()); s &#123;
    case &quot;Spades&quot;:                                &#x2F;&#x2F; ...
    case &quot;Hearts&quot;:                                &#x2F;&#x2F; ...
    case &quot;Diamonds&quot;:                              &#x2F;&#x2F; ...
    case &quot;Clubs&quot;:                                 &#x2F;&#x2F; ...
    default:
        panic(fmt.Sprintf(&quot;invalid suit %q&quot;, s)) &#x2F;&#x2F; Joker?
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，<strong>编译器在运行时会帮你检查代码。</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Reset(x *Buffer) &#123;
    if x &#x3D;&#x3D; nil &#123;
        panic(&quot;x is nil&quot;) &#x2F;&#x2F; unnecessary!
    &#125;
    x.elements &#x3D; nil
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。<strong>勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，</strong>尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。</p>
<p>我们在下一节将看到，如何使程序从panic异常中恢复，阻止程序的崩溃</p>
<p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    defer printStack()
    f(3)
&#125;
func printStack() &#123;
    var buf [4096]byte
    n :&#x3D; runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>
<h2 id="5-10-Recover捕获异常"><a href="#5-10-Recover捕获异常" class="headerlink" title="5.10. Recover捕获异常"></a>5.10. Recover捕获异常</h2><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p>
<p>让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Parse(input string) (s *Syntax, err error) &#123;
    defer func() &#123;
        if p :&#x3D; recover(); p !&#x3D; nil &#123;
            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)
        &#125;
    &#125;()
    &#x2F;&#x2F; ...parser...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。</p>
<p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p>
<p>有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</p>
<p>基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理</p>
<p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。</p>
<h1 id="第六章-方法"><a href="#第六章-方法" class="headerlink" title="第六章　方法"></a>第六章　方法</h1><h2 id="6-1-方法声明"><a href="#6-1-方法声明" class="headerlink" title="6.1. 方法声明"></a>6.1. 方法声明</h2><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package geometry

import &quot;math&quot;

type Point struct&#123; X, Y float64 &#125;

&#x2F;&#x2F; traditional function
func Distance(p, q Point) float64 &#123;
    return math.Hypot(q.X-p.X, q.Y-p.Y)
&#125;

&#x2F;&#x2F; same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 &#123;
    return math.Hypot(q.X-p.X, q.Y-p.Y)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码里那个附加的参数p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。</p>
<p>在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。</p>
<p>在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;
fmt.Println(Distance(p, q)) &#x2F;&#x2F; &quot;5&quot;, function call
fmt.Println(p.Distance(q))  &#x2F;&#x2F; &quot;5&quot;, method call<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数geometry.Distance，而第二个则是使用刚刚声明的Point，调用的是Point类下声明的Point.Distance方法。</p>
<p>这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。</p>
<p>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名</p>
<h2 id="6-2-基于指针对象的方法"><a href="#6-2-基于指针对象的方法" class="headerlink" title="6.2. 基于指针对象的方法"></a>6.2. 基于指针对象的方法</h2><p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。</p>
<p>为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type P *int
func (P) f() &#123; &#x2F;* ... *&#x2F; &#125; &#x2F;&#x2F; compile error: invalid receiver type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>想要调用指针类型方法<code>(*Point).ScaleBy</code>，只要提供一个Point类型的指针即可，像下面这样。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; &amp;Point&#123;1, 2&#125;
r.ScaleBy(2)
fmt.Println(*r) &#x2F;&#x2F; &quot;&#123;2, 4&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">p.ScaleBy(2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Point&#123;1, 2&#125;.ScaleBy(2) &#x2F;&#x2F; compile error: can&#39;t take address of Point literal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是我们可以用一个<code>*Point</code>这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号<code>*</code>来取到该变量即可。编译器在这里也会给我们隐式地插入<code>*</code>这个操作符，所以下面这两种写法等价的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">pptr.Distance(q)
(*pptr).Distance(q)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="6-2-1-Nil也是一个合法的接收器类型"><a href="#6-2-1-Nil也是一个合法的接收器类型" class="headerlink" title="6.2.1. Nil也是一个合法的接收器类型"></a>6.2.1. Nil也是一个合法的接收器类型</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">m :&#x3D; url.Values&#123;&quot;lang&quot;: &#123;&quot;en&quot;&#125;&#125; &#x2F;&#x2F; direct construction
m.Add(&quot;item&quot;, &quot;1&quot;)
m.Add(&quot;item&quot;, &quot;2&quot;)

fmt.Println(m.Get(&quot;lang&quot;)) &#x2F;&#x2F; &quot;en&quot;
fmt.Println(m.Get(&quot;q&quot;))    &#x2F;&#x2F; &quot;&quot;
fmt.Println(m.Get(&quot;item&quot;)) &#x2F;&#x2F; &quot;1&quot;      (first value)
fmt.Println(m[&quot;item&quot;])     &#x2F;&#x2F; &quot;[1 2]&quot;  (direct map access)

m &#x3D; nil
fmt.Println(m.Get(&quot;item&quot;)) &#x2F;&#x2F; &quot;&quot;
m.Add(&quot;item&quot;, &quot;3&quot;)         &#x2F;&#x2F; panic: assignment to entry in nil map<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对Get的最后一次调用中，nil接收器的行为即是一个空map的行为。我们可以等价地将这个操作写成Value(nil).Get(“item”)，但是如果你直接写nil.Get(“item”)的话是无法通过编译的，因为nil的字面量编译器无法判断其准确类型。所以相比之下，最后的那行m.Add的调用就会产生一个panic，因为他尝试更新一个空map。</p>
<p>由于url.Values是一个map类型，并且间接引用了其key/value对，因此url.Values.Add对这个map里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为nil，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的）</p>
<h2 id="6-3-通过嵌入结构体来扩展类型"><a href="#6-3-通过嵌入结构体来扩展类型" class="headerlink" title="6.3. 通过嵌入结构体来扩展类型"></a>6.3. 通过嵌入结构体来扩展类型</h2><p>读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而ColoredPoint看作其子类或者继承类，或者将ColoredPoint看作”is a” Point类型。但这是错误的理解。请注意上面例子中对Distance方法的调用。Distance有一个参数是Point类型，但q并不是一个Point类，所以尽管q有着Point这个内嵌类型，我们也必须要显式地选择它。尝试直接传q的话你会看到下面这样的错误：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">p.Distance(q) &#x2F;&#x2F; compile error: cannot use q (ColoredPoint) as Point<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一个ColoredPoint并不是一个Point，但他”has a”Point，并且它有从Point类里引入的Distance和ScaleBy方法。如果你喜欢从实现的角度来考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：</p>
<p>下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量(§9.2)和它所操作的cache：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var (
    mu sync.Mutex &#x2F;&#x2F; guards mapping
    mapping &#x3D; make(map[string]string)
)

func Lookup(key string) string &#123;
    mu.Lock()
    v :&#x3D; mapping[key]
    mu.Unlock()
    return v
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var cache &#x3D; struct &#123;
    sync.Mutex
    mapping map[string]string
&#125;&#123;
    mapping: make(map[string]string),
&#125;


func Lookup(key string) string &#123;
    cache.Lock()
    v :&#x3D; cache.mapping[key]
    cache.Unlock()
    return v
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p>
<h2 id="6-4-方法值和方法表达式"><a href="#6-4-方法值和方法表达式" class="headerlink" title="6.4. 方法值和方法表达式"></a>6.4. 方法值和方法表达式</h2><p>在某些情况，方法可以当做值来使用</p>
<h2 id="6-5-示例-Bit数组"><a href="#6-5-示例-Bit数组" class="headerlink" title="6.5. 示例: Bit数组"></a>6.5. 示例: Bit数组</h2><h2 id="6-6-封装"><a href="#6-6-封装" class="headerlink" title="6.6. 封装"></a>6.6. 封装</h2><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。</p>
<p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</p>
<h1 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章　接口"></a>第七章　接口</h1><p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p>
<p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。 </p>
<h2 id="7-1-接口约定"><a href="#7-1-接口约定" class="headerlink" title="7.1. 接口约定"></a>7.1. 接口约定</h2><p>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p>
<h2 id="7-2-接口类型"><a href="#7-2-接口类型" class="headerlink" title="7.2 接口类型"></a>7.2 接口类型</h2><h2 id="7-3-实现接口的条件"><a href="#7-3-实现接口的条件" class="headerlink" title="7.3 实现接口的条件"></a>7.3 实现接口的条件</h2><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</p>
<p>例如，<code>*os.File</code>类型实现了io.Reader，Writer，Closer，和ReadWriter接口。<code>*bytes.Buffer</code>实现了Reader，Writer，和ReadWriter这些接口，但是它没有实现Closer接口因为它不具有Close方法</p>
<p>接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var w io.Writer
w &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method
w &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method
w &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods
rwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个规则甚至适用于等式右边本身也是一个接口类型</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">w &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method
rwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在第6.5章中，IntSet类型的String方法的接收者是一个指针类型，所以我们不能在一个不能寻址的IntSet值上调用这个方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type IntSet struct &#123; &#x2F;* ... *&#x2F; &#125;
func (*IntSet) String() string
var _ &#x3D; IntSet&#123;&#125;.String() &#x2F;&#x2F; compile error: String requires *IntSet receiver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是我们可以在一个IntSet值上调用这个方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var s IntSet
var _ &#x3D; s.String() &#x2F;&#x2F; OK: s is a variable and &amp;s has a String method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然而，由于只有<code>*IntSet</code>类型有String方法，所以也只有<code>*IntSet</code>类型实现了fmt.Stringer接口：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var _ fmt.Stringer &#x3D; &amp;s &#x2F;&#x2F; OK
var _ fmt.Stringer &#x3D; s  &#x2F;&#x2F; compile error: IntSet lacks String method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于创建的一个interface{}值持有一个boolean，float，string，map，pointer，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法。</p>
<p>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p>
<h2 id="7-4-flag-Value接口"><a href="#7-4-flag-Value接口" class="headerlink" title="7.4. flag.Value接口"></a>7.4. flag.Value接口</h2><h2 id="7-5-接口值"><a href="#7-5-接口值" class="headerlink" title="7.5. 接口值"></a>7.5. 接口值</h2><p>接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。</p>
<p>下面4个语句中，变量w得到了3个不同的值。（开始和最后的值是相同的）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var w io.Writer
w &#x3D; os.Stdout
w &#x3D; new(bytes.Buffer)
w &#x3D; nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>让我们进一步观察在每一个语句后的w变量的值和动态行为。第一个语句定义了变量w:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var w io.Writer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil</p>
<p>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生panic:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; panic: nil pointer dereference<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同）</p>
<p>接口值可以使用== 和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</p>
<p>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var x interface&#123;&#125; &#x3D; []int&#123;1, 2, 3&#125;
fmt.Println(x &#x3D;&#x3D; x) &#x2F;&#x2F; panic: comparing uncomparable type []int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。</p>
<p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var w io.Writer
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;
w &#x3D; os.Stdout
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*os.File&quot;
w &#x3D; new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在fmt包内部，使用反射来获取接口动态类型的名称</p>
<h3 id="7-5-1-警告：一个包含nil指针的接口不是nil接口"><a href="#7-5-1-警告：一个包含nil指针的接口不是nil接口" class="headerlink" title="7.5.1. 警告：一个包含nil指针的接口不是nil接口"></a>7.5.1. 警告：一个包含nil指针的接口不是nil接口</h3><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
<p>思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const debug &#x3D; true

func main() &#123;
    var buf *bytes.Buffer
    if debug &#123;
        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
    &#125;
    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!
    if debug &#123;
        &#x2F;&#x2F; ...use buf...
    &#125;
&#125;

&#x2F;&#x2F; If out is non-nil, output will be written to it.
func f(out io.Writer) &#123;
    &#x2F;&#x2F; ...do something...
    if out !&#x3D; nil &#123;
        out.Write([]byte(&quot;done!\n&quot;))
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if out !&#x3D; nil &#123;
    out.Write([]byte(&quot;done!\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当main函数调用函数f时，它给f函数的out参数赋了一个<em>bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是</em>bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!=nil的结果依然是true。</p>
<p><img src="https://docs.hacknode.org/gopl-zh/images/ch7-05.png" alt="img"></p>
<p>动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如<em>os.File的类型，nil是一个有效的接收者(§6.2.1)，但是</em>bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p>
<p>问题在于尽管一个nil的<em>bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(</em>bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var buf io.Writer
if debug &#123;
    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
&#125;
f(buf) &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。</p>
<h2 id="7-6-sort-Interface接口"><a href="#7-6-sort-Interface接口" class="headerlink" title="7.6. sort.Interface接口"></a>7.6. sort.Interface接口</h2><p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是sort.Interface的三个方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package sort

type Interface interface &#123;
    Len() int
    Less(i, j int) bool &#x2F;&#x2F; i, j are indices of sequence elements
    Swap(i, j int)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型StringSlice和它的Len，Less和Swap方法</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type StringSlice []string
func (p StringSlice) Len() int           &#123; return len(p) &#125;
func (p StringSlice) Less(i, j int) bool &#123; return p[i] &lt; p[j] &#125;
func (p StringSlice) Swap(i, j int)      &#123; p[i], p[j] &#x3D; p[j], p[i] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们可以通过像下面这样将一个切片转换为一个StringSlice类型来进行排序：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">sort.Sort(StringSlice(names))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="7-10-类型断言"><a href="#7-10-类型断言" class="headerlink" title="7.10. 类型断言"></a>7.10. 类型断言</h2><p>类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。</p>
<p>一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。果检查失败，接下来这个操作会抛出panic。 </p>
<p>第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大）,但是它保留了接口值内部的动态类型和值的部分。</p>
<p>在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型<code>*os.File</code>，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var w io.Writer
w &#x3D; os.Stdout
rw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write
w &#x3D; new(ByteCounter)
rw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">w &#x3D; rw             &#x2F;&#x2F; io.ReadWriter is assignable to io.Writer
w &#x3D; rw.(io.Writer) &#x2F;&#x2F; fails only if rw &#x3D;&#x3D; nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖（理解：其实是声明了一个同名的新的本地变量，外层原来的w不会被改变），如下面这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if w, ok :&#x3D; w.(*os.File); ok &#123;
    &#x2F;&#x2F; ...use w...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="7-11-基于类型断言区别错误类型"><a href="#7-11-基于类型断言区别错误类型" class="headerlink" title="7.11. 基于类型断言区别错误类型"></a>7.11. 基于类型断言区别错误类型</h2><h2 id="7-12-通过类型断言询问行为"><a href="#7-12-通过类型断言询问行为" class="headerlink" title="7.12. 通过类型断言询问行为"></a>7.12. 通过类型断言询问行为</h2><h2 id="7-13-类型分支"><a href="#7-13-类型分支" class="headerlink" title="7.13. 类型分支"></a>7.13. 类型分支</h2><p>接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。</p>
<p>第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）</p>
<p>如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态）</p>
<p>和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import &quot;database&#x2F;sql&quot;

func listTracks(db sql.DB, artist string, minYear, maxYear int) &#123;
    result, err :&#x3D; db.Exec(
        &quot;SELECT * FROM tracks WHERE artist &#x3D; ? AND ? &lt;&#x3D; year AND year &lt;&#x3D; ?&quot;,
        artist, minYear, maxYear)
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Exec方法使用SQL字面量替换在查询字符串中的每个’?’；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func sqlQuote(x interface&#123;&#125;) string &#123;
    if x &#x3D;&#x3D; nil &#123;
        return &quot;NULL&quot;
    &#125; else if _, ok :&#x3D; x.(int); ok &#123;
        return fmt.Sprintf(&quot;%d&quot;, x)
    &#125; else if _, ok :&#x3D; x.(uint); ok &#123;
        return fmt.Sprintf(&quot;%d&quot;, x)
    &#125; else if b, ok :&#x3D; x.(bool); ok &#123;
        if b &#123;
            return &quot;TRUE&quot;
        &#125;
        return &quot;FALSE&quot;
    &#125; else if s, ok :&#x3D; x.(string); ok &#123;
        return sqlQuoteString(s) &#x2F;&#x2F; (not shown)
    &#125; else &#123;
        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">switch x :&#x3D; x.(type) &#123; &#x2F;* ... *&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里我们已经将新的变量也命名为x；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量x的定义不会和外面块中的x变量冲突。每一个case也会隐式的创建一个单独的词法块。</p>
<p>使用类型分支的扩展形式来重写sqlQuote函数会让这个函数更加的清晰：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func sqlQuote(x interface&#123;&#125;) string &#123;
    switch x :&#x3D; x.(type) &#123;
    case nil:
        return &quot;NULL&quot;
    case int, uint:
        return fmt.Sprintf(&quot;%d&quot;, x) &#x2F;&#x2F; x has type interface&#123;&#125; here.
    case bool:
        if x &#123;
            return &quot;TRUE&quot;
        &#125;
        return &quot;FALSE&quot;
    case string:
        return sqlQuoteString(x) &#x2F;&#x2F; (not shown)
    default:
        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Go支持在一个case里写多个条件，例如：”a”,”b” 或者 i<1 && i >-1</strong></p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>使用goto语句跳转到标签，进行代码间的无条件跳转。在快速跳出循环，避免重复退出方面也有一定的帮助。并且可以简化一些代码的实现流程。</p>
<p>在满足条件时，如果需要重复退出两层循环，传统的编码方式：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
  var isBreak bool
  for x :&#x3D; 0; x &lt; 20; x++ &#123;
    for y :&#x3D; 0; y &lt; 20; y++ &#123;
      if y &#x3D;&#x3D; 2 &#123;
        isBreak &#x3D; true
        break
      &#125;
    &#125;
    if isBreak &#123; &#x2F;&#x2F; 根据标记，再退出外层循环
      break
    &#125;
  &#125;
  fmt.Println(&quot;over!&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将上面的代码改写为goto形式：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
  for x :&#x3D; 0; x &lt; 20; x++ &#123;
    for y :&#x3D; 0; y &lt; 20; y++ &#123;
      if y &#x3D;&#x3D; 2 &#123;
        goto breakTag
      &#125;
    &#125;
  &#125;
  return 
breakTag:
  fmt.Println(&quot;done&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在以上代码中，标签只能被goto使用，不影响代码执行流程。在定义标签breakTag之前有一个return语句，此处如果不手动返回，则在不满足条件时也会执行breakTag代码。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import &quot;fmt&quot;

func main() &#123;
	for x :&#x3D; 0; x &lt; 20; x++ &#123;
		for y :&#x3D; 0; y &lt; 20; y++ &#123;
			if y &gt;&#x3D; 22 &#123;
				goto breakTag
			&#125;
		&#125;
	&#125;
breakTag:
	fmt.Println(&quot;done&quot;)
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码中，经常会遇到”多错误处理“，存在代码重复问题</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
  ...
  err :&#x3D; getUserInfo()
  if err !&#x3D; nil &#123;
    goto doExit
  &#125;
  err :&#x3D; getEmail()
  if err !&#x3D; nil &#123;
    goto doExit
  &#125;
  fmt.Println(&quot;over&quot;)
  return
doExit:
  fmt.Println(err)
  exitProcess()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>在break语句后面添加标签，表示退出某个标签对应的代码块，添加的标签必须定义在对应的for，Switch和select的代码块上。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import &quot;fmt&quot;

func main() &#123;
OuterLoop:
	for x :&#x3D; 0; x &lt; 20; x++ &#123;
		for y :&#x3D; 0; y &lt; 20; y++ &#123;
			switch y &#123;
			case 1:
				fmt.Println(x - y) &#x2F;&#x2F; 退出OuterLoop的循环之外
				break OuterLoop
			case 2:
				fmt.Println(y - x)
				continue OuterLoop
			&#125;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="7-15-一些建议"><a href="#7-15-一些建议" class="headerlink" title="7.15. 一些建议"></a>7.15. 一些建议</h2><p>当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制(§6.6)来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</p>
<p>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</p>
<p>因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）</p>
<h1 id="第八章-Goroutines和Channels"><a href="#第八章-Goroutines和Channels" class="headerlink" title="第八章　Goroutines和Channels"></a>第八章　Goroutines和Channels</h1><p>Go语言中的并发程序可以用两种手段来实现。本章讲解goroutine和channel，其支持“顺序通信进程”(communicating sequential processes)或被简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例(goroutine)中传递，尽管大多数情况下仍然是被限制在单一实例中。</p>
<p>尽管Go对并发的支持是众多强力特性之一，但跟踪调试并发程序还是很困难，在线性程序中形成的直觉往往还会使我们误入歧途。</p>
<h2 id="8-1-Goroutines"><a href="#8-1-Goroutines" class="headerlink" title="8.1. Goroutines"></a>8.1. Goroutines</h2><p>在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。</p>
<p>新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">f()    &#x2F;&#x2F; call f(); wait for it to return
go f() &#x2F;&#x2F; create a new goroutine that calls f(); don&#39;t wait<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</p>
<h2 id="8-2-示例-并发的Clock服务"><a href="#8-2-示例-并发的Clock服务" class="headerlink" title="8.2. 示例: 并发的Clock服务"></a>8.2. 示例: 并发的Clock服务</h2><p>网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端 </p>
<h2 id="8-3-示例-并发的Echo服务"><a href="#8-3-示例-并发的Echo服务" class="headerlink" title="8.3. 示例: 并发的Echo服务"></a>8.3. 示例: 并发的Echo服务</h2><p>让服务使用并发不只是处理多个客户端的请求，甚至在处理单个连接时也可能会用到，就像我们上面的两个go关键词的用法。然而在我们使用go关键词的同时，需要慎重地考虑net.Conn中的方法在并发地调用时是否安全，事实上对于大多数类型来说也确实不安全。我们会在下一章中详细地探讨并发安全性。</p>
<h2 id="8-4-Channels"><a href="#8-4-Channels" class="headerlink" title="8.4. Channels"></a>8.4. Channels</h2><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p>
<p>使用内置的make函数，我们可以创建一个channel：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ch :&#x3D; make(chan int) &#x2F;&#x2F; ch has type &#39;chan int&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p>
<p>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</p>
<p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ch &lt;- x  &#x2F;&#x2F; a send statement
x &#x3D; &lt;-ch &#x2F;&#x2F; a receive expression in an assignment statement
&lt;-ch     &#x2F;&#x2F; a receive statement; result is discarded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</p>
<p>使用内置的close函数就可以关闭一个channel：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">close(ch)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ch &#x3D; make(chan int)    &#x2F;&#x2F; unbuffered channel
ch &#x3D; make(chan int, 0) &#x2F;&#x2F; unbuffered channel
ch &#x3D; make(chan int, 3) &#x2F;&#x2F; buffered channel with capacity 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="8-4-1-不带缓存的Channels"><a href="#8-4-1-不带缓存的Channels" class="headerlink" title="8.4.1. 不带缓存的Channels"></a>8.4.1. 不带缓存的Channels</h3><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p>
<p>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前（译注：<em>happens before</em>，这是Go语言并发内存模型的一个关键术语！）。</p>
<p>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</p>
<p>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。</p>
<h3 id="8-4-2-串联的Channels（Pipeline）"><a href="#8-4-2-串联的Channels（Pipeline）" class="headerlink" title="8.4.2. 串联的Channels（Pipeline）"></a>8.4.2. 串联的Channels（Pipeline）</h3><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来，如图8.1所示。</p>
<p><img src="https://docs.hacknode.org/gopl-zh/images/ch8-01.png" alt="img"></p>
<p>像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？</p>
<p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">close(naturals)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</p>
<p>没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel.</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() &#123;
	naturals :&#x3D; make(chan int)
	squares :&#x3D; make(chan int)

	&#x2F;&#x2F; Counter
	go func() &#123;
		for x :&#x3D; 0; x &lt; 5; x++ &#123;
			naturals &lt;- x
		&#125;
		close(naturals)
	&#125;()

	&#x2F;&#x2F; Squarer
	go func() &#123;
		for &#123;
			x, ok :&#x3D; &lt;-naturals
			if !ok &#123;
				break
			&#125;
			squares &lt;- x * x
		&#125;
		close(squares)
	&#125;()

	&#x2F;&#x2F; Printer (in main goroutine)
	for i :&#x3D; 0; i &lt; 5; i++ &#123;
		fmt.Println(&lt;-squares)
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。）最后，主goroutine也可以正常终止循环并退出程序。</p>
<p><em>gopl.io/ch8/pipeline2</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    naturals :&#x3D; make(chan int)
    squares :&#x3D; make(chan int)

    &#x2F;&#x2F; Counter
    go func() &#123;
        for x :&#x3D; 0; x &lt; 100; x++ &#123;
            naturals &lt;- x
        &#125;
        close(naturals)
    &#125;()

    &#x2F;&#x2F; Squarer
    go func() &#123;
        for x :&#x3D; range naturals &#123;
            squares &lt;- x * x
        &#125;
        close(squares)
    &#125;()

    &#x2F;&#x2F; Printer (in main goroutine)
    for x :&#x3D; range squares &#123;
        fmt.Println(x)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实你并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。）</p>
<p>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制</p>
<h3 id="8-4-3-单方向的Channel"><a href="#8-4-3-单方向的Channel" class="headerlink" title="8.4.3. 单方向的Channel"></a>8.4.3. 单方向的Channel</h3><p>当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。</p>
<p>分别用于只发送或只接收的channel。类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。（箭头<code>&lt;-</code>和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。</p>
<p><strong>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误</strong>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func counter(out chan&lt;- int) &#123;
    for x :&#x3D; 0; x &lt; 100; x++ &#123;
        out &lt;- x
    &#125;
    close(out)
&#125;

func squarer(out chan&lt;- int, in &lt;-chan int) &#123;
    for v :&#x3D; range in &#123;
        out &lt;- v * v
    &#125;
    close(out)
&#125;

func printer(in &lt;-chan int) &#123;
    for v :&#x3D; range in &#123;
        fmt.Println(v)
    &#125;
&#125;

func main() &#123;
    naturals :&#x3D; make(chan int)
    squares :&#x3D; make(chan int)
    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用counter（naturals）时，naturals的类型将隐式地从chan int转换成chan&lt;- int。调用printer(squares)也会导致相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的channel。任何双向channel向单向channel变量的赋值操作都将导致该隐式转换</p>
<h3 id="8-4-4-带缓存的Channels"><a href="#8-4-4-带缓存的Channels" class="headerlink" title="8.4.4. 带缓存的Channels"></a>8.4.4. 带缓存的Channels</h3><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>
<p>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</p>
<p>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。</p>
<p>Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。</p>
<p>如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。</p>
<p>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p>
<p>生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。<strong>例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作</strong>。这类似于基于相同的channels创建另一个独立的goroutine。</p>
<h2 id="8-9-并发的退出"><a href="#8-9-并发的退出" class="headerlink" title="8.9. 并发的退出"></a>8.9. 并发的退出</h2><p>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上</p>
<p>为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。</p>
<p>回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。</p>
<p>现在当取消发生时，所有后台的goroutine都会迅速停止并且主函数会返回。当然，当主函数返回时，一个程序会退出，而我们又无法在主函数退出的时候确认其已经释放了所有的资源(译注：因为程序都退出了，你的代码都没法执行了)。这里有一个方便的窍门我们可以一用：取代掉直接从主函数返回，我们调用一个panic，然后runtime会把每一个goroutine的栈dump下来。如果main goroutine是唯一一个剩下的goroutine的话，他会清理掉自己的一切资源。但是如果还有其它的goroutine没有退出，他们可能没办法被正确地取消掉，也有可能被取消但是取消操作会很花时间；所以这里的一个调研还是很有必要的。我们用panic来获取到足够的信息来验证我们上面的判断，看看最终到底是什么样的情况。</p>
<h1 id="第九章-基于共享变量的并发"><a href="#第九章-基于共享变量的并发" class="headerlink" title="第九章　基于共享变量的并发"></a>第九章　基于共享变量的并发</h1><h2 id="9-1-竞态条件"><a href="#9-1-竞态条件" class="headerlink" title="9.1 竞态条件"></a>9.1 竞态条件</h2><p>当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。</p>
<p>一个函数在并发调用时没法工作的原因太多了，比如死锁(deadlock)、活锁(livelock)和饿死(resource starvation)。我们没有空去讨论所有的问题，这里我们只聚焦在竞争条件上。</p>
<p>竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。</p>
<h2 id="9-2-sync-Mutex互斥锁"><a href="#9-2-sync-Mutex互斥锁" class="headerlink" title="9.2. sync.Mutex互斥锁"></a>9.2. sync.Mutex互斥锁</h2><p>这种互斥很实用，而且被sync包里的Mutex类型直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token：</p>
<p><em>gopl.io/ch9/bank3</em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import &quot;sync&quot;

var (
    mu      sync.Mutex &#x2F;&#x2F; guards balance
    balance int
)

func Deposit(amount int) &#123;
    mu.Lock()
    balance &#x3D; balance + amount
    mu.Unlock()
&#125;

func Balance() int &#123;
    mu.Lock()
    b :&#x3D; balance
    mu.Unlock()
    return b
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在更复杂的临界区的应用中，尤其是必须要尽早处理错误并返回的情况下，就很难去(靠人)判断对Lock和Unlock的调用是在所有路径中都能够严格配对的了。Go语言里的defer简直就是这种情况下的救星：我们用defer来调用Unlock，临界区会隐式地延伸到函数作用域的最后，这样我们就从“总要记得在函数返回之后或者发生错误返回时要记得调用一次Unlock”这种状态中获得了解放。Go会自动帮我们完成这些事情。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Balance() int &#123;
    mu.Lock()
    defer mu.Unlock()
    return balance
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，一个deferred Unlock即使在临界区发生panic时依然会执行，这对于用recover (§5.10)来恢复的程序来说是很重要的。defer调用只会比显式地调用Unlock成本高那么一点点，不过却在很大程度上保证了代码的整洁性。</p>
<p>理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; NOTE: incorrect!
func Withdraw(amount int) bool &#123;
    mu.Lock()
    defer mu.Unlock()
    Deposit(-amount)
    if Balance() &lt; 0 &#123;
        Deposit(amount)
        return false &#x2F;&#x2F; insufficient funds
    &#125;
    return true
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这个例子中，Deposit会调用mu.Lock()第二次去获取互斥锁，但因为mutex已经锁上了，而无法被重入(译注：go里没有重入锁，关于重入锁的概念，请参考java)—也就是说没法对一个已经锁上的mutex来再次上锁—这会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。</p>
<h2 id="9-3-sync-RWMutex读写锁"><a href="#9-3-sync-RWMutex读写锁" class="headerlink" title="9.3. sync.RWMutex读写锁"></a>9.3. sync.RWMutex读写锁</h2><p>由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁(multiple readers, single writer lock)，Go语言提供的这样的锁是sync.RWMutex：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var mu sync.RWMutex
var balance int
func Balance() int &#123;
    mu.RLock() &#x2F;&#x2F; readers lock
    defer mu.RUnlock()
    return balance
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>RLock只能在临界区共享变量没有任何写入操作时可用。一般来说，我们不应该假设逻辑上的只读函数/方法也不会去更新某一些变量。比如一个方法功能是访问一个变量，但它也有可能会同时去给一个内部的计数器+1(译注：可能是记录这个方法的访问次数啥的)，或者去更新缓存—使即时的调用能够更快。如果有疑惑的话，请使用互斥锁。</p>
<p>RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些</p>
<h2 id="9-4-内存同步"><a href="#9-4-内存同步" class="headerlink" title="9.4. 内存同步"></a>9.4. 内存同步</h2><p>你可能比较纠结为什么Balance方法需要用到互斥条件，无论是基于channel还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它goroutine在其执行“期间”执行其它逻辑的风险。这里使用mutex有两方面考虑。第一Balance不会在其它操作比如Withdraw“中间”执行。第二（更重要的）是“同步”不仅仅是一堆goroutine执行顺序的问题，同样也会涉及到内存的问题。</p>
<p>在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存(local cache)。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。</p>
<p>考虑一下下面代码片段的可能输出：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var x, y int
go func() &#123;
    x &#x3D; 1 &#x2F;&#x2F; A1
    fmt.Print(&quot;y:&quot;, y, &quot; &quot;) &#x2F;&#x2F; A2
&#125;()
go func() &#123;
    y &#x3D; 1                   &#x2F;&#x2F; B1
    fmt.Print(&quot;x:&quot;, x, &quot; &quot;) &#x2F;&#x2F; B2
&#125;()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为两个goroutine是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：</p>
<pre class="line-numbers language-none"><code class="language-none">y:0 x:1
x:0 y:1
x:1 y:1
y:1 x:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。然而实际运行时还是有些情况让我们有点惊讶：</p>
<pre class="line-numbers language-none"><code class="language-none">x:0 y:0
y:0 x:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。</p>
<h2 id="9-5-sync-Once惰性初始化"><a href="#9-5-sync-Once惰性初始化" class="headerlink" title="9.5. sync.Once惰性初始化"></a>9.5. sync.Once惰性初始化</h2><p>回忆一下9.4节。因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var mu sync.RWMutex &#x2F;&#x2F; guards icons
var icons map[string]image.Image
&#x2F;&#x2F; Concurrency-safe.
func Icon(name string) image.Image &#123;
    mu.RLock()
    if icons !&#x3D; nil &#123;
        icon :&#x3D; icons[name]
        mu.RUnlock()
        return icon
    &#125;
    mu.RUnlock()

    &#x2F;&#x2F; acquire an exclusive lock
    mu.Lock()
    if icons &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; NOTE: must recheck for nil
        loadIcons()
    &#125;
    icon :&#x3D; icons[name]
    mu.Unlock()
    return icon
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码有两个临界区。goroutine首先会获取一个读锁，查询map，然后释放锁。如果条目被找到了(一般情况下)，那么会直接返回。如果没有找到，那goroutine会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查icons变量是否为nil，以防止在执行这一段代码的时候，icons变量已经被其它gorouine初始化过了。</p>
<p>上面的模板使我们的程序能够更好的并发，但是有一点太复杂且容易出错。幸运的是，sync包为我们提供了一个专门的方案来解决这种一次性初始化的问题：sync.Once。概念上来讲，一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了；互斥量用来保护boolean变量和客户端数据结构。Do这个唯一的方法需要接收初始化函数作为其参数。让我们用sync.Once来简化前面的Icon函数吧：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var loadIconsOnce sync.Once
var icons map[string]image.Image
&#x2F;&#x2F; Concurrency-safe.
func Icon(name string) image.Image &#123;
    loadIconsOnce.Do(loadIcons)
    return icons[name]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一次对Do(loadIcons)的调用都会锁定mutex，并会检查boolean变量(译注：Go1.9中会先判断boolean变量是否为1(true)，只有不为1才锁定mutex，不再需要每次都锁定mutex)。在第一次调用时，boolean变量的值是false，Do会调用loadIcons并会将boolean变量设置为true。随后的调用什么都不会做，但是mutex同步会保证loadIcons对内存(这里其实就是指icons变量啦)产生的效果能够对所有goroutine可见。用这种方式来使用sync.Once的话，我们能够避免在变量被构建完成之前和其它goroutine共享该变量。</p>
<h2 id="9-6-竞争条件检测"><a href="#9-6-竞争条件检测" class="headerlink" title="9.6. 竞争条件检测"></a>9.6. 竞争条件检测</h2><p>只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对<code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code>等等的调用。(完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的</p>
<p>竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。</p>
<p>竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。</p>
<p>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的工作来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。(译注：多少服务端C和C++程序员为此竞折腰)</p>
<h2 id="9-8-Goroutines和线程"><a href="#9-8-Goroutines和线程" class="headerlink" title="9.8. Goroutines和线程"></a>9.8. Goroutines和线程</h2><h3 id="9-8-1-动态栈"><a href="#9-8-1-动态栈" class="headerlink" title="9.8.1. 动态栈"></a>9.8.1. 动态栈</h3><p>每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。</p>
<p>相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。</p>
<h3 id="9-8-2-Goroutine调度"><a href="#9-8-2-Goroutine调度" class="headerlink" title="9.8.2. Goroutine调度"></a>9.8.2. Goroutine调度</h3><p>OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。</p>
<p>Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（译注：按程序独立）。</p>
<p>和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>
<h3 id="9-8-3-GOMAXPROCS"><a href="#9-8-3-GOMAXPROCS" class="headerlink" title="9.8.3. GOMAXPROCS"></a>9.8.3. GOMAXPROCS</h3><p>Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。(GOMAXPROCS是前面说的m:n调度中的n)。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。 </p>
<h3 id="9-8-4-Goroutine没有ID号"><a href="#9-8-4-Goroutine没有ID号" class="headerlink" title="9.8.4. Goroutine没有ID号"></a>9.8.4. Goroutine没有ID号</h3><p>goroutine没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层(这个存储层有可能是tls)查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变——比如一些worker线程之类的——那么函数的行为就会变得神秘莫测。</p>
<p>Go鼓励更为简单的模式，这种模式下参数(译注：外部显式参数和内部显式参数。tls 中的内容算是”外部”隐式参数)对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。</p>
<h1 id="10-包"><a href="#10-包" class="headerlink" title="10 包"></a>10 包</h1><h2 id="10-1-包简介"><a href="#10-1-包简介" class="headerlink" title="10.1 包简介"></a>10.1 包简介</h2><p>Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。</p>
<h2 id="10-2-导入路径"><a href="#10-2-导入路径" class="headerlink" title="10.2. 导入路径"></a>10.2. 导入路径</h2><p>如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。</p>
<h2 id="10-3-包声明"><a href="#10-3-包声明" class="headerlink" title="10.3. 包声明"></a>10.3. 包声明</h2><p>例如，math/rand包的每个源文件的开头都包含<code>package rand</code>包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。</p>
<p>通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。 </p>
<p>关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</p>
<p>第二个例外，包所在的目录中可能有一些文件名是以<code>_test.go</code>为后缀的Go源文件（译注：前面必须有其它的字符，因为以<code>_</code>或<code>.</code>开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以<code>_test</code>为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以<code>_test</code>为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。</p>
<p>第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如”gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。</p>
<h2 id="10-4-导入声明"><a href="#10-4-导入声明" class="headerlink" title="10.4. 导入声明"></a>10.4. 导入声明</h2><p>如果我们想同时导入两个有着名字相同的包，例如math/rand包和crypto/rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import (
    &quot;crypto&#x2F;rand&quot;
    mrand &quot;math&#x2F;rand&quot; &#x2F;&#x2F; alternative name mrand avoids conflict
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便</p>
<p>每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。</p>
<h2 id="10-5-包的匿名导入"><a href="#10-5-包的匿名导入" class="headerlink" title="10.5. 包的匿名导入"></a>10.5. 包的匿名导入</h2><p>如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线<code>_</code>来重命名导入的包。像往常一样，下划线<code>_</code>为空白标识符，并不能被访问。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import _ &quot;image&#x2F;png&quot; &#x2F;&#x2F; register PNG decoder<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。</p>
<p>数据库包database/sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import (
    &quot;database&#x2F;sql&quot;
    _ &quot;github.com&#x2F;lib&#x2F;pq&quot;              &#x2F;&#x2F; enable support for Postgres
    _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot; &#x2F;&#x2F; enable support for MySQL
)

db, err &#x3D; sql.Open(&quot;postgres&quot;, dbname) &#x2F;&#x2F; OK
db, err &#x3D; sql.Open(&quot;mysql&quot;, dbname)    &#x2F;&#x2F; OK
db, err &#x3D; sql.Open(&quot;sqlite3&quot;, dbname)  &#x2F;&#x2F; returns error: unknown driver &quot;sqlite3&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="10-6-包和命名"><a href="#10-6-包和命名" class="headerlink" title="10.6. 包和命名"></a>10.6. 包和命名</h2><p>当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。</p>
<p>要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，</p>
<p>包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。</p>
<h2 id="10-7-工具"><a href="#10-7-工具" class="headerlink" title="10.7. 工具"></a>10.7. 工具</h2><h3 id="10-7-1-工作区结构"><a href="#10-7-1-工作区结构" class="headerlink" title="10.7.1. 工作区结构"></a>10.7.1. 工作区结构</h3><p>对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了</p>
<p>第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径</p>
<h3 id="10-7-2-下载包"><a href="#10-7-2-下载包" class="headerlink" title="10.7.2. 下载包"></a>10.7.2. 下载包</h3><p>使用命令<code>go get</code>可以下载一个单一的包或者用<code>...</code>下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org/x/net/html自动出现在本地工作区目录的原因。</p>
<p><code>go get</code>命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行<code>go help importpath</code>获取相关的信息。</p>
<p><code>go get</code>命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org/x/net包目录对应一个Git仓库：</p>
<pre class="line-numbers language-none"><code class="language-none">$ cd $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;net
$ git remote -v
origin  https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (fetch)
origin  https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 <a target="_blank" rel="noopener" href="https://golang.org/x/net/html">https://golang.org/x/net/html</a> 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;fetch https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html | grep go-import
&lt;meta name&#x3D;&quot;go-import&quot;
      content&#x3D;&quot;golang.org&#x2F;x&#x2F;net git https:&#x2F;&#x2F;go.googlesource.com&#x2F;net&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果指定<code>-u</code>命令行标志参数，<code>go get</code>命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。</p>
<p><code>go get -u</code>命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org/x/net/html导入路径可能会变为gopl.io/vendor/golang.org/x/net/html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。</p>
<h3 id="10-7-3-构建包"><a href="#10-7-3-构建包" class="headerlink" title="10.7.3. 构建包"></a>10.7.3. 构建包</h3><p><code>go build</code>命令编译命令行参数指定的每个包。</p>
<h3 id="10-7-4-包文档"><a href="#10-7-4-包文档" class="headerlink" title="10.7.4. 包文档"></a>10.7.4. 包文档</h3><p>Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。</p>
<p>Go语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Fprintf formats according to a format specifier and writes to w.
&#x2F;&#x2F; It returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (int, error)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Fprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。</p>
<h3 id="10-7-5-内部包"><a href="#10-7-5-内部包" class="headerlink" title="10.7.5. 内部包"></a>10.7.5. 内部包</h3><p>为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。</p>
<pre class="line-numbers language-none"><code class="language-none">net&#x2F;http
net&#x2F;http&#x2F;internal&#x2F;chunked
net&#x2F;http&#x2F;httputil
net&#x2F;url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="10-7-6-查询包"><a href="#10-7-6-查询包" class="headerlink" title="10.7.6. 查询包"></a>10.7.6. 查询包</h3><p><code>go list</code>命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径</p>
<h1 id="第十一章-测试"><a href="#第十一章-测试" class="headerlink" title="第十一章　测试"></a>第十一章　测试</h1><p>现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试</p>
<p>我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。</p>
<p>Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。</p>
<p>在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。我们必须小心处理边界条件，思考合适的数据结构，推断合适的输入应该产生什么样的结果输出。编写测试代码和编写普通的Go代码过程是类似的；它并不需要学习新的符号、规则和工具。</p>
<h2 id="11-1-go-test"><a href="#11-1-go-test" class="headerlink" title="11.1 go test"></a>11.1 go test</h2><p>go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以<code>_test.go</code>为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。</p>
<p>在<code>*_test.go</code>文件中，有三种类型的函数：测试函数、基准测试(benchmark)函数、示例函数。一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。</p>
<p>go test命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<h2 id="11-2-测试函数"><a href="#11-2-测试函数" class="headerlink" title="11.2 测试函数"></a>11.2 测试函数</h2><p>每个测试函数必须导入testing包。测试函数有如下的签名：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestName(t *testing.T) &#123;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，其中t参数用于报告测试失败和附加的日志信息</p>
<p>先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。</p>
<p>先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。</p>
<p>参数<code>-v</code>可用于打印每个测试函数的名字和运行时间：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数<code>-run</code>对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被<code>go test</code>测试命令运行：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -v -run&#x3D;&quot;French|Canal&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的<code>go test</code>命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。</p>
<p>失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。</p>
<p>如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。</p>
<h3 id="11-2-1-随机测试"><a href="#11-2-1-随机测试" class="headerlink" title="11.2.1. 随机测试"></a>11.2.1. 随机测试</h3><p>表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。</p>
<p>那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。</p>
<p>下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import &quot;math&#x2F;rand&quot;

&#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents
&#x2F;&#x2F; are derived from the pseudo-random number generator rng.
func randomPalindrome(rng *rand.Rand) string &#123;
    n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24
    runes :&#x3D; make([]rune, n)
    for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;
        r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\u0999&#39;
        runes[i] &#x3D; r
        runes[n-1-i] &#x3D; r
    &#125;
    return string(runes)
&#125;

func TestRandomPalindromes(t *testing.T) &#123;
    &#x2F;&#x2F; Initialize a pseudo-random number generator.
    seed :&#x3D; time.Now().UTC().UnixNano()
    t.Logf(&quot;Random seed: %d&quot;, seed)
    rng :&#x3D; rand.New(rand.NewSource(seed))

    for i :&#x3D; 0; i &lt; 1000; i++ &#123;
        p :&#x3D; randomPalindrome(rng)
        if !IsPalindrome(p) &#123;
            t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入IsPalindrome的p参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。</p>
<p>通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。</p>
<h3 id="11-2-2-测试一个命令"><a href="#11-2-2-测试一个命令" class="headerlink" title="11.2.2. 测试一个命令"></a>11.2.2. 测试一个命令</h3><p>要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。</p>
<h3 id="11-2-3-白盒测试"><a href="#11-2-3-白盒测试" class="headerlink" title="11.2.3. 白盒测试"></a>11.2.3. 白盒测试</h3><p>一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。</p>
<p>例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（<strong>白盒测试只是一个传统的名称，其实称为clear box测试会更准确。</strong>）</p>
<p>黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。</p>
<h3 id="11-2-4-外部测试包"><a href="#11-2-4-外部测试包" class="headerlink" title="11.2.4. 外部测试包"></a>11.2.4. 外部测试包</h3><p>我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net/url包所在的目录声明一个独立的url_test测试包。其中包名的<code>_test</code>后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net/url_test会更容易理解，但实际上它并不能被其他任何包导入。</p>
<p>因为外部测试包是一个独立的包，所以能够导入那些<code>依赖待测代码本身</code>的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。</p>
<p><img src="https://docs.hacknode.org/gopl-zh/images/ch11-02.png" alt="img"></p>
<p>通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。</p>
<h3 id="11-2-5-编写有效的测试"><a href="#11-2-5-编写有效的测试" class="headerlink" title="11.2.5. 编写有效的测试"></a>11.2.5. 编写有效的测试</h3><p>许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 == 1”或成页的海量跟踪日志。</p>
<p>Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。</p>
<p>下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;testing&quot;
)
&#x2F;&#x2F; A poor assertion function.
func assertEqual(x, y int) &#123;
    if x !&#x3D; y &#123;
        panic(fmt.Sprintf(&quot;%d !&#x3D; %d&quot;, x, y))
    &#125;
&#125;
func TestSplit(t *testing.T) &#123;
    words :&#x3D; strings.Split(&quot;a:b:c&quot;, &quot;:&quot;)
    assertEqual(len(words), 3)
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestSplit(t *testing.T) &#123;
    s, sep :&#x3D; &quot;a:b:c&quot;, &quot;:&quot;
    words :&#x3D; strings.Split(s, sep)
    if got, want :&#x3D; len(words), 3; got !&#x3D; want &#123;
        t.Errorf(&quot;Split(%q, %q) returned %d words, want %d&quot;,
            s, sep, got, want)
    &#125;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像IsPalindrome的表驱动测试那样来准备更多的s和sep测试用例。</p>
<h3 id="11-2-6-避免脆弱的测试"><a href="#11-2-6-避免脆弱的测试" class="headerlink" title="11.2.6. 避免脆弱的测试"></a>11.2.6. 避免脆弱的测试</h3><p>避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。</p>
<h2 id="11-3-测试覆盖率"><a href="#11-3-测试覆盖率" class="headerlink" title="11.3. 测试覆盖率"></a>11.3. 测试覆盖率</h2><p>就其性质而言，测试不可能是完整的</p>
<p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化——即使最简单的程序的动态也是难以精确测量的——但是有启发式方法来帮助我们编写有效的测试代码。</p>
<p>这些启发式方法中，语句的覆盖率是最简单和最广泛使用的。语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。</p>
<p>首先，我们要确保所有的测试都正常通过：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -v -run&#x3D;Coverage gopl.io&#x2F;ch7&#x2F;eval
&#x3D;&#x3D;&#x3D; RUN TestCoverage
--- PASS: TestCoverage (0.00s)
PASS
ok      gopl.io&#x2F;ch7&#x2F;eval         0.011s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面这个命令可以显示测试覆盖率工具的使用用法：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go tool cover
Usage of &#39;go tool cover&#39;:
Given a coverage profile produced by &#39;go test&#39;:
    go test -coverprofile&#x3D;c.out

Open a web browser displaying annotated source code:
    go tool cover -html&#x3D;c.out
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>go tool</code>命令运行Go工具链的底层可执行程序。这些底层可执行程序放在$GOROOT/pkg/tool/${GOOS}_${GOARCH}目录。因为有<code>go build</code>命令的原因，我们很少直接调用这些底层工具。</p>
<p>现在我们可以用<code>-coverprofile</code>标志参数重新运行测试：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval
ok      gopl.io&#x2F;ch7&#x2F;eval         0.032s      coverage: 68.5% of statements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用<code>go test -cover</code>。）</p>
<p>如果使用了<code>-covermode=count</code>标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。</p>
<p>为了收集数据，我们运行了测试覆盖率工具，打印了测试日志，生成一个HTML报告，然后在浏览器中打开（图11.3）。</p>
<pre class="line-numbers language-none"><code class="language-none">$ go tool cover -html&#x3D;c.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；因为对于逻辑复杂的语句需要针对不同的输入执行多次。有一些语句，例如上面的panic语句则永远都不会被执行到。另外，还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试从本质上来说是一个比较务实的工作，编写测试代码和编写应用代码的成本对比是需要考虑的。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。</p>
<h2 id="11-4-基准测试"><a href="#11-4-基准测试" class="headerlink" title="11.4. 基准测试"></a>11.4. 基准测试</h2><p>基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个<code>*testing.B</code>类型的参数；<code>*testing.B</code>参数除了提供和<code>*testing.T</code>类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。</p>
<p>下面是IsPalindrome函数的基准测试，其中循环将执行N次。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">import &quot;testing&quot;

func BenchmarkIsPalindrome(b *testing.B) &#123;
    for i :&#x3D; 0; i &lt; b.N; i++ &#123;
        IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过<code>-bench</code>命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和<code>-bench=IsPalindrome</code>参数是等价的效果。</p>
<pre class="line-numbers language-none"><code class="language-none">$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch11&#x2F;word2
$ go test -bench&#x3D;.
PASS
BenchmarkIsPalindrome-8 1000000                1035 ns&#x2F;op
ok      gopl.io&#x2F;ch11&#x2F;word2      2.179s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。</p>
<p>报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。</p>
<p>循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。</p>
<p>这个基准测试告诉了我们某个具体操作所需的绝对时间，但我们往往想知道的是两个不同的操作的时间对比。例如，如果一个函数需要1ms处理1,000个元素，那么处理10000或1百万将需要多少时间呢？这样的比较揭示了渐近增长函数的运行时间。另一个例子：I/O缓存该设置为多大呢？基准测试可以帮助我们选择在性能达标情况下所需的最小内存。第三个例子：对于一个确定的工作哪种算法更好？基准测试可以评估两种不同算法对于相同的输入在不同的场景和负载下的优缺点。</p>
<p>比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func benchmark(b *testing.B, size int) &#123; &#x2F;* ... *&#x2F; &#125;
func Benchmark10(b *testing.B)         &#123; benchmark(b, 10) &#125;
func Benchmark100(b *testing.B)        &#123; benchmark(b, 100) &#125;
func Benchmark1000(b *testing.B)       &#123; benchmark(b, 1000) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。</p>
<p>比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。</p>
<h2 id="11-5-剖析"><a href="#11-5-剖析" class="headerlink" title="11.5. 剖析"></a>11.5. 剖析</h2><p>基准测试(Benchmark)对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化</p>
<p>当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。</p>
<p>Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的<code>go test</code>工具对几种分析方式都提供了支持。</p>
<p>CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。</p>
<p>堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。</p>
<p>阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</p>
<p>只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ go test -cpuprofile&#x3D;cpu.out
$ go test -blockprofile&#x3D;block.out
$ go test -memprofile&#x3D;mem.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。</p>
<p>一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应<code>go tool pprof</code>命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。</p>
<p>为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然<code>go test</code>通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。</p>
<p>本书最后的两章是讨论reflect和unsafe包,<strong>一般的Go程序员很少使用它们，事实上也很少需要用到</strong>。因此，如果你还没有写过任何真实的Go程序的话，现在可以先去写些代码了。</p>
<h1 id="第十二章-反射"><a href="#第十二章-反射" class="headerlink" title="第十二章　反射"></a>第十二章　反射</h1><p>Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。</p>
<p>在本章，我们将探讨Go语言的反射特性，看看它可以给语言增加哪些表达力，以及在两个至关重要的API是如何使用反射机制的：一个是fmt包提供的字符串格式化功能，另一个是类似encoding/json和encoding/xml提供的针对特定协议的编解码功能。对于我们在4.6节中看到过的text/template和html/template包，它们的实现也是依赖反射技术的。然后，反射是一个复杂的内省技术，不应该随意使用，因此，尽管上面这些包内部都是用反射技术实现的，但是它们自己的API都没有公开反射相关的接口。</p>
<h2 id="12-1-为何需要反射"><a href="#12-1-为何需要反射" class="headerlink" title="12.1. 为何需要反射?"></a>12.1. 为何需要反射?</h2><p>有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在。</p>
<p>一个大家熟悉的例子是fmt.Fprintf函数提供的字符串格式化处理逻辑，它可以用来对任意类型的值格式化并打印，甚至支持用户自定义的类型。</p>
<p>我们首先用switch类型分支来测试输入参数是否实现了String方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个值的动态类型是否是string、int、bool等基础类型，并在每种情况下执行相应的格式化操作。</p>
<p>但是我们如何处理其它类似[]float64、map[string][]string等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理类似url.Values这样的具名类型呢？即使类型分支可以识别出底层的基础类型是map[string][]string，但是它并不匹配url.Values类型，因为它们是两种不同的类型，而且switch类型分支也不可能包含每个类似url.Values的类型，这会导致对这些库的依赖。</p>
<p>没有办法来检查未知类型的表示方式，我们被卡住了。这就是我们为何需要反射的原因。</p>
<h2 id="12-2-reflect-Type和reflect-Value"><a href="#12-2-reflect-Type和reflect-Value" class="headerlink" title="12.2. reflect.Type和reflect.Value"></a>12.2. reflect.Type和reflect.Value</h2><p>反射是由 reflect 包提供的。 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 它是一个接口, 有许多方法来区分类型以及检查它们的组成部分, 例如一个结构体的成员或一个函数的参数等. 唯一能反映 reflect.Type 实现的是接口的类型描述信息(§7.5), 也正是这个实体标识了接口值的动态类型.</p>
<p>函数 reflect.TypeOf 接受任意的 interface{} 类型, 并以reflect.Type形式返回其动态类型:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">t :&#x3D; reflect.TypeOf(3)  &#x2F;&#x2F; a reflect.Type
fmt.Println(t.String()) &#x2F;&#x2F; &quot;int&quot;
fmt.Println(t)          &#x2F;&#x2F; &quot;int&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>根据我的经验，感觉反射的东西，不是经常用到，属于那种用到再查的知识，（go并不像java那么面向对象）</p>
<h1 id="第十三章-底层编程"><a href="#第十三章-底层编程" class="headerlink" title="第十三章　底层编程"></a>第十三章　底层编程</h1><p>Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出错的用法。编译时类型检查可以发现大多数类型不匹配的操作，例如两个字符串做减法的错误。字符串、map、slice和chan等所有的内置类型，都有严格的类型转换规则。</p>
<p>对于无法静态检测到的错误，例如数组访问越界或使用空指针，运行时动态检测可以保证程序在遇到问题的时候立即终止并打印相关的错误信息。自动内存管理（垃圾内存自动回收）可以消除大部分野指针和内存泄漏相关的问题。</p>
<p>Go语言的实现刻意隐藏了很多底层细节。我们无法知道一个结构体真实的内存布局，也无法获取一个运行时函数对应的机器码，也无法知道当前的goroutine是运行在哪个操作系统线程之上。事实上，Go语言的调度器会自己决定是否需要将某个goroutine从一个操作系统线程转移到另一个操作系统线程。一个指向变量的指针也并没有展示变量真实的地址。因为垃圾回收器可能会根据需要移动变量的内存位置，当然变量对应的地址也会被自动更新。</p>
<p>总的来说，Go语言的这些特性使得Go程序相比较低级的C语言来说更容易预测和理解，程序也不容易崩溃。通过隐藏底层的实现细节，也使得Go语言编写的程序具有高度的可移植性，因为语言的语义在很大程度上是独立于任何编译器实现、操作系统和CPU系统结构的（当然也不是完全绝对独立：例如int等类型就依赖于CPU机器字的大小，某些表达式求值的具体顺序，还有编译器实现的一些额外的限制等）。</p>
<p>有时候我们可能会放弃使用部分语言特性而优先选择具有更好性能的方法，例如需要与其他语言编写的库进行互操作，或者用纯Go语言无法实现的某些函数。</p>
<p>在本章，我们将展示如何使用unsafe包来摆脱Go语言规则带来的限制，讲述如何创建C语言函数库的绑定，以及如何进行系统调用。</p>
<p><strong>本章提供的方法不应该轻易使用</strong>（译注：属于黑魔法，虽然功能很强大，但是也容易误伤到自己）如果没有处理好细节，它们可能导致各种不可预测的并且隐晦的错误，甚至连有经验的C语言程序员也无法理解这些错误。使用unsafe包的同时也放弃了Go语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的Go语言中很可能会被改变。</p>
<p>要注意的是，unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布局相关的细节。将这些特性封装到一个独立的包中，是为在极少数情况下需要使用的时候，同时引起人们的注意（译注：因为看包的名字就知道使用unsafe包是不安全的）。此外，有一些环境因为安全的因素可能限制这个包的使用。</p>
<p>不过unsafe包被广泛地用于比较低级的包, 例如runtime、os、syscall还有net包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用unsafe包的。</p>
<h2 id="13-1-unsafe-Sizeof-Alignof-和-Offsetof"><a href="#13-1-unsafe-Sizeof-Alignof-和-Offsetof" class="headerlink" title="13.1. unsafe.Sizeof, Alignof 和 Offsetof"></a>13.1. unsafe.Sizeof, Alignof 和 Offsetof</h2><h2 id="13-4-通过cgo调用C代码"><a href="#13-4-通过cgo调用C代码" class="headerlink" title="13.4. 通过cgo调用C代码"></a>13.4. 通过cgo调用C代码</h2><p>Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景，或者是从一个C++语言实现的嵌入式数据库查询记录的场景，或者是使用Fortran语言实现的一些线性代数库的场景。C语言作为一个通用语言，很多库会选择提供一个C兼容的API，然后用其他不同的编程语言实现（译者：Go语言需要也应该拥抱这些巨大的代码遗产）。</p>
<p>在本节中，我们将构建一个简易的数据压缩程序，使用了一个Go语言自带的叫cgo的用于支援C语言函数调用的工具。这类工具一般被称为 <em>foreign-function interfaces</em> （简称ffi）, 并且在类似工具中cgo也不是唯一的。SWIG（ <a target="_blank" rel="noopener" href="http://swig.org/">http://swig.org</a> ）是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支援C++的特性，但SWIG并不是我们要讨论的主题</p>
<p>如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了（译注：用os/exec包调用子进程的方法会导致程序运行时依赖那个应用程序）。下面我们将通过一个例子讲述cgo的具体用法。</p>
<p>译注：本章采用的代码都是最新的。因为之前已经出版的书中包含的代码只能在Go1.5之前使用。从Go1.6开始，Go语言已经明确规定了哪些Go语言指针可以直接传入C语言函数。新代码重点是增加了bz2alloc和bz2free的两个函数，用于bz_stream对象空间的申请和释放操作</p>
<p>其中<code>import &quot;C&quot;</code>的语句是比较特别的。其实并没有一个叫C的包，但是这行语句会让Go编译程序在编译之前先运行cgo工具。</p>
<h2 id="13-5-几点忠告"><a href="#13-5-几点忠告" class="headerlink" title="13.5. 几点忠告"></a>13.5. 几点忠告</h2><p>我们在前一章结尾的时候，我们警告要谨慎使用reflect包。那些警告同样适用于本章的unsafe包。</p>
<p>高级语言使得程序员不用再关心真正运行程序的指令细节，同时也不再需要关注许多如内存布局之类的实现细节。因为高级语言这个绝缘的抽象层，我们可以编写安全健壮的，并且可以运行在不同操作系统上的具有高度可移植性的程序。</p>
<p>但是unsafe包，它让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，虽然可能是为了获得更好的性能。但是代价就是牺牲了可移植性和程序安全，因此使用unsafe包是一个危险的行为。我们对何时以及如何使用unsafe包的建议和我们在11.5节提到的Knuth对过早优化的建议类似。大多数Go程序员可能永远不会需要直接使用unsafe包。当然，也永远都会有一些需要使用unsafe包实现会更简单的场景。如果确实认为使用unsafe包是最理想的方式，那么应该尽可能将它限制在较小的范围，这样其它代码就可以忽略unsafe的影响。</p>
<p>现在，赶紧将最后两章抛入脑后吧。编写一些实实在在的应用是真理。请远离reflect的unsafe包，除非你确实需要它们。</p>
<p>最后，用Go快乐地编程。我们希望你能像我们一样喜欢Go语言。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="常青 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>常青
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://changqingaas.github.io/%E4%B9%A6%E6%91%98/Go/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/" title="《Go语言圣经》阅读笔记">https://changqingaas.github.io/书摘/Go/go语言圣经/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E4%B9%A6%E6%91%98/Others/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="prev" title="《把时间当做朋友》阅读笔记">
                  <i class="fa fa-chevron-left"></i> 《把时间当做朋友》阅读笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E4%B9%A6%E6%91%98/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" rel="next" title="《Go语言高级编程》阅读笔记">
                  《Go语言高级编程》阅读笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">常青</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">474k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:11</span>
  </span>
</div>
<div class="busuanzi-count">
</div>

<!--
-->


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    该博客访客共<span id="busuanzi_value_site_uv"></span>人
</span>
</div>


  <script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);


    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.5/pdfobject.min.js","integrity":"sha256-YuNlP9i6s/WH7EaU2kErloo9Vc85C3WVqhoMDgsEVpY="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","cdn":"//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>

<!-- 樱花特效 -->
  
      <script async src="/js/src/fairyDustCursor.js"></script>
  
